{"version":3,"file":"orbitCameraPointersInput.js","sourceRoot":"","sources":["../../../../../dev/core/src/Cameras/Inputs/orbitCameraPointersInput.ts"],"names":[],"mappings":";AACA,OAAO,EAAE,SAAS,EAAE,MAAM,uBAAuB,CAAC;AAGlD,OAAO,EAAE,uBAAuB,EAAE,MAAM,2BAA2B,CAAC;AAEpE;;;GAGG;AACH,MAAM,OAAgB,wBAAyB,SAAQ,uBAAuB;IAA9E;;QACI;;WAEG;QAEI,cAAS,GAAY,IAAI,CAAC;QAEjC;;WAEG;QAEI,sBAAiB,GAAY,IAAI,CAAC;QAEzC;;;WAGG;QAEI,yBAAoB,GAAY,IAAI,CAAC;QAElC,gBAAW,GAAY,KAAK,CAAC;QAC7B,4BAAuB,GAAW,CAAC,CAAC;QACpC,0BAAqB,GAAY,KAAK,CAAC;IAkFrD,CAAC;IAhFa,iBAAiB,CAAC,6BAAqC,EAAE,qBAA6B,IAAS,CAAC;IAEhG,yBAAyB,CAAC,8BAAsD,EAAE,sBAA8C,IAAS,CAAC;IAEpJ;;;;;;;;;OASG;IACa,YAAY,CACxB,OAA+B,EAC/B,OAA+B,EAC/B,4BAAoC,EACpC,oBAA4B,EAC5B,6BAAqD,EACrD,qBAA6C;QAE7C,IAAI,4BAA4B,KAAK,CAAC,IAAI,6BAA6B,KAAK,IAAI,EAAE,CAAC;YAC/E,kDAAkD;YAClD,2CAA2C;YAC3C,oEAAoE;YACpE,OAAO;QACX,CAAC;QACD,IAAI,oBAAoB,KAAK,CAAC,IAAI,qBAAqB,KAAK,IAAI,EAAE,CAAC;YAC/D,yDAAyD;YACzD,OAAO;QACX,CAAC;QAED,oCAAoC;QACpC,IAAI,IAAI,CAAC,oBAAoB,EAAE,CAAC;YAC5B,IAAI,CAAC,iBAAiB,CAAC,4BAA4B,EAAE,oBAAoB,CAAC,CAAC;YAC3E,IAAI,CAAC,yBAAyB,CAAC,6BAA6B,EAAE,qBAAqB,CAAC,CAAC;YAErF,kDAAkD;QACtD,CAAC;aAAM,IAAI,IAAI,CAAC,iBAAiB,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YAClD,IAAI,CAAC,uBAAuB,EAAE,CAAC;YAE/B,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,qBAAqB,EAAE,CAAC;gBACjD,kEAAkE;gBAClE,IAAI,CAAC,iBAAiB,CAAC,4BAA4B,EAAE,oBAAoB,CAAC,CAAC;gBAE3E,4DAA4D;gBAC5D,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;YAC5B,CAAC;iBAAM,CAAC;gBACJ,iFAAiF;gBACjF,IAAI,CAAC,yBAAyB,CAAC,6BAA6B,EAAE,qBAAqB,CAAC,CAAC;YACzF,CAAC;YAED,iCAAiC;QACrC,CAAC;aAAM,IAAI,IAAI,CAAC,iBAAiB,EAAE,CAAC;YAChC,IAAI,CAAC,yBAAyB,CAAC,6BAA6B,EAAE,qBAAqB,CAAC,CAAC;YAErF,iCAAiC;QACrC,CAAC;aAAM,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YACxB,IAAI,CAAC,iBAAiB,CAAC,4BAA4B,EAAE,oBAAoB,CAAC,CAAC;QAC/E,CAAC;IACL,CAAC;IAED;;;;OAIG;IACa,UAAU,CAAC,IAAmB;QAC1C,IAAI,CAAC,uBAAuB,GAAG,CAAC,CAAC;QACjC,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;IAC7B,CAAC;IAED;;OAEG;IACa,WAAW;QACvB,IAAI,CAAC,uBAAuB,GAAG,CAAC,CAAC;QACjC,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC;IAC7B,CAAC;CACJ;AAnGU;IADN,SAAS,EAAE;2DACqB;AAM1B;IADN,SAAS,EAAE;mEAC6B;AAOlC;IADN,SAAS,EAAE;sEACgC","sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { PointerTouch } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\nimport { BaseCameraPointersInput } from \"./BaseCameraPointersInput\";\r\n\r\n/**\r\n * Used by both arcrotatecamera and geospatialcamera, OrbitCameraPointersInputs handle pinchToZoom and multiTouchPanning\r\n * as though you are orbiting around a target point\r\n */\r\nexport abstract class OrbitCameraPointersInput extends BaseCameraPointersInput {\r\n    /**\r\n     * Defines whether zoom (2 fingers pinch) is enabled through multitouch\r\n     */\r\n    @serialize()\r\n    public pinchZoom: boolean = true;\r\n\r\n    /**\r\n     * Defines whether panning (2 fingers swipe) is enabled through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanning: boolean = true;\r\n\r\n    /**\r\n     * Defines whether panning is enabled for both pan (2 fingers swipe) and\r\n     * zoom (pinch) through multitouch.\r\n     */\r\n    @serialize()\r\n    public multiTouchPanAndZoom: boolean = true;\r\n\r\n    protected _isPinching: boolean = false;\r\n    protected _twoFingerActivityCount: number = 0;\r\n    protected _shouldStartPinchZoom: boolean = false;\r\n\r\n    protected _computePinchZoom(_previousPinchSquaredDistance: number, _pinchSquaredDistance: number): void {}\r\n\r\n    protected _computeMultiTouchPanning(_previousMultiTouchPanPosition: Nullable<PointerTouch>, _multiTouchPanPosition: Nullable<PointerTouch>): void {}\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * Override this method to provide functionality.\r\n     * @param _pointA First point in the pair\r\n     * @param _pointB Second point in the pair\r\n     * @param previousPinchSquaredDistance Sqr Distance between the points the last time this event was fired (by this input)\r\n     * @param pinchSquaredDistance Sqr Distance between the points this time\r\n     * @param previousMultiTouchPanPosition Previous center point between the points\r\n     * @param multiTouchPanPosition Current center point between the points\r\n     */\r\n    public override onMultiTouch(\r\n        _pointA: Nullable<PointerTouch>,\r\n        _pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {\r\n        if (previousPinchSquaredDistance === 0 && previousMultiTouchPanPosition === null) {\r\n            // First time this method is called for new pinch.\r\n            // Next time this is called there will be a\r\n            // previousPinchSquaredDistance and pinchSquaredDistance to compare.\r\n            return;\r\n        }\r\n        if (pinchSquaredDistance === 0 && multiTouchPanPosition === null) {\r\n            // Last time this method is called at the end of a pinch.\r\n            return;\r\n        }\r\n\r\n        // Zoom and panning enabled together\r\n        if (this.multiTouchPanAndZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom and panning enabled but only one at a time\r\n        } else if (this.multiTouchPanning && this.pinchZoom) {\r\n            this._twoFingerActivityCount++;\r\n\r\n            if (this._isPinching || this._shouldStartPinchZoom) {\r\n                // Since pinch has not been active long, assume we intend to zoom.\r\n                this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n\r\n                // Since we are pinching, remain pinching on next iteration.\r\n                this._isPinching = true;\r\n            } else {\r\n                // Pause between pinch starting and moving implies not a zoom event. Pan instead.\r\n                this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n            }\r\n\r\n            // Panning enabled, zoom disabled\r\n        } else if (this.multiTouchPanning) {\r\n            this._computeMultiTouchPanning(previousMultiTouchPanPosition, multiTouchPanPosition);\r\n\r\n            // Zoom enabled, panning disabled\r\n        } else if (this.pinchZoom) {\r\n            this._computePinchZoom(previousPinchSquaredDistance, pinchSquaredDistance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public override onButtonUp(_evt: IPointerEvent): void {\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     */\r\n    public override onLostFocus(): void {\r\n        this._twoFingerActivityCount = 0;\r\n        this._isPinching = false;\r\n    }\r\n}\r\n"]}