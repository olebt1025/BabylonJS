{"version":3,"file":"arcRotateCameraPointersInput.js","sourceRoot":"","sources":["../../../../../dev/core/src/Cameras/Inputs/arcRotateCameraPointersInput.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport { serialize } from \"../../Misc/decorators\";\r\nimport type { ArcRotateCamera } from \"../../Cameras/arcRotateCamera\";\r\nimport { CameraInputTypes } from \"../../Cameras/cameraInputsManager\";\r\nimport { OrbitCameraPointersInput } from \"../../Cameras/Inputs/orbitCameraPointersInput\";\r\nimport type { PointerTouch } from \"../../Events/pointerEvents\";\r\nimport type { IPointerEvent } from \"../../Events/deviceInputEvents\";\r\n\r\n/**\r\n * Manage the pointers inputs to control an arc rotate camera.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/cameras/customizingCameraInputs\r\n */\r\nexport class ArcRotateCameraPointersInput extends OrbitCameraPointersInput {\r\n    /**\r\n     * Defines the camera the input is attached to.\r\n     */\r\n    public camera: ArcRotateCamera;\r\n\r\n    /**\r\n     * The minimum radius used for pinch, to avoid radius lock at 0\r\n     */\r\n    public static MinimumRadiusForPinch: number = 0.001;\r\n\r\n    /**\r\n     * Gets the class name of the current input.\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"ArcRotateCameraPointersInput\";\r\n    }\r\n\r\n    /**\r\n     * Defines the buttons associated with the input to handle camera move.\r\n     */\r\n    @serialize()\r\n    public override buttons = [0, 1, 2];\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility  along the X axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityX = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer angular sensibility along the Y axis or how fast is\r\n     * the camera rotating.\r\n     */\r\n    @serialize()\r\n    public angularSensibilityY = 1000.0;\r\n\r\n    /**\r\n     * Defines the pointer pinch precision or how fast is the camera zooming.\r\n     */\r\n    @serialize()\r\n    public pinchPrecision = 12.0;\r\n\r\n    /**\r\n     * pinchDeltaPercentage will be used instead of pinchPrecision if different\r\n     * from 0.\r\n     * It defines the percentage of current camera.radius to use as delta when\r\n     * pinch zoom is used.\r\n     */\r\n    @serialize()\r\n    public pinchDeltaPercentage = 0;\r\n\r\n    /**\r\n     * When useNaturalPinchZoom is true, multi touch zoom will zoom in such\r\n     * that any object in the plane at the camera's target point will scale\r\n     * perfectly with finger motion.\r\n     * Overrides pinchDeltaPercentage and pinchPrecision.\r\n     */\r\n    @serialize()\r\n    public useNaturalPinchZoom: boolean = false;\r\n\r\n    /**\r\n     * Defines the pointer panning sensibility or how fast is the camera moving.\r\n     */\r\n    @serialize()\r\n    public panningSensibility: number = 1000.0;\r\n\r\n    /**\r\n     * Revers pinch action direction.\r\n     */\r\n    public pinchInwards = true;\r\n\r\n    private _isPanClick: boolean = false;\r\n\r\n    /**\r\n     * Move camera from multi touch panning positions.\r\n     * @param previousMultiTouchPanPosition\r\n     * @param multiTouchPanPosition\r\n     */\r\n    protected override _computeMultiTouchPanning(previousMultiTouchPanPosition: Nullable<PointerTouch>, multiTouchPanPosition: Nullable<PointerTouch>): void {\r\n        if (this.panningSensibility !== 0 && previousMultiTouchPanPosition && multiTouchPanPosition) {\r\n            const moveDeltaX = multiTouchPanPosition.x - previousMultiTouchPanPosition.x;\r\n            const moveDeltaY = multiTouchPanPosition.y - previousMultiTouchPanPosition.y;\r\n            this.camera.inertialPanningX += -moveDeltaX / this.panningSensibility;\r\n            this.camera.inertialPanningY += moveDeltaY / this.panningSensibility;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move camera from multitouch (pinch) zoom distances.\r\n     * @param previousPinchSquaredDistance\r\n     * @param pinchSquaredDistance\r\n     */\r\n    protected override _computePinchZoom(previousPinchSquaredDistance: number, pinchSquaredDistance: number): void {\r\n        const radius = this.camera.radius || ArcRotateCameraPointersInput.MinimumRadiusForPinch;\r\n        if (this.useNaturalPinchZoom) {\r\n            this.camera.radius = (radius * Math.sqrt(previousPinchSquaredDistance)) / Math.sqrt(pinchSquaredDistance);\r\n        } else if (this.pinchDeltaPercentage) {\r\n            this.camera.inertialRadiusOffset += (pinchSquaredDistance - previousPinchSquaredDistance) * 0.001 * radius * this.pinchDeltaPercentage;\r\n        } else {\r\n            this.camera.inertialRadiusOffset +=\r\n                (pinchSquaredDistance - previousPinchSquaredDistance) /\r\n                ((this.pinchPrecision * (this.pinchInwards ? 1 : -1) * (this.angularSensibilityX + this.angularSensibilityY)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if only a single touch is active.\r\n     * @param point current touch point\r\n     * @param offsetX offset on X\r\n     * @param offsetY offset on Y\r\n     */\r\n    public override onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void {\r\n        if (this.panningSensibility !== 0 && ((this._ctrlKey && this.camera._useCtrlForPanning) || this._isPanClick)) {\r\n            this.camera.inertialPanningX += -offsetX / this.panningSensibility;\r\n            this.camera.inertialPanningY += offsetY / this.panningSensibility;\r\n        } else {\r\n            this.camera.inertialAlphaOffset -= offsetX / this.angularSensibilityX;\r\n            this.camera.inertialBetaOffset -= offsetY / this.angularSensibilityY;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERDOUBLETAP event.\r\n     */\r\n    public override onDoubleTap() {\r\n        if (this.camera.useInputToRestoreState) {\r\n            this.camera.restoreState();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called on pointer POINTERMOVE event if multiple touches are active.\r\n     * @param pointA point A\r\n     * @param pointB point B\r\n     * @param previousPinchSquaredDistance distance between points in previous pinch\r\n     * @param pinchSquaredDistance distance between points in current pinch\r\n     * @param previousMultiTouchPanPosition multi-touch position in previous step\r\n     * @param multiTouchPanPosition multi-touch position in current step\r\n     */\r\n    public override onMultiTouch(\r\n        pointA: Nullable<PointerTouch>,\r\n        pointB: Nullable<PointerTouch>,\r\n        previousPinchSquaredDistance: number,\r\n        pinchSquaredDistance: number,\r\n        previousMultiTouchPanPosition: Nullable<PointerTouch>,\r\n        multiTouchPanPosition: Nullable<PointerTouch>\r\n    ): void {\r\n        this._shouldStartPinchZoom =\r\n            this._twoFingerActivityCount < 20 && Math.abs(Math.sqrt(pinchSquaredDistance) - Math.sqrt(previousPinchSquaredDistance)) > this.camera.pinchToPanMaxDistance;\r\n        super.onMultiTouch(pointA, pointB, previousPinchSquaredDistance, pinchSquaredDistance, previousMultiTouchPanPosition, multiTouchPanPosition);\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERDOWN event occurs. Ie, for each button\r\n     * press.\r\n     * @param evt Defines the event to track\r\n     */\r\n    public override onButtonDown(evt: IPointerEvent): void {\r\n        this._isPanClick = evt.button === this.camera._panningMouseButton;\r\n        super.onButtonDown(evt);\r\n    }\r\n\r\n    /**\r\n     * Called each time a new POINTERUP event occurs. Ie, for each button\r\n     * release.\r\n     * @param _evt Defines the event to track\r\n     */\r\n    public override onButtonUp(_evt: IPointerEvent): void {\r\n        super.onButtonUp(_evt);\r\n    }\r\n\r\n    /**\r\n     * Called when window becomes inactive.\r\n     */\r\n    public override onLostFocus(): void {\r\n        this._isPanClick = false;\r\n        super.onLostFocus();\r\n    }\r\n}\r\n(<any>CameraInputTypes)[\"ArcRotateCameraPointersInput\"] = ArcRotateCameraPointersInput;\r\n"]}