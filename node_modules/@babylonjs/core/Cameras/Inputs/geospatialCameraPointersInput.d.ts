import type { GeospatialCamera } from "../../Cameras/geospatialCamera.js";
import type { IPointerEvent } from "../../Events/deviceInputEvents.js";
import type { PointerTouch } from "../../Events/pointerEvents.js";
import type { Nullable } from "../../types.js";
import { OrbitCameraPointersInput } from "./orbitCameraPointersInput.js";
/**
 * @experimental
 * Geospatial camera inputs can simulate dragging the globe around or tilting the camera around some point on the globe
 * This class will update the GeospatialCameraMovement class's movementDeltaCurrentFrame, and the camera is responsible for using these updates to calculate viewMatrix appropriately
 *
 * As of right now, the camera correction logic (to keep the camera geospatially oriented around the globe) is happening within the camera class when calculating viewmatrix
 * As this is experimental, it is possible we move that correction step to live within the input class (to enable non-corrected translations in the future), say if we want to allow the camera to move outside of the globe's orbit
 *
 * Left mouse button: drag globe
 * Middle mouse button: tilt globe
 * Right mouse button: tilt globe
 *
 */
export declare class GeospatialCameraPointersInput extends OrbitCameraPointersInput {
    camera: GeospatialCamera;
    private _initialPinchSquaredDistance;
    private _pinchCentroid;
    /**
     * Defines the rotation sensitivity of the pointer when rotating camera around the x axis (pitch)
     * (Multiplied by the true pixel delta of pointer input, before rotation speed factor is applied by movement class)
     */
    pitchSensitivity: number;
    /**
     * Defines the rotation sensitivity of the pointer when rotating the camera around the Y axis (yaw)
     * (Multiplied by the true pixel delta of pointer input, before rotation speed factor is applied by movement class)
     */
    yawSensitivity: number;
    /**
     * Defines the distance used to consider the camera in pan mode vs pinch/zoom.
     * Basically if your fingers moves away from more than this distance you will be considered
     * in pinch mode.
     */
    pinchToPanMax: number;
    getClassName(): string;
    onButtonDown(evt: IPointerEvent): void;
    onTouch(point: Nullable<PointerTouch>, offsetX: number, offsetY: number): void;
    /**
     * Move camera from multitouch (pinch) zoom distances.
     * Zooms towards the centroid (midpoint between the two fingers).
     * @param previousPinchSquaredDistance
     * @param pinchSquaredDistance
     */
    protected _computePinchZoom(previousPinchSquaredDistance: number, pinchSquaredDistance: number): void;
    /**
     * Move camera from multi touch panning positions.
     * In geospatialcamera, multi touch panning tilts the globe (whereas single touch will pan/drag it)
     * @param previousMultiTouchPanPosition
     * @param multiTouchPanPosition
     */
    protected _computeMultiTouchPanning(previousMultiTouchPanPosition: Nullable<PointerTouch>, multiTouchPanPosition: Nullable<PointerTouch>): void;
    onDoubleTap(type: string): void;
    onMultiTouch(pointA: Nullable<PointerTouch>, pointB: Nullable<PointerTouch>, previousPinchSquaredDistance: number, pinchSquaredDistance: number, previousMultiTouchPanPosition: Nullable<PointerTouch>, multiTouchPanPosition: Nullable<PointerTouch>): void;
    onButtonUp(_evt: IPointerEvent): void;
    onLostFocus(): void;
    private _handleTilt;
}
