import { CameraMovement } from "./cameraMovement.js";
import type { GeospatialLimits } from "./Limits/geospatialLimits.js";
import { Vector3 } from "../Maths/math.vector.js";
import type { MeshPredicate } from "../Culling/ray.core.js";
import type { Scene } from "../scene.js";
import type { PickingInfo } from "../Collisions/pickingInfo.js";
import type { Nullable } from "../types.js";
import type { InterpolatingBehavior } from "../Behaviors/Cameras/interpolatingBehavior.js";
import type { GeospatialCamera } from "./geospatialCamera.js";
/**
 * Geospatial-specific camera movement system that extends the base movement with
 * raycasting and altitude-aware zoom constraints.
 *
 * This class encapsulates geospatial camera movement logic:
 * - Dragging in a way which keeps cursor anchored to globe
 * - Latitude-based pan speed dampening
 * - Zoom speed scaling based on distance to center
 * - Raycasting to determine zoom constraints based on terrain/globe
 * - Altitude-based zoom clamping
 * - Zoom direction calculation (towards cursor vs along look vector)
 */
export declare class GeospatialCameraMovement extends CameraMovement {
    limits: GeospatialLimits;
    private _cameraCenter;
    private _cameraLookAt;
    /** Predicate function to determine which meshes to pick against (e.g., globe mesh) */
    pickPredicate?: MeshPredicate;
    /** World-space picked point under cursor for zoom-to-cursor behavior (may be undefined) */
    computedPerFrameZoomPickPoint?: Vector3;
    zoomToCursor: boolean;
    private _tempPickingRay;
    private _hitPointRadius?;
    private _dragPlane;
    private _dragPlaneNormal;
    private _dragPlaneOriginPointEcef;
    private _dragPlaneHitPointLocal;
    private _previousDragPlaneHitPointLocal;
    constructor(scene: Scene, limits: GeospatialLimits, cameraPosition: Vector3, _cameraCenter: Vector3, _cameraLookAt: Vector3, pickPredicate?: MeshPredicate, behavior?: InterpolatingBehavior<GeospatialCamera>);
    startDrag(pointerX: number, pointerY: number): void;
    stopDrag(): void;
    /**
     * The previous drag plane hit point in local space is stored to compute the movement delta.
     * As the drag movement occurs, we will continuously recalculate this point. The delta between the previous and current hit points is the delta we will apply to the camera's localtranslation
     * @param hitPointRadius The distance between the world origin (center of globe) and the initial drag hit point
     * @param ray The ray from the camera to the new cursor location
     * @param localToEcefResult The matrix to convert from local to ECEF space
     */
    private _recalculateDragPlaneHitPoint;
    handleDrag(pointerX: number, pointerY: number): void;
    /** @override */
    computeCurrentFrameDeltas(): void;
    get isDragging(): boolean;
    handleZoom(zoomDelta: number, toCursor: boolean): void;
    pickAlongVector(vector: Vector3): Nullable<PickingInfo>;
}
/** @internal */
export declare function ClampCenterFromPolesInPlace(center: Vector3): Vector3;
/**
 * Helper to build east/north/up basis vectors at a world position.
 * Cross product order is swapped based on handedness so that the east vector
 * encodes the coordinate-system convention, removing the need for a separate yawScale.
 * @param worldPos - The position on the globe
 * @param refEast - Receives the east direction
 * @param refNorth - Receives the north direction
 * @param refUp - Receives the up (outward) direction
 * @param useRightHandedSystem - Whether the scene uses a right-handed coordinate system (default: false)
 * @internal
 */
export declare function ComputeLocalBasisToRefs(worldPos: Vector3, refEast: Vector3, refNorth: Vector3, refUp: Vector3, useRightHandedSystem?: boolean): void;
