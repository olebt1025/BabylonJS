{"version":3,"file":"geospatialCameraMovement.js","sourceRoot":"","sources":["../../../../dev/core/src/Cameras/geospatialCameraMovement.ts"],"names":[],"mappings":"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","sourcesContent":["import { CameraMovement } from \"./cameraMovement\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { GeospatialLimits } from \"./Limits/geospatialLimits\";\r\nimport { Matrix, TmpVectors, Vector3 } from \"../Maths/math.vector\";\r\nimport type { MeshPredicate } from \"../Culling/ray.core\";\r\nimport { Plane } from \"../Maths/math.plane\";\r\nimport { Ray } from \"../Culling/ray\";\r\nimport type { Scene } from \"../scene\";\r\nimport { Vector3Distance } from \"../Maths/math.vector.functions\";\r\nimport { Clamp } from \"../Maths/math.scalar.functions\";\r\nimport type { PickingInfo } from \"../Collisions/pickingInfo\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { InterpolatingBehavior } from \"../Behaviors/Cameras/interpolatingBehavior\";\r\nimport type { GeospatialCamera } from \"./geospatialCamera\";\r\n\r\n/**\r\n * Geospatial-specific camera movement system that extends the base movement with\r\n * raycasting and altitude-aware zoom constraints.\r\n *\r\n * This class encapsulates geospatial camera movement logic:\r\n * - Dragging in a way which keeps cursor anchored to globe\r\n * - Latitude-based pan speed dampening\r\n * - Zoom speed scaling based on distance to center\r\n * - Raycasting to determine zoom constraints based on terrain/globe\r\n * - Altitude-based zoom clamping\r\n * - Zoom direction calculation (towards cursor vs along look vector)\r\n */\r\nexport class GeospatialCameraMovement extends CameraMovement {\r\n    /** Predicate function to determine which meshes to pick against (e.g., globe mesh) */\r\n    public pickPredicate?: MeshPredicate;\r\n\r\n    /** World-space picked point under cursor for zoom-to-cursor behavior (may be undefined) */\r\n    public computedPerFrameZoomPickPoint?: Vector3;\r\n\r\n    public zoomToCursor: boolean = true;\r\n\r\n    private _tempPickingRay: Ray;\r\n\r\n    private _hitPointRadius?: number = undefined;\r\n    private _dragPlane: Plane = new Plane(0, 0, 0, 0);\r\n    private _dragPlaneNormal: Vector3 = Vector3.Zero();\r\n    private _dragPlaneOriginPointEcef: Vector3 = Vector3.Zero();\r\n    private _dragPlaneHitPointLocal: Vector3 = Vector3.Zero();\r\n    private _previousDragPlaneHitPointLocal: Vector3 = Vector3.Zero();\r\n\r\n    constructor(\r\n        scene: Scene,\r\n        public limits: GeospatialLimits,\r\n        cameraPosition: Vector3,\r\n        private _cameraCenter: Vector3,\r\n        private _cameraLookAt: Vector3,\r\n        pickPredicate?: MeshPredicate,\r\n        behavior?: InterpolatingBehavior<GeospatialCamera>\r\n    ) {\r\n        super(scene, cameraPosition, behavior);\r\n        this.pickPredicate = pickPredicate;\r\n        this._tempPickingRay = new Ray(this._cameraPosition, this._cameraLookAt);\r\n        this.panInertia = 0;\r\n        this.rotationInertia = 0;\r\n        this.rotationXSpeed = Math.PI / 500; // Move 1/500th of a half circle per pixel\r\n        this.rotationYSpeed = Math.PI / 500; // Move 1/500th of a half circle per pixel\r\n        this.zoomSpeed = 2; // Base zoom speed; actual speed is scaled based on altitude\r\n    }\r\n\r\n    public startDrag(pointerX: number, pointerY: number) {\r\n        const pickResult = this._scene.pick(pointerX, pointerY, this.pickPredicate);\r\n        if (pickResult.pickedPoint && pickResult.ray) {\r\n            // Store radius from earth center to pickedPoint, used when calculating drag plane\r\n            this._hitPointRadius = pickResult.pickedPoint.length();\r\n\r\n            this._recalculateDragPlaneHitPoint(this._hitPointRadius, pickResult.ray, TmpVectors.Matrix[0]);\r\n            this._previousDragPlaneHitPointLocal.copyFrom(this._dragPlaneHitPointLocal);\r\n        } else {\r\n            this._hitPointRadius = undefined; // can't drag without a hit on the globe\r\n        }\r\n    }\r\n\r\n    public stopDrag() {\r\n        this._hitPointRadius = undefined;\r\n    }\r\n\r\n    /**\r\n     * The previous drag plane hit point in local space is stored to compute the movement delta.\r\n     * As the drag movement occurs, we will continuously recalculate this point. The delta between the previous and current hit points is the delta we will apply to the camera's localtranslation\r\n     * @param hitPointRadius The distance between the world origin (center of globe) and the initial drag hit point\r\n     * @param ray The ray from the camera to the new cursor location\r\n     * @param localToEcefResult The matrix to convert from local to ECEF space\r\n     */\r\n    private _recalculateDragPlaneHitPoint(hitPointRadius: number, ray: Ray, localToEcefResult: Matrix): void {\r\n        // Use the camera's geocentric normal to find the dragPlaneOriginPoint which lives at hitPointRadius along the camera's geocentric normal\r\n        this._cameraPosition.normalizeToRef(this._dragPlaneNormal);\r\n        this._dragPlaneNormal.scaleToRef(hitPointRadius, this._dragPlaneOriginPointEcef);\r\n\r\n        // The dragPlaneOffsetVector will later be recalculated when drag occurs, and the delta between the offset vectors will be applied to localTranslation\r\n        ComputeLocalBasisToRefs(this._dragPlaneOriginPointEcef, TmpVectors.Vector3[0], TmpVectors.Vector3[1], TmpVectors.Vector3[2], this._scene.useRightHandedSystem);\r\n        const localToEcef = Matrix.FromXYZAxesToRef(TmpVectors.Vector3[0], TmpVectors.Vector3[1], TmpVectors.Vector3[2], localToEcefResult);\r\n        localToEcef.setTranslationFromFloats(this._dragPlaneOriginPointEcef.x, this._dragPlaneOriginPointEcef.y, this._dragPlaneOriginPointEcef.z);\r\n        const ecefToLocal = localToEcef.invertToRef(TmpVectors.Matrix[1]);\r\n\r\n        // Now create a plane at that point, perpendicular to the camera's geocentric normal\r\n        Plane.FromPositionAndNormalToRef(this._dragPlaneOriginPointEcef, this._dragPlaneNormal, this._dragPlane);\r\n\r\n        // Lastly, find the _dragPlaneHitPoint where the ray intersects the _dragPlane.\r\n        if (IntersectRayWithPlaneToRef(ray, this._dragPlane, this._dragPlaneHitPointLocal)) {\r\n            // If hit, convert the drag plane hit point into the local space.\r\n            Vector3.TransformCoordinatesToRef(this._dragPlaneHitPointLocal, ecefToLocal, this._dragPlaneHitPointLocal);\r\n        }\r\n    }\r\n\r\n    public handleDrag(pointerX: number, pointerY: number) {\r\n        if (this._hitPointRadius) {\r\n            const pickResult = this._scene.pick(pointerX, pointerY, this.pickPredicate);\r\n            if (pickResult.ray) {\r\n                const localToEcef = TmpVectors.Matrix[0];\r\n                this._recalculateDragPlaneHitPoint(this._hitPointRadius, pickResult.ray, localToEcef);\r\n\r\n                const delta = this._dragPlaneHitPointLocal.subtractToRef(this._previousDragPlaneHitPointLocal, TmpVectors.Vector3[6]);\r\n\r\n                // When the camera is pitched nearly parallel to the drag plane, ray-plane intersection\r\n                // can produce enormous deltas. Clamp the delta to avoid massive jumps.\r\n                const maxDragDelta = this._hitPointRadius * 0.1; // Max 10% of hit radius per frame\r\n                const deltaLength = delta.length();\r\n                if (deltaLength > maxDragDelta) {\r\n                    delta.scaleInPlace(maxDragDelta / deltaLength);\r\n                }\r\n\r\n                this._previousDragPlaneHitPointLocal.copyFrom(this._dragPlaneHitPointLocal);\r\n\r\n                Vector3.TransformNormalToRef(delta, localToEcef, delta);\r\n                this._dragPlaneOriginPointEcef.addInPlace(delta);\r\n\r\n                this.panAccumulatedPixels.subtractInPlace(delta);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** @override */\r\n    public override computeCurrentFrameDeltas(): void {\r\n        const cameraCenter = this._cameraCenter;\r\n\r\n        // Slows down panning near the poles\r\n        if (this.panAccumulatedPixels.lengthSquared() > Epsilon) {\r\n            const centerRadius = cameraCenter.length(); // distance from planet origin to camera center\r\n            const currentRadius = this._cameraPosition.length();\r\n            // Dampen the pan speed based on latitude (slower near poles)\r\n            const sineOfSphericalLat = centerRadius === 0 ? 0 : cameraCenter.z / centerRadius;\r\n            const cosOfSphericalLat = Math.sqrt(1 - Math.min(1, sineOfSphericalLat * sineOfSphericalLat));\r\n            const latitudeDampening = Math.sqrt(Math.abs(cosOfSphericalLat)); // sqrt here reduces effect near equator\r\n\r\n            // Reduce the dampening effect near surface (so that at ground level, pan speed is not affected by latitude)\r\n            const height = Math.max(currentRadius - centerRadius, Epsilon);\r\n            const latitudeDampeningScale = Math.max(1, centerRadius / height);\r\n\r\n            this._panSpeedMultiplier = Clamp(latitudeDampeningScale * latitudeDampening, 0, 1);\r\n        } else {\r\n            this._panSpeedMultiplier = 1;\r\n        }\r\n\r\n        // If a pan drag or rotate is occurring, stop zooming.\r\n        let zoomTargetDistance: number | undefined;\r\n        if (this.isDragging || this.rotationAccumulatedPixels.lengthSquared() > Epsilon) {\r\n            this._zoomSpeedMultiplier = 0;\r\n            this._zoomVelocity = 0;\r\n        } else {\r\n            zoomTargetDistance = this.computedPerFrameZoomPickPoint ? Vector3Distance(this._cameraPosition, this.computedPerFrameZoomPickPoint) : undefined;\r\n\r\n            // Scales zoom movement speed based on camera distance to zoom target.\r\n            this._zoomSpeedMultiplier = (zoomTargetDistance ?? Vector3Distance(this._cameraPosition, cameraCenter)) * 0.01;\r\n        }\r\n\r\n        super.computeCurrentFrameDeltas();\r\n    }\r\n\r\n    public get isDragging() {\r\n        return this._hitPointRadius !== undefined;\r\n    }\r\n\r\n    public handleZoom(zoomDelta: number, toCursor: boolean) {\r\n        if (zoomDelta !== 0) {\r\n            this.zoomAccumulatedPixels += zoomDelta;\r\n\r\n            const pickResult = this._scene.pick(this._scene.pointerX, this._scene.pointerY, this.pickPredicate);\r\n\r\n            if (toCursor && pickResult.hit && pickResult.pickedPoint && pickResult.ray && this.zoomToCursor) {\r\n                this.computedPerFrameZoomPickPoint = pickResult.pickedPoint;\r\n            } else {\r\n                // If no hit under cursor or explicitly told not to zoom to cursor, zoom along lookVector instead\r\n                const lookPickResult = this.pickAlongVector(this._cameraLookAt);\r\n                this.computedPerFrameZoomPickPoint = lookPickResult?.pickedPoint ?? undefined;\r\n            }\r\n        }\r\n    }\r\n\r\n    public pickAlongVector(vector: Vector3): Nullable<PickingInfo> {\r\n        this._tempPickingRay.origin.copyFrom(this._cameraPosition);\r\n        this._tempPickingRay.direction.copyFrom(vector);\r\n        return this._scene.pickWithRay(this._tempPickingRay, this.pickPredicate);\r\n    }\r\n}\r\n/** @internal */\r\nexport function ClampCenterFromPolesInPlace(center: Vector3) {\r\n    const sineOfSphericalLatitudeLimit = 0.998749218; // ~90 degrees\r\n    const centerMagnitude = center.length(); // distance from planet origin\r\n    if (centerMagnitude > Epsilon) {\r\n        const sineSphericalLat = centerMagnitude === 0 ? 0 : center.z / centerMagnitude;\r\n        if (Math.abs(sineSphericalLat) > sineOfSphericalLatitudeLimit) {\r\n            // Clamp the spherical latitude (and derive longitude)\r\n            const sineOfClampedSphericalLat = Clamp(sineSphericalLat, -sineOfSphericalLatitudeLimit, sineOfSphericalLatitudeLimit);\r\n            const cosineOfClampedSphericalLat = Math.sqrt(1 - sineOfClampedSphericalLat * sineOfClampedSphericalLat);\r\n            const longitude = Math.atan2(center.y, center.x);\r\n\r\n            // Spherical to Cartesian\r\n            const newX = centerMagnitude * Math.cos(longitude) * cosineOfClampedSphericalLat;\r\n            const newY = centerMagnitude * Math.sin(longitude) * cosineOfClampedSphericalLat;\r\n            const newZ = centerMagnitude * sineOfClampedSphericalLat;\r\n\r\n            center.set(newX, newY, newZ);\r\n        }\r\n    }\r\n    return center;\r\n}\r\n\r\nfunction IntersectRayWithPlaneToRef(ray: Ray, plane: Plane, ref: Vector3): boolean {\r\n    // Distance along the ray to the plane; null if no hit\r\n    const dist = ray.intersectsPlane(plane);\r\n\r\n    if (dist !== null && dist >= 0) {\r\n        ray.origin.addToRef(ray.direction.scaleToRef(dist, TmpVectors.Vector3[0]), ref);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Helper to build east/north/up basis vectors at a world position.\r\n * Cross product order is swapped based on handedness so that the east vector\r\n * encodes the coordinate-system convention, removing the need for a separate yawScale.\r\n * @param worldPos - The position on the globe\r\n * @param refEast - Receives the east direction\r\n * @param refNorth - Receives the north direction\r\n * @param refUp - Receives the up (outward) direction\r\n * @param useRightHandedSystem - Whether the scene uses a right-handed coordinate system (default: false)\r\n * @internal\r\n */\r\nexport function ComputeLocalBasisToRefs(worldPos: Vector3, refEast: Vector3, refNorth: Vector3, refUp: Vector3, useRightHandedSystem: boolean = false) {\r\n    // up = normalized position (geocentric normal)\r\n    refUp.copyFrom(worldPos).normalize();\r\n\r\n    // east – cross product order determines handedness\r\n    const worldNorth = Vector3.LeftHandedForwardReadOnly; // (0,0,1)\r\n    if (useRightHandedSystem) {\r\n        Vector3.CrossToRef(worldNorth, refUp, refEast);\r\n    } else {\r\n        Vector3.CrossToRef(refUp, worldNorth, refEast);\r\n    }\r\n\r\n    // at poles, cross with worldRight instead\r\n    if (refEast.lengthSquared() < Epsilon) {\r\n        if (useRightHandedSystem) {\r\n            Vector3.CrossToRef(Vector3.Right(), refUp, refEast);\r\n        } else {\r\n            Vector3.CrossToRef(refUp, Vector3.Right(), refEast);\r\n        }\r\n    }\r\n    refEast.normalize();\r\n\r\n    // north – completes the basis (cross order also swapped for handedness)\r\n    if (useRightHandedSystem) {\r\n        Vector3.CrossToRef(refUp, refEast, refNorth);\r\n    } else {\r\n        Vector3.CrossToRef(refEast, refUp, refNorth);\r\n    }\r\n    refNorth.normalize();\r\n}\r\n"]}