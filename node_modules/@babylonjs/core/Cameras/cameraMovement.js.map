{"version":3,"file":"cameraMovement.js","sourceRoot":"","sources":["../../../../dev/core/src/Cameras/cameraMovement.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Scene } from \"../scene\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport { Epsilon } from \"../Maths/math.constants\";\r\nimport type { InterpolatingBehavior } from \"../Behaviors/Cameras/interpolatingBehavior\";\r\n\r\nconst FrameDurationAt60FPS = 1000 / 60;\r\n/**\r\n * @experimental\r\n * This class is subject to change as geospatial camera evolves.\r\n *\r\n * It is intended to hold all logic related to converting input pixel deltas into current frame deltas, taking speed / framerate into account\r\n * to ensure smooth frame-rate-independent movement\r\n */\r\nexport class CameraMovement {\r\n    protected _scene: Scene;\r\n\r\n    /**\r\n     * Should be set by input classes to indicates whether there is active input this frame\r\n     * This helps us differentiate between 0 pixel delta due to no input vs user actively holding still\r\n     */\r\n    public activeInput: boolean = false;\r\n\r\n    /**\r\n     * ------------ Speed ----------------\r\n     * Speed defines the amount of camera movement expected per input pixel movement\r\n     * -----------------------------------\r\n     */\r\n    /**\r\n     * Desired coordinate unit movement per input pixel when zooming\r\n     */\r\n    public zoomSpeed: number = 1;\r\n    /**\r\n     * Desired coordinate unit movement per input pixel when panning\r\n     */\r\n    public panSpeed: number = 1;\r\n    /**\r\n     * Desired radians movement per input pixel when rotating along x axis\r\n     */\r\n    public rotationXSpeed: number = 1;\r\n    /**\r\n     * Desired radians movement per input pixel when rotating along y axis\r\n     */\r\n    public rotationYSpeed: number = 1;\r\n\r\n    /**\r\n     * ----------- Speed multipliers ---------------\r\n     * Multipliers allow movement classes to modify the effective speed dynamically per-frame\r\n     * (ex: scale zoom based on distance from target)\r\n     * -----------------------------------\r\n     */\r\n    /**\r\n     * Multiplied atop zoom speed. Used to dynamically adjust zoom speed based on per-frame context (ex: zoom faster when further from target)\r\n     */\r\n    protected _zoomSpeedMultiplier: number = 1;\r\n    /**\r\n     * Multiplied atop pan speed. Used to dynamically adjust pan speed based on per-frame context (ex: pan slowly when close to target)\r\n     */\r\n    protected _panSpeedMultiplier: number = 1;\r\n\r\n    /**\r\n     * ---------- Inertia ----------------\r\n     * Inertia represents the decay factor per-frame applied to the velocity when there is no user input.\r\n     * 0 = No inertia, instant stop (velocity immediately becomes 0)\r\n     * 0.5 = Strong decay, velocity halves every frame at 60fps\r\n     * 0.9 = Moderate inertia, velocity retains 90% per frame at 60fps\r\n     * 0.95 = High inertia, smooth glide, velocity retains 95% per frame at 60fps\r\n     * 1 = Infinite inertia, never stops (velocity never decays)\r\n     * -----------------------------------\r\n     */\r\n    /**\r\n     * Inertia applied to the zoom velocity when there is no user input.\r\n     * Higher inertia === slower decay, velocity retains more of its value each frame\r\n     */\r\n    public zoomInertia: number = 0.9;\r\n    /**\r\n     * Inertia applied to the panning velocity when there is no user input.\r\n     * Higher inertia === slower decay, velocity retains more of its value each frame\r\n     */\r\n    public panInertia: number = 0.9;\r\n    /**\r\n     * Inertia applied to the rotation velocity when there is no user input.\r\n     * Higher inertia === slower decay, velocity retains more of its value each frame\r\n     */\r\n    public rotationInertia: number = 0.9;\r\n\r\n    /**\r\n     * ---------- Accumulated Pixel Deltas -----------\r\n     * Pixel inputs accumulated throughout the frame by input classes (reset each frame after processing)\r\n     * -----------------------------------\r\n     */\r\n    /**\r\n     * Accumulated pixel delta (by input classes) for zoom this frame\r\n     * Read by computeCurrentFrameDeltas() function and converted into zoomDeltaCurrentFrame (taking speed into account)\r\n     * Reset to zero after each frame\r\n     */\r\n    public zoomAccumulatedPixels: number = 0;\r\n    /**\r\n     * Accumulated pixel delta (by input classes) for panning this frame\r\n     * Read by computeCurrentFrameDeltas() function and converted into panDeltaCurrentFrame (taking speed into account)\r\n     * Reset to zero after each frame\r\n     */\r\n    public panAccumulatedPixels: Vector3 = new Vector3();\r\n    /**\r\n     * Accumulated pixel delta (by input classes) for rotation this frame\r\n     * Read by computeCurrentFrameDeltas() function and converted into rotationDeltaCurrentFrame (taking speed into account)\r\n     * Reset to zero after each frame\r\n     */\r\n    public rotationAccumulatedPixels: Vector3 = new Vector3();\r\n\r\n    /**\r\n     * ---------- Current Frame Movement Deltas -----------\r\n     * Deltas read on each frame by camera class in order to move the camera\r\n     * -----------------------------------\r\n     */\r\n    /**\r\n     * Zoom delta to apply to camera this frame, computed by computeCurrentFrameDeltas() from zoomPixelDelta (taking speed into account)\r\n     */\r\n    public zoomDeltaCurrentFrame: number = 0;\r\n    /**\r\n     * Pan delta to apply to camera this frame, computed by computeCurrentFrameDeltas() from panPixelDelta (taking speed into account)\r\n     */\r\n    public panDeltaCurrentFrame: Vector3 = Vector3.Zero();\r\n    /**\r\n     * Rotation delta to apply to camera this frame, computed by computeCurrentFrameDeltas() from rotationPixelDelta (taking speed into account)\r\n     */\r\n    public rotationDeltaCurrentFrame: Vector3 = Vector3.Zero();\r\n\r\n    /**\r\n     * ---------- Velocity -----------\r\n     * Used to track velocity between frames for inertia calculation\r\n     * -----------------------------------\r\n     */\r\n    /**\r\n     * Zoom pixel velocity used for inertia calculations (pixels / ms).\r\n     */\r\n    protected _zoomVelocity: number = 0;\r\n    /**\r\n     * Pan velocity used for inertia calculations (movement / time)\r\n     */\r\n    private _panVelocity: Vector3 = new Vector3();\r\n    /**\r\n     * Rotation velocity used for inertia calculations (movement / time)\r\n     */\r\n    private _rotationVelocity: Vector3 = new Vector3();\r\n\r\n    /**\r\n     * Used when calculating inertial decay. Default to 60fps\r\n     */\r\n    private _prevFrameTimeMs: number = FrameDurationAt60FPS;\r\n\r\n    constructor(\r\n        scene: Scene,\r\n        protected _cameraPosition: Vector3,\r\n        protected _behavior?: InterpolatingBehavior\r\n    ) {\r\n        this._scene = scene;\r\n    }\r\n\r\n    /**\r\n     * When called, will take the accumulated pixel deltas set by input classes and convert them into current frame deltas, stored in currentFrameMovementDelta properties\r\n     * Takes speed, scaling, inertia, and framerate into account to ensure smooth movement\r\n     * Zeros out pixelDeltas before returning\r\n     */\r\n    public computeCurrentFrameDeltas(): void {\r\n        const deltaTimeMs = this._scene.getEngine().getDeltaTime();\r\n\r\n        this.panDeltaCurrentFrame.setAll(0);\r\n        this.rotationDeltaCurrentFrame.setAll(0);\r\n        this.zoomDeltaCurrentFrame = 0;\r\n\r\n        const hasUserInput = this.panAccumulatedPixels.lengthSquared() > 0 || this.rotationAccumulatedPixels.lengthSquared() > 0 || this.zoomAccumulatedPixels !== 0;\r\n\r\n        if (hasUserInput && this._behavior?.isInterpolating) {\r\n            this._behavior.stopAllAnimations();\r\n        }\r\n\r\n        this._panVelocity.copyFromFloats(\r\n            this._calculateCurrentVelocity(this._panVelocity.x, this.panAccumulatedPixels.x, this.panInertia),\r\n            this._calculateCurrentVelocity(this._panVelocity.y, this.panAccumulatedPixels.y, this.panInertia),\r\n            this._calculateCurrentVelocity(this._panVelocity.z, this.panAccumulatedPixels.z, this.panInertia)\r\n        );\r\n        this._panVelocity.scaleToRef(this.panSpeed * this._panSpeedMultiplier * deltaTimeMs, this.panDeltaCurrentFrame);\r\n\r\n        this._rotationVelocity.copyFromFloats(\r\n            this._calculateCurrentVelocity(this._rotationVelocity.x, this.rotationAccumulatedPixels.x, this.rotationInertia),\r\n            this._calculateCurrentVelocity(this._rotationVelocity.y, this.rotationAccumulatedPixels.y, this.rotationInertia),\r\n            this._calculateCurrentVelocity(this._rotationVelocity.z, this.rotationAccumulatedPixels.z, this.rotationInertia)\r\n        );\r\n        this.rotationDeltaCurrentFrame.copyFromFloats(\r\n            this._rotationVelocity.x * this.rotationXSpeed * deltaTimeMs,\r\n            this._rotationVelocity.y * this.rotationYSpeed * deltaTimeMs,\r\n            this._rotationVelocity.z * this.rotationYSpeed * deltaTimeMs\r\n        );\r\n\r\n        this._zoomVelocity = this._calculateCurrentVelocity(this._zoomVelocity, this.zoomAccumulatedPixels, this.zoomInertia);\r\n        this.zoomDeltaCurrentFrame = this._zoomVelocity * (this.zoomSpeed * this._zoomSpeedMultiplier) * deltaTimeMs;\r\n\r\n        this._prevFrameTimeMs = deltaTimeMs;\r\n        this.zoomAccumulatedPixels = 0;\r\n        this.panAccumulatedPixels.setAll(0);\r\n        this.rotationAccumulatedPixels.setAll(0);\r\n    }\r\n\r\n    public get isInterpolating(): boolean {\r\n        return !!this._behavior?.isInterpolating;\r\n    }\r\n\r\n    private _calculateCurrentVelocity(velocityRef: number, pixelDelta: number, inertialDecayFactor: number): number {\r\n        let inputVelocity = velocityRef;\r\n        const deltaTimeMs = this._scene.getEngine().getDeltaTime();\r\n\r\n        // If we are actively receiving input or have accumulated some pixel delta since last frame, calculate inputVelocity (inertia doesn't kick in yet)\r\n        if (pixelDelta !== 0 || this.activeInput) {\r\n            inputVelocity = pixelDelta / deltaTimeMs;\r\n        } else if (!this.activeInput && inputVelocity !== 0) {\r\n            // If we are not receiving input and velocity isn't already zero, apply inertial decay to decelerate velocity\r\n            const frameIndependentDecay = Math.pow(inertialDecayFactor, this._prevFrameTimeMs / FrameDurationAt60FPS);\r\n            inputVelocity *= frameIndependentDecay;\r\n            if (Math.abs(inputVelocity) <= Epsilon) {\r\n                inputVelocity = 0;\r\n            }\r\n        }\r\n\r\n        return inputVelocity;\r\n    }\r\n}\r\n"]}