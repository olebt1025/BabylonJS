import { GeospatialCameraInputsManager } from "./geospatialCameraInputsManager.js";
import { Vector3, Matrix } from "../Maths/math.vector.js";
import type { Vector2 } from "../Maths/math.vector.js";
import { Camera } from "./camera.js";
import type { Scene } from "../scene.js";
import type { MeshPredicate } from "../Culling/ray.core.js";
import type { DeepImmutable } from "../types.js";
import { GeospatialLimits } from "./Limits/geospatialLimits.js";
import { GeospatialCameraMovement } from "./geospatialCameraMovement.js";
import type { IVector3Like } from "../Maths/math.like.js";
import type { EasingFunction } from "../Animations/easing.js";
export type GeospatialCameraOptions = {
    /**
     * Radius of the planet being orbited
     */
    planetRadius: number;
    /**
     * If supplied, will be used by the movement class when picking the globe. Can later update camera.movement.pickPredicate directly
     */
    pickPredicate?: MeshPredicate;
};
/**
 * Camera equipped to orbit a spherical planet centered at world origin
 */
export declare class GeospatialCamera extends Camera {
    inputs: GeospatialCameraInputsManager;
    /** Movement controller that turns input pixelDeltas into currentFrameDeltas used by camera*/
    readonly movement: GeospatialCameraMovement;
    private _tempPosition;
    private _tempCenter;
    private _viewMatrix;
    private _isViewMatrixDirty;
    private _lookAtVector;
    /** Behavior used for smooth flying animations */
    private _flyingBehavior;
    private _flyToTargets;
    private _collider?;
    private _collisionVelocity;
    /** Public option to customize the collision offset applied each frame - vs the one calculated using internal CollisionCoordinator */
    perFrameCollisionOffset: Vector3;
    /** Enable or disable collision checking for this camera. Default is false. */
    checkCollisions: boolean;
    constructor(name: string, scene: Scene, options: GeospatialCameraOptions);
    private _center;
    /** The point on the globe that we are anchoring around. If no alternate rotation point is supplied, this will represent the center of screen*/
    get center(): Vector3;
    /**
     * Sets the camera position to orbit around a new center point
     * @param center The world position (ECEF) to orbit around
     */
    set center(center: IVector3Like);
    private _yaw;
    /**
     * Gets the camera's yaw (rotation around the geocentric normal) in radians
     */
    get yaw(): number;
    /**
     * Sets the camera's yaw (rotation around the geocentric normal). Will wrap value to [-π, π)
     * @param yaw The desired yaw angle in radians (0 = north, π/2 = east)
     */
    set yaw(yaw: number);
    private _pitch;
    /**
     * Gets the camera's pitch (angle from looking straight at globe)
     * Pitch is measured from looking straight down at planet center:
     * - zero pitch = looking straight at planet center (down)
     * - positive pitch = tilting up away from planet
     * - π/2 pitch = looking at horizon (perpendicular to geocentric normal)
     */
    get pitch(): number;
    /**
     * Sets the camera's pitch (angle from looking straight at globe). Will wrap value to [-π, π)
     * @param pitch The desired pitch angle in radians (0 = looking at planet center, π/2 = looking at horizon)
     */
    set pitch(pitch: number);
    private _radius;
    get radius(): number;
    /**
     * Sets the camera's distance from the current center point
     * @param radius The desired radius
     */
    set radius(radius: number);
    protected _checkLimits(): void;
    private _tempVect;
    private _tempEast;
    private _tempNorth;
    private _tempUp;
    private _setOrientation;
    /**
     * If camera is actively in flight, will update the target properties and use up the remaining duration from original flyTo call
     *
     * To start a new flyTo curve entirely, call into flyToAsync again (it will stop the inflight animation)
     * @param targetYaw
     * @param targetPitch
     * @param targetRadius
     * @param targetCenter
     */
    updateFlyToDestination(targetYaw?: number, targetPitch?: number, targetRadius?: number, targetCenter?: Vector3): void;
    /**
     * Animate camera towards passed in property values. If undefined, will use current value
     * @param targetYaw
     * @param targetPitch
     * @param targetRadius
     * @param targetCenter
     * @param flightDurationMs
     * @param easingFunction
     * @param centerHopScale If supplied, will define the parabolic hop height scale for center animation to create a "bounce" effect
     * @returns Promise that will return when the animation is complete (or interuppted by pointer input)
     */
    flyToAsync(targetYaw?: number, targetPitch?: number, targetRadius?: number, targetCenter?: Vector3, flightDurationMs?: number, easingFunction?: EasingFunction, centerHopScale?: number): Promise<void>;
    /**
     * Helper function to move camera towards a given point by `distanceScale` of the current camera-to-destination distance (by default 50%).
     * @param destination point to move towards
     * @param distanceScale value between 0 and 1, % of distance to move
     * @param durationMs duration of flight, default 1s
     * @param easingFn optional easing function for flight interpolation of properties
     * @param centerHopScale If supplied, will define the parabolic hop height scale for center animation to create a "bounce" effect
     */
    flyToPointAsync(destination: Vector3, distanceScale?: number, durationMs?: number, easingFn?: EasingFunction, centerHopScale?: number): Promise<void>;
    private _limits;
    get limits(): GeospatialLimits;
    private _resetToDefault;
    /** @internal */
    _getViewMatrix(): Matrix;
    /** @internal */
    _isSynchronizedViewMatrix(): boolean;
    private _applyGeocentricTranslation;
    /**
     * This rotation keeps the camera oriented towards the globe as it orbits around it. This is different from cameraCentricRotation which is when the camera rotates around its own axis
     */
    private _applyGeocentricRotation;
    private _getCenterAndRadiusFromZoomToPoint;
    /**
     * Apply zoom by moving the camera toward/away from a target point.
     */
    private _applyZoom;
    private _clampZoomDelta;
    zoomToPoint(targetPoint: DeepImmutable<IVector3Like>, distance: number): void;
    zoomAlongLookAt(distance: number): void;
    _checkInputs(): void;
    private _wasCenterMovingLastFrame;
    private _recalculateCenter;
    /**
     * Allows extended classes to override how collision offset is calculated
     * @param newPosition
     * @returns
     */
    protected _getCollisionOffset(newPosition: Vector3): Vector3;
    attachControl(noPreventDefault?: boolean): void;
    detachControl(): void;
    /**
     * Gets the class name of the camera.
     * @returns the class name
     */
    getClassName(): string;
}
/**
 * Compute the lookAt direction vector from yaw and pitch angles at a given center point.
 * This is the forward formula used by GeospatialCamera._setOrientation.
 * @param yaw - The yaw angle in radians (0 = north, π/2 = east)
 * @param pitch - The pitch angle in radians (0 = looking at planet center, π/2 = looking at horizon)
 * @param center - The center point on the globe
 * @param useRightHandedSystem - Whether the scene uses a right-handed coordinate system
 * @param result - The vector to store the result in
 * @returns The normalized lookAt direction vector (same as result)
 */
export declare function ComputeLookAtFromYawPitchToRef(yaw: number, pitch: number, center: Vector3, useRightHandedSystem: boolean, result: Vector3): Vector3;
/**
 * Given a lookAt direction and center, compute the yaw and pitch angles that would produce that lookAt.
 * This is the inverse of ComputeLookAtFromYawPitchToRef.
 * @param lookAt - The normalized lookAt direction vector
 * @param center - The center point on the globe
 * @param useRightHandedSystem - Whether the scene uses a right-handed coordinate system
 * @param currentYaw - The current yaw value to use as fallback when pitch is near 0 (looking straight down/up)
 * @param result - The Vector2 to store the result in (x = yaw, y = pitch)
 * @returns The result Vector2
 */
export declare function ComputeYawPitchFromLookAtToRef(lookAt: Vector3, center: Vector3, useRightHandedSystem: boolean, currentYaw: number, result: Vector2): Vector2;
