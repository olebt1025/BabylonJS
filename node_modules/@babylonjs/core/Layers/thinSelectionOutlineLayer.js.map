{"version":3,"file":"thinSelectionOutlineLayer.js","sourceRoot":"","sources":["../../../../dev/core/src/Layers/thinSelectionOutlineLayer.ts"],"names":[],"mappings":"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","sourcesContent":["import { VertexBuffer } from \"../Buffers/buffer\";\nimport { Camera } from \"../Cameras/camera\";\nimport { Constants } from \"../Engines/constants\";\nimport type { ThinEngine } from \"../Engines/thinEngine\";\nimport { AddClipPlaneUniforms, BindClipPlane, PrepareStringDefinesForClipPlanes } from \"../Materials/clipPlaneMaterialHelper\";\nimport type { Effect, IEffectCreationOptions } from \"../Materials/effect\";\nimport { EffectFallbacks } from \"../Materials/effectFallbacks\";\nimport { Material } from \"../Materials/material\";\nimport { BindBonesParameters, BindMorphTargetParameters, PrepareDefinesAndAttributesForMorphTargets, PushAttributesForInstances } from \"../Materials/materialHelper.functions\";\nimport { ShaderLanguage } from \"../Materials/shaderLanguage\";\nimport type { BaseTexture } from \"../Materials/Textures/baseTexture\";\nimport { Color3, Color4 } from \"../Maths/math.color\";\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\nimport type { InstancedMesh } from \"../Meshes/instancedMesh\";\nimport type { Mesh } from \"../Meshes/mesh\";\nimport type { SubMesh } from \"../Meshes/subMesh\";\nimport type { Scene } from \"../scene\";\nimport type { Nullable } from \"../types\";\nimport type { IThinEffectLayerOptions } from \"./thinEffectLayer\";\nimport { ThinEffectLayer } from \"./thinEffectLayer\";\n\n/**\n * Selection outline layer options. This helps customizing the behaviour\n * of the selection outline layer.\n */\nexport interface IThinSelectionOutlineLayerOptions extends IThinEffectLayerOptions {\n    /**\n     * Use the GLSL code generation for the shader (even on WebGPU). Default is false\n     */\n    forceGLSL?: boolean;\n\n    /**\n     * Specifies whether the depth stored is the Z coordinate in camera space.\n     */\n    storeCameraSpaceZ?: boolean;\n\n    /**\n     * Outline method to use (default: Constants.OUTLINELAYER_SAMPLING_TRIDIRECTIONAL)\n     *\n     * @see {@link Constants.OUTLINELAYER_SAMPLING_TRIDIRECTIONAL}\n     */\n    outlineMethod?: number;\n}\n\n/**\n * @internal\n */\nexport class ThinSelectionOutlineLayer extends ThinEffectLayer {\n    /**\n     * Effect Name of the layer.\n     */\n    public static readonly EffectName = \"SelectionOutlineLayer\";\n\n    /**\n     * Name of the instance selection ID attribute\n     * @internal\n     */\n    public static readonly InstanceSelectionIdAttributeName = \"instanceSelectionId\";\n\n    /**\n     * The outline color\n     */\n    public outlineColor: Color3 = new Color3(1, 0.5, 0);\n\n    /**\n     * The thickness of the edges\n     */\n    public outlineThickness: number = 2.0;\n\n    /**\n     * The strength of the occlusion effect (default: 0.8)\n     */\n    public occlusionStrength: number = 0.8;\n\n    /**\n     * The occlusion threshold (default: 0.0001)\n     */\n    public occlusionThreshold: number = 0.0001;\n\n    /**\n     * The width of the source texture\n     */\n    public textureWidth: number = 0;\n\n    /**\n     * The height of the source texture\n     */\n    public textureHeight: number = 0;\n\n    /** @internal */\n    public override _options: Required<IThinSelectionOutlineLayerOptions>;\n\n    /** @internal */\n    public readonly _meshUniqueIdToSelectionId: number[] = [];\n    /** @internal */\n    public _selection: Nullable<AbstractMesh[]> = [];\n    private _nextSelectionId = 1;\n\n    /**\n     * Instantiates a new selection outline Layer and references it to the scene..\n     * @param name The name of the layer\n     * @param scene The scene to use the layer in\n     * @param options Sets of none mandatory options to use with the layer (see IThinSelectionOutlineLayerOptions for more information)\n     * @param dontCheckIfReady Specifies if the layer should disable checking whether all the post processes are ready (default: false). To save performance, this should be set to true and you should call `isReady` manually before rendering to the layer.\n     */\n    public constructor(name: string, scene?: Scene, options?: Partial<IThinSelectionOutlineLayerOptions>, dontCheckIfReady = false) {\n        super(name, scene, options !== undefined ? !!options.forceGLSL : false);\n\n        // Adapt options\n        this._options = {\n            mainTextureRatio: 1.0,\n            mainTextureFixedSize: 0,\n            alphaBlendingMode: Constants.ALPHA_COMBINE,\n            camera: null,\n            renderingGroupId: -1,\n            forceGLSL: false,\n            mainTextureType: Constants.TEXTURETYPE_FLOAT,\n            mainTextureFormat: Constants.TEXTUREFORMAT_RG,\n            storeCameraSpaceZ: false,\n            outlineMethod: Constants.OUTLINELAYER_SAMPLING_TRIDIRECTIONAL,\n            ...options,\n        };\n\n        // set clear color\n        this.neutralColor = new Color4(0.0, this._options.storeCameraSpaceZ ? 0.0 : 1.0, 0.0, 1.0);\n\n        // Initialize the layer\n        this._init(this._options);\n\n        // Do not render as long as no meshes have been added\n        this._shouldRender = false;\n\n        if (dontCheckIfReady) {\n            // When dontCheckIfReady is true, we are in the new ThinXXX layer mode, so we must call _createTextureAndPostProcesses ourselves (it is called by EffectLayer otherwise)\n            this._createTextureAndPostProcesses();\n        }\n    }\n\n    /**\n     * Gets the class name of the effect layer\n     * @returns the string with the class name of the effect layer\n     */\n    public getClassName(): string {\n        return \"SelectionOutlineLayer\";\n    }\n\n    /** @internal */\n    public override _internalIsSubMeshReady(subMesh: SubMesh, useInstances: boolean, _emissiveTexture: Nullable<BaseTexture>): boolean {\n        const engine = this._scene.getEngine();\n        const mesh = subMesh.getMesh();\n\n        const renderingMaterial = mesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\n\n        if (renderingMaterial) {\n            return renderingMaterial.isReadyForSubMesh(mesh, subMesh, useInstances);\n        }\n\n        const material = subMesh.getMaterial();\n\n        if (!material) {\n            return false;\n        }\n\n        // selection outline layer is not compatible with custom materials\n        // if (this._useMeshMaterial(subMesh.getRenderingMesh())) {\n        //     return material.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances);\n        // }\n\n        const defines: string[] = [];\n\n        const attribs = [VertexBuffer.PositionKind];\n\n        let uv1 = false;\n        let uv2 = false;\n        const color = false;\n\n        // Alpha test\n        if (material.needAlphaTestingForMesh(mesh)) {\n            defines.push(\"#define ALPHATEST\");\n            if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {\n                attribs.push(VertexBuffer.UVKind);\n                defines.push(\"#define UV1\");\n                uv1 = true;\n            }\n            if (mesh.isVerticesDataPresent(VertexBuffer.UV2Kind)) {\n                attribs.push(VertexBuffer.UV2Kind);\n                defines.push(\"#define UV2\");\n                uv2 = true;\n            }\n        }\n\n        // Bones\n        const fallbacks = new EffectFallbacks();\n        if (mesh.useBones && mesh.computeBonesUsingShaders) {\n            attribs.push(VertexBuffer.MatricesIndicesKind);\n            attribs.push(VertexBuffer.MatricesWeightsKind);\n            if (mesh.numBoneInfluencers > 4) {\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n            }\n\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n\n            const skeleton = mesh.skeleton;\n            if (skeleton && skeleton.isUsingTextureForMatrices) {\n                defines.push(\"#define BONETEXTURE\");\n            } else {\n                defines.push(\"#define BonesPerMesh \" + (skeleton ? skeleton.bones.length + 1 : 0));\n            }\n\n            if (mesh.numBoneInfluencers > 0) {\n                fallbacks.addCPUSkinningFallback(0, mesh);\n            }\n        } else {\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n        }\n\n        // Morph targets\n        const numMorphInfluencers = mesh.morphTargetManager\n            ? PrepareDefinesAndAttributesForMorphTargets(\n                  mesh.morphTargetManager,\n                  defines,\n                  attribs,\n                  mesh,\n                  true, // usePositionMorph\n                  false, // useNormalMorph\n                  false, // useTangentMorph\n                  uv1, // useUVMorph\n                  uv2, // useUV2Morph\n                  color // useColorMorph\n              )\n            : 0;\n\n        // Instances\n        if (useInstances) {\n            defines.push(\"#define INSTANCES\");\n            PushAttributesForInstances(attribs);\n            if (subMesh.getRenderingMesh().hasThinInstances) {\n                defines.push(\"#define THIN_INSTANCES\");\n            }\n        }\n\n        // Baked vertex animations\n        const bvaManager = mesh.bakedVertexAnimationManager;\n        if (bvaManager && bvaManager.isEnabled) {\n            defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\n            if (useInstances) {\n                attribs.push(\"bakedVertexAnimationSettingsInstanced\");\n            }\n        }\n\n        // ClipPlanes\n        PrepareStringDefinesForClipPlanes(material, this._scene, defines);\n\n        // Selection ID\n        if (useInstances) {\n            attribs.push(ThinSelectionOutlineLayer.InstanceSelectionIdAttributeName);\n        }\n\n        this._addCustomEffectDefines(defines);\n\n        // Get correct effect\n        const drawWrapper = subMesh._getDrawWrapper(undefined, true)!;\n        const cachedDefines = drawWrapper.defines as string;\n        const join = defines.join(\"\\n\");\n        if (cachedDefines !== join) {\n            const uniforms = [\n                \"world\",\n                \"mBones\",\n                \"viewProjection\",\n                \"view\",\n                \"morphTargetInfluences\",\n                \"morphTargetCount\",\n                \"boneTextureWidth\",\n                \"diffuseMatrix\",\n                \"morphTargetTextureInfo\",\n                \"morphTargetTextureIndices\",\n                \"bakedVertexAnimationSettings\",\n                \"bakedVertexAnimationTextureSizeInverted\",\n                \"bakedVertexAnimationTime\",\n                \"bakedVertexAnimationTexture\",\n                \"depthValues\",\n                \"selectionId\",\n            ];\n\n            AddClipPlaneUniforms(uniforms);\n\n            drawWrapper.setEffect(\n                this._engine.createEffect(\n                    \"selection\",\n                    <IEffectCreationOptions>{\n                        attributes: attribs,\n                        uniformsNames: uniforms,\n                        uniformBuffersNames: [],\n                        samplers: [\"diffuseSampler\", \"boneSampler\", \"morphTargets\", \"bakedVertexAnimationTexture\"],\n                        defines: join,\n                        fallbacks: fallbacks,\n                        onCompiled: null,\n                        onError: null,\n                        indexParameters: { maxSimultaneousMorphTargets: numMorphInfluencers },\n                        shaderLanguage: this._shaderLanguage,\n                        extraInitializationsAsync: this._shadersLoaded\n                            ? undefined\n                            : async () => {\n                                  await this._importShadersAsync();\n                                  this._shadersLoaded = true;\n                              },\n                    },\n                    this._engine\n                ),\n                join\n            );\n        }\n\n        const effectIsReady = drawWrapper.effect!.isReady();\n\n        return effectIsReady && (this._dontCheckIfReady || (!this._dontCheckIfReady && this.isLayerReady()));\n    }\n\n    protected override async _importShadersAsync(): Promise<void> {\n        if (this._shaderLanguage === ShaderLanguage.WGSL) {\n            await Promise.all([\n                import(\"../ShadersWGSL/selection.vertex\"),\n                import(\"../ShadersWGSL/selection.fragment\"),\n                import(\"../ShadersWGSL/glowMapMerge.vertex\"),\n                import(\"../ShadersWGSL/selectionOutline.fragment\"),\n            ]);\n        } else {\n            await Promise.all([\n                import(\"../Shaders/selection.vertex\"),\n                import(\"../Shaders/selection.fragment\"),\n                import(\"../Shaders/glowMapMerge.vertex\"),\n                import(\"../Shaders/selectionOutline.fragment\"),\n            ]);\n        }\n\n        await super._importShadersAsync();\n    }\n\n    /**\n     * Get the effect name of the layer.\n     * @returns The effect name\n     */\n    public override getEffectName(): string {\n        return ThinSelectionOutlineLayer.EffectName;\n    }\n\n    /** @internal */\n    public override _createMergeEffect(): Effect {\n        const defines: string[] = [];\n        switch (this._options.outlineMethod) {\n            case Constants.OUTLINELAYER_SAMPLING_TRIDIRECTIONAL:\n                defines.push(\"#define OUTLINELAYER_SAMPLING_TRIDIRECTIONAL\");\n                break;\n            case Constants.OUTLINELAYER_SAMPLING_OCTADIRECTIONAL:\n                defines.push(\"#define OUTLINELAYER_SAMPLING_OCTADIRECTIONAL\");\n                break;\n        }\n        const join = defines.join(\"\\n\");\n\n        return this._engine.createEffect(\n            {\n                // glowMapMerge vertex is just a basic vertex shader for drawing a quad. so we reuse it here\n                vertex: \"glowMapMerge\",\n                // selection outline fragment does computation of outline with alpha channel for blending\n                fragment: \"selectionOutline\",\n            },\n            <IEffectCreationOptions>{\n                attributes: [VertexBuffer.PositionKind],\n                uniformsNames: [\"screenSize\", \"outlineColor\", \"outlineThickness\", \"occlusionStrength\", \"occlusionThreshold\"],\n                samplers: [\"maskSampler\", \"depthSampler\"],\n                defines: join,\n                fallbacks: null,\n                onCompiled: null,\n                onError: null,\n                shaderLanguage: this._shaderLanguage,\n                extraInitializationsAsync: this._shadersLoaded\n                    ? undefined\n                    : async () => {\n                          await this._importShadersAsync();\n                          this._shadersLoaded = true;\n                      },\n            },\n            this._engine\n        );\n    }\n\n    /** @internal */\n    public override _createTextureAndPostProcesses(): void {\n        // we don't need to create a texture for this layer. since all computation is done in the merge effect\n    }\n\n    /**\n     * Checks for the readiness of the element composing the layer.\n     * @param subMesh the mesh to check for\n     * @param useInstances specify whether or not to use instances to render the mesh\n     * @returns true if ready otherwise, false\n     */\n    public override isReady(subMesh: SubMesh, useInstances: boolean): boolean {\n        const material = subMesh.getMaterial();\n        const mesh = subMesh.getRenderingMesh();\n\n        if (!material || !mesh || !this._selection) {\n            return false;\n        }\n\n        return super._isSubMeshReady(subMesh, useInstances, null);\n    }\n\n    /** @internal */\n    public override _canRenderMesh(_mesh: AbstractMesh, _material: Material): boolean {\n        return true;\n    }\n\n    protected override _renderSubMesh(subMesh: SubMesh, enableAlphaMode: boolean = false): void {\n        if (!this._internalShouldRender()) {\n            return;\n        }\n\n        const material = subMesh.getMaterial();\n        const ownerMesh = subMesh.getMesh();\n        const replacementMesh = subMesh.getReplacementMesh();\n        const renderingMesh = subMesh.getRenderingMesh();\n        const effectiveMesh = subMesh.getEffectiveMesh();\n        const scene = this._scene;\n        const engine = scene.getEngine();\n\n        effectiveMesh._internalAbstractMeshDataInfo._isActiveIntermediate = false;\n\n        if (!material) {\n            return;\n        }\n\n        // Do not block in blend mode.\n        if (!this._canRenderMesh(renderingMesh, material)) {\n            return;\n        }\n\n        // Culling\n        let sideOrientation = material._getEffectiveOrientation(renderingMesh);\n        const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();\n        if (mainDeterminant < 0) {\n            sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\n        }\n\n        const reverse = sideOrientation === Material.ClockWiseSideOrientation;\n        engine.setState(material.backFaceCulling, material.zOffset, undefined, reverse, material.cullBackFaces, undefined, material.zOffsetUnits);\n\n        // Managing instances\n        const batch = renderingMesh._getInstancesRenderList(subMesh._id, !!replacementMesh);\n        if (batch.mustReturn) {\n            return;\n        }\n\n        // Early Exit per mesh\n        if (!this._shouldRenderMesh(renderingMesh)) {\n            return;\n        }\n\n        const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances || !!renderingMesh._userInstancedBuffersStorage;\n\n        this._setEmissiveTextureAndColor(renderingMesh, subMesh, material);\n\n        this.onBeforeRenderMeshToEffect.notifyObservers(ownerMesh);\n\n        // selection outline layer is not compatible with custom materials\n        // if (this._useMeshMaterial(renderingMesh)) {\n        //     subMesh.getMaterial()!._glowModeEnabled = true;\n        //     renderingMesh.render(subMesh, enableAlphaMode, replacementMesh || undefined);\n        //     subMesh.getMaterial()!._glowModeEnabled = false;\n        // } else\n        if (this._isSubMeshReady(subMesh, hardwareInstancedRendering, this._emissiveTextureAndColor.texture)) {\n            const renderingMaterial = effectiveMesh._internalAbstractMeshDataInfo._materialForRenderPass?.[engine.currentRenderPassId];\n\n            let drawWrapper = subMesh._getDrawWrapper();\n            if (!drawWrapper && renderingMaterial) {\n                drawWrapper = renderingMaterial._getDrawWrapper();\n            }\n\n            if (!drawWrapper) {\n                return;\n            }\n\n            const effect = drawWrapper.effect!;\n\n            engine.enableEffect(drawWrapper);\n            if (!hardwareInstancedRendering) {\n                renderingMesh._bind(subMesh, effect, material.fillMode);\n            }\n\n            if (!renderingMaterial) {\n                effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n                if (this._options.storeCameraSpaceZ) {\n                    effect.setMatrix(\"view\", scene.getViewMatrix());\n                } else {\n                    const camera = this.camera || scene.activeCamera;\n                    if (camera) {\n                        const cameraIsOrtho = camera.mode === Camera.ORTHOGRAPHIC_CAMERA;\n\n                        let minZ: number, maxZ: number;\n\n                        if (cameraIsOrtho) {\n                            minZ = !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n                            maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n                        } else {\n                            minZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? camera.minZ : engine.isNDCHalfZRange ? 0 : camera.minZ;\n                            maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : camera.maxZ;\n                        }\n\n                        effect.setFloat2(\"depthValues\", minZ, minZ + maxZ);\n                    }\n                }\n                effect.setMatrix(\"world\", effectiveMesh.getWorldMatrix());\n            } else {\n                renderingMaterial.bindForSubMesh(effectiveMesh.getWorldMatrix(), effectiveMesh as Mesh, subMesh);\n            }\n\n            if (!renderingMaterial) {\n                // Alpha test\n                if (material && material.needAlphaTestingForMesh(effectiveMesh)) {\n                    const alphaTexture = material.getAlphaTestTexture();\n                    if (alphaTexture) {\n                        effect.setTexture(\"diffuseSampler\", alphaTexture);\n                        effect.setMatrix(\"diffuseMatrix\", alphaTexture.getTextureMatrix());\n                    }\n                }\n\n                // Bones\n                BindBonesParameters(renderingMesh, effect);\n\n                // Morph targets\n                BindMorphTargetParameters(renderingMesh, effect);\n                if (renderingMesh.morphTargetManager && renderingMesh.morphTargetManager.isUsingTextureForTargets) {\n                    renderingMesh.morphTargetManager._bind(effect);\n                }\n\n                // Baked vertex animations\n                const bvaManager = subMesh.getMesh().bakedVertexAnimationManager;\n                if (bvaManager && bvaManager.isEnabled) {\n                    bvaManager.bind(effect, hardwareInstancedRendering);\n                }\n\n                // Alpha mode\n                if (enableAlphaMode) {\n                    engine.setAlphaMode(material.alphaMode);\n                }\n\n                // Clip planes\n                BindClipPlane(effect, material, scene);\n\n                // Selection ID\n                const selectionId = this._meshUniqueIdToSelectionId[renderingMesh.uniqueId];\n                if (!renderingMesh.hasInstances && !renderingMesh.hasThinInstances && !renderingMesh.isAnInstance && selectionId !== undefined) {\n                    effect.setFloat(\"selectionId\", selectionId);\n                }\n            }\n\n            // Draw\n            renderingMesh._processRendering(effectiveMesh, subMesh, effect, material.fillMode, batch, hardwareInstancedRendering, (isInstance, world) =>\n                effect.setMatrix(\"world\", world)\n            );\n        } else {\n            // Need to reset refresh rate of the main map\n            this._objectRenderer.resetRefreshCounter();\n        }\n\n        this.onAfterRenderMeshToEffect.notifyObservers(ownerMesh);\n    }\n\n    /** @internal */\n    public override _internalCompose(effect: Effect, _renderIndex: number): void {\n        // Texture\n        this.bindTexturesForCompose(effect);\n        effect.setFloat2(\"screenSize\", this.textureWidth, this.textureHeight);\n        effect.setColor3(\"outlineColor\", this.outlineColor);\n        effect.setFloat(\"outlineThickness\", this.outlineThickness);\n        effect.setFloat(\"occlusionStrength\", this.occlusionStrength);\n        effect.setFloat(\"occlusionThreshold\", this.occlusionThreshold);\n\n        // Cache\n        const engine = this._engine;\n        const previousStencilBuffer = engine.getStencilBuffer();\n\n        // Draw order\n        engine.setStencilBuffer(false);\n\n        engine.drawElementsType(Material.TriangleFillMode, 0, 6);\n\n        // Draw order\n        engine.setStencilBuffer(previousStencilBuffer);\n    }\n\n    /** @internal */\n    public override _setEmissiveTextureAndColor(_mesh: Mesh, _subMesh: SubMesh, _material: Material): void {\n        // we don't use emissive texture or color for this layer\n    }\n\n    /**\n     * Returns true if the layer contains information to display, otherwise false.\n     * @returns true if the glow layer should be rendered\n     */\n    public override shouldRender(): boolean {\n        return this._selection && super.shouldRender() ? true : false;\n    }\n\n    /** @internal */\n    public override _shouldRenderMesh(mesh: Mesh): boolean {\n        return this.hasMesh(mesh);\n    }\n\n    /** @internal */\n    public override _addCustomEffectDefines(defines: string[]): void {\n        if (this._options.storeCameraSpaceZ) {\n            defines.push(\"#define STORE_CAMERASPACE_Z\");\n        }\n    }\n\n    /**\n     * Determine if a given mesh will be used in the current effect.\n     * @param mesh mesh to test\n     * @returns true if the mesh will be used\n     */\n    public override hasMesh(mesh: AbstractMesh): boolean {\n        // we control selection as RTT render list\n        return super.hasMesh(mesh);\n    }\n\n    /** @internal */\n    public override _useMeshMaterial(_mesh: AbstractMesh): boolean {\n        return false;\n    }\n\n    /**\n     * Remove all the meshes currently referenced in the selection outline layer\n     */\n    public clearSelection(): void {\n        if (!this._selection) {\n            return;\n        }\n\n        for (let index = 0; index < this._selection.length; ++index) {\n            const mesh = this._selection[index] as Mesh;\n            if (mesh._userInstancedBuffersStorage) {\n                const kind = ThinSelectionOutlineLayer.InstanceSelectionIdAttributeName;\n                mesh._userInstancedBuffersStorage.vertexBuffers[kind]?.dispose();\n\n                const vao = mesh._userInstancedBuffersStorage.vertexArrayObjects?.[kind];\n                if (vao) {\n                    // invalidate VAO is very important to keep sync between VAO and vertex buffers\n                    (this._engine as ThinEngine).releaseVertexArrayObject(vao);\n                    delete mesh._userInstancedBuffersStorage.vertexArrayObjects![kind];\n                }\n\n                delete mesh._userInstancedBuffersStorage.data[kind];\n                delete mesh._userInstancedBuffersStorage.vertexBuffers[kind];\n                delete mesh._userInstancedBuffersStorage.strides[kind];\n                delete mesh._userInstancedBuffersStorage.sizes[kind];\n\n                if (Object.keys(mesh._userInstancedBuffersStorage.vertexBuffers).length === 0) {\n                    mesh._userInstancedBuffersStorage = undefined!;\n                }\n            }\n            if (mesh.instancedBuffers?.[ThinSelectionOutlineLayer.InstanceSelectionIdAttributeName] !== undefined) {\n                delete mesh.instancedBuffers[ThinSelectionOutlineLayer.InstanceSelectionIdAttributeName];\n            }\n        }\n        this._selection.length = 0;\n        this._meshUniqueIdToSelectionId.length = 0;\n\n        this._nextSelectionId = 1;\n\n        this._shouldRender = false;\n    }\n\n    /**\n     * Adds mesh or group of mesh to the current selection\n     *\n     * If a group of meshes is provided, they will outline as a single unit\n     * @param meshOrGroup Meshes to add to the selection\n     */\n    public addSelection(meshOrGroup: AbstractMesh | AbstractMesh[]): void {\n        if (!this._selection) {\n            return;\n        }\n\n        const nextId = this._nextSelectionId;\n\n        const group = Array.isArray(meshOrGroup) ? meshOrGroup : [meshOrGroup];\n        if (group.length === 0) {\n            return;\n        }\n\n        for (let meshIndex = 0; meshIndex < group.length; ++meshIndex) {\n            const mesh = group[meshIndex];\n\n            this._selection.push(mesh); // add to render list\n\n            if (mesh.hasInstances || mesh.isAnInstance) {\n                const sourceMesh = (mesh as InstancedMesh).sourceMesh ?? (mesh as Mesh);\n\n                if (sourceMesh.instancedBuffers?.[ThinSelectionOutlineLayer.InstanceSelectionIdAttributeName] === undefined) {\n                    sourceMesh.registerInstancedBuffer(ThinSelectionOutlineLayer.InstanceSelectionIdAttributeName, 1);\n                }\n\n                mesh.instancedBuffers[ThinSelectionOutlineLayer.InstanceSelectionIdAttributeName] = nextId;\n            } else if (mesh.hasThinInstances) {\n                const thinInstanceCount = (mesh as Mesh).thinInstanceCount;\n                const selectionIdData = new Float32Array(thinInstanceCount);\n                for (let i = 0; i < thinInstanceCount; i++) {\n                    selectionIdData[i] = nextId;\n                }\n                (mesh as Mesh).thinInstanceSetBuffer(ThinSelectionOutlineLayer.InstanceSelectionIdAttributeName, selectionIdData, 1);\n            } else {\n                this._meshUniqueIdToSelectionId[mesh.uniqueId] = nextId;\n            }\n        }\n        this._nextSelectionId += 1;\n\n        this._shouldRender = true;\n    }\n\n    /**\n     * Free any resources and references associated to a mesh.\n     * Internal use\n     * @param mesh The mesh to free.\n     * @internal\n     */\n    public _disposeMesh(mesh: Mesh): void {\n        const selection = this._selection;\n        if (!selection) {\n            return;\n        }\n\n        const index = selection.indexOf(mesh);\n        if (index !== -1) {\n            selection.splice(index, 1);\n\n            if (mesh.hasInstances) {\n                mesh.removeVerticesData(ThinSelectionOutlineLayer.InstanceSelectionIdAttributeName);\n            } else if (mesh.hasThinInstances) {\n                (mesh as Mesh).thinInstanceSetBuffer(ThinSelectionOutlineLayer.InstanceSelectionIdAttributeName, null);\n            }\n\n            if (selection.length === 0) {\n                this._shouldRender = false;\n            }\n        }\n    }\n\n    /**\n     * Dispose the effect layer and free resources.\n     */\n    public override dispose(): void {\n        this.clearSelection();\n        this._selection = null;\n\n        super.dispose();\n    }\n}\n"]}