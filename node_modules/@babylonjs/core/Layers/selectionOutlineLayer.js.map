{"version":3,"file":"selectionOutlineLayer.js","sourceRoot":"","sources":["../../../../dev/core/src/Layers/selectionOutlineLayer.ts"],"names":[],"mappings":"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","sourcesContent":["import { serialize, serializeAsColor3 } from \"../Misc/decorators\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport type { SubMesh } from \"../Meshes/subMesh\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport { EffectLayer } from \"./effectLayer\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\n\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport type { IThinSelectionOutlineLayerOptions } from \"./thinSelectionOutlineLayer\";\r\nimport { ThinSelectionOutlineLayer } from \"./thinSelectionOutlineLayer\";\r\nimport type { Color3 } from \"../Maths/math.color\";\r\n\r\ndeclare module \"../scene\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Scene {\r\n        /**\r\n         * Return a the first selection outline layer of the scene with a given name.\r\n         * @param name The name of the selection outline layer to look for.\r\n         * @returns The selection outline layer if found otherwise null.\r\n         */\r\n        getSelectionOutlineLayerByName(name: string): Nullable<SelectionOutlineLayer>;\r\n    }\r\n}\r\n\r\nScene.prototype.getSelectionOutlineLayerByName = function (name: string): Nullable<SelectionOutlineLayer> {\r\n    for (let index = 0; index < this.effectLayers?.length; index++) {\r\n        if (this.effectLayers[index].name === name && this.effectLayers[index].getEffectName() === SelectionOutlineLayer.EffectName) {\r\n            return (<any>this.effectLayers[index]) as SelectionOutlineLayer;\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n/**\r\n * Selection outline layer options. This helps customizing the behaviour\r\n * of the selection outline layer.\r\n */\r\nexport interface ISelectionOutlineLayerOptions extends IThinSelectionOutlineLayerOptions {\r\n    /**\r\n     * Enable MSAA by choosing the number of samples. Default: 1\r\n     */\r\n    mainTextureSamples?: number;\r\n}\r\n\r\n/**\r\n * The selection outline layer Helps adding a outline effect around a mesh.\r\n *\r\n * Once instantiated in a scene, simply use the addMesh or removeMesh method to add or remove\r\n * outlined meshes to your scene.\r\n */\r\nexport class SelectionOutlineLayer extends EffectLayer {\r\n    /**\r\n     * Effect Name of the selection outline layer.\r\n     */\r\n    public static get EffectName() {\r\n        return ThinSelectionOutlineLayer.EffectName;\r\n    }\r\n\r\n    /**\r\n     * The outline color (default (1, 0.5, 0))\r\n     */\r\n    @serializeAsColor3()\r\n    public get outlineColor(): Color3 {\r\n        return this._thinEffectLayer.outlineColor;\r\n    }\r\n\r\n    public set outlineColor(value: Color3) {\r\n        this._thinEffectLayer.outlineColor = value;\r\n    }\r\n\r\n    /**\r\n     * The thickness of the edges (default: 2.0)\r\n     */\r\n    @serialize()\r\n    public get outlineThickness(): number {\r\n        return this._thinEffectLayer.outlineThickness;\r\n    }\r\n\r\n    public set outlineThickness(value: number) {\r\n        this._thinEffectLayer.outlineThickness = value;\r\n    }\r\n\r\n    /**\r\n     * The strength of the occlusion effect (default: 0.8)\r\n     */\r\n    @serialize()\r\n    public get occlusionStrength(): number {\r\n        return this._thinEffectLayer.occlusionStrength;\r\n    }\r\n\r\n    public set occlusionStrength(value: number) {\r\n        this._thinEffectLayer.occlusionStrength = value;\r\n    }\r\n\r\n    /**\r\n     * The occlusion threshold (default: 0.01)\r\n     */\r\n    @serialize()\r\n    public get occlusionThreshold(): number {\r\n        return this._thinEffectLayer.occlusionThreshold;\r\n    }\r\n\r\n    public set occlusionThreshold(value: number) {\r\n        this._thinEffectLayer.occlusionThreshold = value;\r\n    }\r\n\r\n    @serialize(\"options\")\r\n    private _options: Required<ISelectionOutlineLayerOptions>;\r\n\r\n    protected override readonly _thinEffectLayer: ThinSelectionOutlineLayer;\r\n\r\n    /**\r\n     * Instantiates a new selection outline Layer and references it to the scene..\r\n     * @param name The name of the layer\r\n     * @param scene The scene to use the layer in\r\n     * @param options Sets of none mandatory options to use with the layer (see ISelectionOutlineLayerOptions for more information)\r\n     */\r\n    public constructor(name: string, scene?: Scene, options?: Partial<ISelectionOutlineLayerOptions>) {\r\n        super(name, scene, options !== undefined ? !!options.forceGLSL : false, new ThinSelectionOutlineLayer(name, scene, options));\r\n\r\n        // Adapt options\r\n        this._options = {\r\n            mainTextureRatio: 1.0,\r\n            mainTextureFixedSize: 0,\r\n            alphaBlendingMode: Constants.ALPHA_COMBINE,\r\n            camera: null,\r\n            mainTextureSamples: 1,\r\n            renderingGroupId: -1,\r\n            mainTextureType: Constants.TEXTURETYPE_FLOAT,\r\n            mainTextureFormat: Constants.TEXTUREFORMAT_RG,\r\n            forceGLSL: false,\r\n            storeCameraSpaceZ: false,\r\n            outlineMethod: Constants.OUTLINELAYER_SAMPLING_TRIDIRECTIONAL,\r\n            ...options,\r\n        };\r\n\r\n        // Initialize the layer\r\n        this._init(this._options);\r\n\r\n        // Do not render as long as no meshes have been added\r\n        this._shouldRender = false;\r\n\r\n        this._scene.enableDepthRenderer();\r\n    }\r\n\r\n    /**\r\n     * Get the effect name of the layer.\r\n     * @returns The effect name\r\n     */\r\n    public getEffectName(): string {\r\n        return SelectionOutlineLayer.EffectName;\r\n    }\r\n\r\n    protected override _numInternalDraws(): number {\r\n        return 1; // draw depth mask on main pass and outline on merge pass\r\n    }\r\n\r\n    /**\r\n     * Create the merge effect. This is the shader use to blit the information back\r\n     * to the main canvas at the end of the scene rendering.\r\n     * @returns The effect created\r\n     */\r\n    protected _createMergeEffect(): Effect {\r\n        return this._thinEffectLayer._createMergeEffect();\r\n    }\r\n\r\n    /**\r\n     * Creates the render target textures and post processes used in the selection outline layer.\r\n     */\r\n    protected _createTextureAndPostProcesses(): void {\r\n        this._textures = [];\r\n\r\n        this._thinEffectLayer.bindTexturesForCompose = (effect: Effect): void => {\r\n            effect.setTexture(\"maskSampler\", this._mainTexture);\r\n            const depthRenderer = this._scene.enableDepthRenderer();\r\n            effect.setTexture(\"depthSampler\", depthRenderer.getDepthMap());\r\n\r\n            const mainTextureDesiredSize = this._mainTextureDesiredSize;\r\n            this._thinEffectLayer.textureWidth = mainTextureDesiredSize.width;\r\n            this._thinEffectLayer.textureHeight = mainTextureDesiredSize.height;\r\n        };\r\n\r\n        this._thinEffectLayer._createTextureAndPostProcesses();\r\n\r\n        this._postProcesses = [];\r\n\r\n        this._mainTexture.samples = this._options.mainTextureSamples;\r\n        this._mainTexture.onAfterUnbindObservable.add(() => {\r\n            // glow layer and highlight layer both call this._scene.postProcessManager.directRender\r\n            // when you call this._scene.postProcessManager.directRender, it has 4 side effects:\r\n            // 1. binds the framebuffer\r\n            // 2. setAlphaMode(ALPHA_DISABLE)\r\n            // 3. setDepthBuffer(true)\r\n            // 4. setDepthWrite(true)\r\n            // glow layer and highlight layer are restore framebuffer and depends on other side effects\r\n            // but for now 3 and 4 are not needed to resolve the state management issue, so we just restore alpha mode\r\n            this._scene.getEngine().setAlphaMode(Constants.ALPHA_DISABLE);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Creates the main texture for the effect layer.\r\n     */\r\n    protected override _createMainTexture(): void {\r\n        super._createMainTexture();\r\n        // set the render list for selective rendering\r\n        this._mainTexture.renderList = this._thinEffectLayer._selection;\r\n    }\r\n\r\n    /**\r\n     * @returns whether or not the layer needs stencil enabled during the mesh rendering.\r\n     */\r\n    public needStencil(): boolean {\r\n        return this._thinEffectLayer.needStencil();\r\n    }\r\n\r\n    /**\r\n     * Checks for the readiness of the element composing the layer.\r\n     * @param subMesh the mesh to check for\r\n     * @param useInstances specify whether or not to use instances to render the mesh\r\n     * @returns true if ready otherwise, false\r\n     */\r\n    public isReady(subMesh: SubMesh, useInstances: boolean): boolean {\r\n        return this._thinEffectLayer.isReady(subMesh, useInstances);\r\n    }\r\n\r\n    /**\r\n     * Implementation specific of rendering the generating effect on the main canvas.\r\n     * @param effect The effect used to render through\r\n     * @param renderIndex\r\n     */\r\n    protected _internalRender(effect: Effect, renderIndex: number): void {\r\n        this._thinEffectLayer._internalCompose(effect, renderIndex);\r\n    }\r\n\r\n    /**\r\n     * @returns true if the layer contains information to display, otherwise false.\r\n     */\r\n    public override shouldRender(): boolean {\r\n        return this._thinEffectLayer.shouldRender();\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh should render, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @returns true if it should render otherwise false\r\n     */\r\n    protected override _shouldRenderMesh(mesh: Mesh): boolean {\r\n        return this._thinEffectLayer._shouldRenderMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the mesh can be rendered, otherwise false.\r\n     * @param mesh The mesh to render\r\n     * @param material The material used on the mesh\r\n     * @returns true if it can be rendered otherwise false\r\n     */\r\n    protected override _canRenderMesh(mesh: AbstractMesh, material: Material): boolean {\r\n        return this._thinEffectLayer._canRenderMesh(mesh, material);\r\n    }\r\n\r\n    /**\r\n     * Adds specific effects defines.\r\n     * @param defines The defines to add specifics to.\r\n     */\r\n    protected override _addCustomEffectDefines(defines: string[]): void {\r\n        this._thinEffectLayer._addCustomEffectDefines(defines);\r\n    }\r\n\r\n    /**\r\n     * Sets the required values for both the emissive texture and and the main color.\r\n     * @param mesh\r\n     * @param subMesh\r\n     * @param material\r\n     */\r\n    protected _setEmissiveTextureAndColor(mesh: Mesh, subMesh: SubMesh, material: Material): void {\r\n        this._thinEffectLayer._setEmissiveTextureAndColor(mesh, subMesh, material);\r\n    }\r\n\r\n    /**\r\n     * Determine if a given mesh will be highlighted by the current SelectionOutlineLayer\r\n     * @param mesh mesh to test\r\n     * @returns true if the mesh will be highlighted by the current SelectionOutlineLayer\r\n     */\r\n    public override hasMesh(mesh: AbstractMesh): boolean {\r\n        return this._thinEffectLayer.hasMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Remove all the meshes currently referenced in the selection outline layer\r\n     */\r\n    public clearSelection(): void {\r\n        this._thinEffectLayer.clearSelection();\r\n        this._mainTexture.renderList = this._thinEffectLayer._selection; // update render list\r\n    }\r\n\r\n    /**\r\n     * Adds mesh or group of mesh to the current selection\r\n     *\r\n     * If a group of meshes is provided, they will outline as a single unit\r\n     * @param meshOrGroup Meshes to add to the selection\r\n     */\r\n    public addSelection(meshOrGroup: AbstractMesh | AbstractMesh[]): void {\r\n        this._thinEffectLayer.addSelection(meshOrGroup);\r\n    }\r\n\r\n    /**\r\n     * Free any resources and references associated to a mesh.\r\n     * Internal use\r\n     * @param mesh The mesh to free.\r\n     * @internal\r\n     */\r\n    public _disposeMesh(mesh: Mesh): void {\r\n        this._thinEffectLayer._disposeMesh(mesh);\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the effect layer\r\n     * @returns the string with the class name of the effect layer\r\n     */\r\n    public override getClassName(): string {\r\n        return \"SelectionOutlineLayer\";\r\n    }\r\n\r\n    /**\r\n     * Serializes this SelectionOutline layer\r\n     * @returns a serialized SelectionOutline layer object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this);\r\n        serializationObject.customType = \"BABYLON.SelectionOutlineLayer\";\r\n\r\n        // Selected meshes\r\n        serializationObject.selection = [];\r\n\r\n        const selection = this._thinEffectLayer._selection;\r\n        if (selection) {\r\n            const meshUniqueIdToSelectionId = this._thinEffectLayer._meshUniqueIdToSelectionId;\r\n\r\n            // selection can be sparse since _removeMesh can remove entries\r\n            const selectionMap: {\r\n                [uniqueId: number]: {\r\n                    meshIds: string[];\r\n                };\r\n            } = {};\r\n\r\n            for (let i = 0; i < selection.length; ++i) {\r\n                const mesh = selection[i];\r\n                const selectionId = meshUniqueIdToSelectionId[mesh.uniqueId];\r\n\r\n                if (!selectionMap[selectionId]) {\r\n                    selectionMap[selectionId] = {\r\n                        meshIds: [],\r\n                    };\r\n                }\r\n                selectionMap[selectionId].meshIds.push(mesh.id);\r\n            }\r\n            serializationObject.selection = selectionMap;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Creates a SelectionOutline layer from parsed SelectionOutline layer data\r\n     * @param parsedSelectionOutlineLayer defines the SelectionOutline layer data\r\n     * @param scene defines the current scene\r\n     * @param rootUrl defines the root URL containing the SelectionOutline layer information\r\n     * @returns a parsed SelectionOutline layer\r\n     */\r\n    public static override Parse(parsedSelectionOutlineLayer: any, scene: Scene, rootUrl: string): SelectionOutlineLayer {\r\n        const selectionOutlineLayer = SerializationHelper.Parse(\r\n            () => new SelectionOutlineLayer(parsedSelectionOutlineLayer.name, scene, parsedSelectionOutlineLayer.options),\r\n            parsedSelectionOutlineLayer,\r\n            scene,\r\n            rootUrl\r\n        );\r\n\r\n        const selectionMap = parsedSelectionOutlineLayer.selection as { [uniqueId: number]: { meshIds: string[] } };\r\n\r\n        // Selected meshes\r\n        for (const outlinedMeshes of Object.values(selectionMap)) {\r\n            const meshes: AbstractMesh[] = [];\r\n            for (let meshIndex = 0; meshIndex < outlinedMeshes.meshIds.length; meshIndex++) {\r\n                const meshId = outlinedMeshes.meshIds[meshIndex];\r\n                const mesh = scene.getMeshById(meshId);\r\n                if (mesh) {\r\n                    meshes.push(mesh);\r\n                }\r\n            }\r\n\r\n            selectionOutlineLayer.addSelection(meshes);\r\n        }\r\n\r\n        return selectionOutlineLayer;\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.SelectionOutlineLayer\", SelectionOutlineLayer);\r\n"]}