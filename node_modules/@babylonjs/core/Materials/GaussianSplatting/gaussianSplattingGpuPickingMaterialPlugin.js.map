{"version":3,"file":"gaussianSplattingGpuPickingMaterialPlugin.js","sourceRoot":"","sources":["../../../../../dev/core/src/Materials/GaussianSplatting/gaussianSplattingGpuPickingMaterialPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { UniformBuffer } from \"../uniformBuffer\";\r\nimport type { MaterialDefines } from \"../materialDefines\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport { GaussianSplattingMaxPartCount } from \"./gaussianSplattingMaterial\";\r\nimport type { GaussianSplattingMaterial } from \"./gaussianSplattingMaterial\";\r\n\r\n/**\r\n * Plugin for GaussianSplattingMaterial that replaces per-splat color output with\r\n * a pre-computed picking color for GPU-based hit testing.\r\n *\r\n * The picking color is computed on the CPU by encoding a 24-bit picking ID as RGB\r\n * (matching the readback decoding in GPUPicker).\r\n * @experimental\r\n */\r\nexport class GaussianSplattingGpuPickingMaterialPlugin extends MaterialPluginBase {\r\n    private _pickingColor: [number, number, number] = [0, 0, 0];\r\n    private _isCompound: boolean = false;\r\n    private _partPickingColors: number[] = [];\r\n    private _maxPartCount: number;\r\n\r\n    /**\r\n     * Creates a new GaussianSplattingGpuPickingMaterialPlugin.\r\n     * @param material The GaussianSplattingMaterial to attach the plugin to.\r\n     * @param maxPartCount The maximum number of parts supported for compound meshes.\r\n     */\r\n    constructor(material: GaussianSplattingMaterial, maxPartCount = GaussianSplattingMaxPartCount) {\r\n        super(material, \"GaussianSplatGpuPicking\", 200);\r\n\r\n        this._maxPartCount = maxPartCount;\r\n        this._enable(true);\r\n    }\r\n\r\n    /**\r\n     * Encodes a 24-bit picking ID into normalized RGB components.\r\n     * @param id The picking ID to encode\r\n     * @returns A tuple [r, g, b] with values in [0, 1]\r\n     */\r\n    public static EncodeIdToColor(id: number): [number, number, number] {\r\n        return [((id >> 16) & 0xff) / 255, ((id >> 8) & 0xff) / 255, (id & 0xff) / 255];\r\n    }\r\n\r\n    /**\r\n     * Sets the picking color for a non-compound mesh from a picking ID.\r\n     * The ID is encoded into an RGB color on the CPU.\r\n     * @param id The 24-bit picking ID.\r\n     */\r\n    public set meshId(id: number) {\r\n        this._pickingColor = GaussianSplattingGpuPickingMaterialPlugin.EncodeIdToColor(id);\r\n    }\r\n\r\n    /**\r\n     * Sets whether this material is for a compound mesh with per-part picking.\r\n     */\r\n    public set isCompound(value: boolean) {\r\n        this._isCompound = value;\r\n        this.markAllDefinesAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets whether this material is for a compound mesh with per-part picking.\r\n     */\r\n    public get isCompound(): boolean {\r\n        return this._isCompound;\r\n    }\r\n\r\n    /**\r\n     * Sets the per-part picking colors from an array of picking IDs.\r\n     * Each ID is encoded into an RGB color on the CPU.\r\n     * @param ids Array mapping part index to picking ID.\r\n     */\r\n    public set partMeshIds(ids: number[]) {\r\n        const colors: number[] = [];\r\n        for (let i = 0; i < this._maxPartCount; i++) {\r\n            const c = i < ids.length ? GaussianSplattingGpuPickingMaterialPlugin.EncodeIdToColor(ids[i]) : ([0, 0, 0] as [number, number, number]);\r\n            colors.push(c[0], c[1], c[2]);\r\n        }\r\n        this._partPickingColors = colors;\r\n    }\r\n\r\n    /**\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"GaussianSplattingGpuPickingMaterialPlugin\";\r\n    }\r\n\r\n    /**\r\n     * Indicates this plugin supports both GLSL and WGSL.\r\n     * @param shaderLanguage the shader language to check\r\n     * @returns true for GLSL and WGSL\r\n     */\r\n    public override isCompatible(shaderLanguage: ShaderLanguage): boolean {\r\n        switch (shaderLanguage) {\r\n            case ShaderLanguage.GLSL:\r\n            case ShaderLanguage.WGSL:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Always ready — no textures or async resources to wait on.\r\n     * @param _defines the defines\r\n     * @param _scene the scene\r\n     * @param _engine the engine\r\n     * @param _subMesh the submesh\r\n     * @returns true\r\n     */\r\n    public override isReadyForSubMesh(_defines: MaterialDefines, _scene: Scene, _engine: AbstractEngine, _subMesh: SubMesh): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns custom shader code to inject GPU picking color output.\r\n     *\r\n     * @param shaderType \"vertex\" or \"fragment\"\r\n     * @param shaderLanguage the shader language to use (default: GLSL)\r\n     * @returns null or a map of injection point names to code strings\r\n     */\r\n    public override getCustomCode(shaderType: string, shaderLanguage = ShaderLanguage.GLSL): Nullable<{ [pointName: string]: string }> {\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            return this._getCustomCodeWGSL(shaderType);\r\n        }\r\n        return this._getCustomCodeGLSL(shaderType);\r\n    }\r\n\r\n    private _getCustomCodeGLSL(shaderType: string): Nullable<{ [pointName: string]: string }> {\r\n        if (shaderType === \"vertex\") {\r\n            return {\r\n                CUSTOM_VERTEX_DEFINITIONS: `varying float vPartIndex;`,\r\n                CUSTOM_VERTEX_UPDATE: `\r\n#if IS_COMPOUND\r\n    vPartIndex = float(splat.partIndex);\r\n#else\r\n    vPartIndex = 0.0;\r\n#endif\r\n                `,\r\n            };\r\n        } else if (shaderType === \"fragment\") {\r\n            return {\r\n                CUSTOM_FRAGMENT_DEFINITIONS: `\r\nvarying float vPartIndex;\r\n#if IS_COMPOUND\r\nuniform vec3 partPickingColors[${this._maxPartCount}];\r\n#else\r\nuniform vec3 pickingColor;\r\n#endif\r\n                `,\r\n                CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: `\r\n#if IS_COMPOUND\r\n    finalColor = vec4(partPickingColors[int(vPartIndex + 0.5)], 1.0);\r\n#else\r\n    finalColor = vec4(pickingColor, 1.0);\r\n#endif\r\n                `,\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private _getCustomCodeWGSL(shaderType: string): Nullable<{ [pointName: string]: string }> {\r\n        if (shaderType === \"vertex\") {\r\n            return {\r\n                CUSTOM_VERTEX_DEFINITIONS: `varying vPartIndex: f32;`,\r\n                CUSTOM_VERTEX_UPDATE: `\r\n#if IS_COMPOUND\r\n    vertexOutputs.vPartIndex = f32(splat.partIndex);\r\n#else\r\n    vertexOutputs.vPartIndex = 0.0;\r\n#endif\r\n                `,\r\n            };\r\n        } else if (shaderType === \"fragment\") {\r\n            return {\r\n                CUSTOM_FRAGMENT_DEFINITIONS: `\r\nvarying vPartIndex: f32;\r\n#if IS_COMPOUND\r\nuniform partPickingColors: array<vec3f, ${this._maxPartCount}>;\r\n#else\r\nuniform pickingColor: vec3f;\r\n#endif\r\n                `,\r\n                CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: `\r\n#if IS_COMPOUND\r\n    finalColor = vec4f(uniforms.partPickingColors[i32(fragmentInputs.vPartIndex + 0.5)], 1.0);\r\n#else\r\n    finalColor = vec4f(uniforms.pickingColor, 1.0);\r\n#endif\r\n                `,\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Registers the picking uniforms with the engine.\r\n     * @returns uniform descriptions\r\n     */\r\n    public override getUniforms(): {\r\n        ubo?: Array<{ name: string; size?: number; type?: string; arraySize?: number }>;\r\n        vertex?: string;\r\n        fragment?: string;\r\n        externalUniforms?: string[];\r\n    } {\r\n        return {\r\n            externalUniforms: [\"pickingColor\", \"partPickingColors\"],\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds the picking color uniform(s) each frame.\r\n     * @param _uniformBuffer the uniform buffer (unused — we bind directly on the effect)\r\n     * @param _scene the current scene\r\n     * @param _engine the current engine\r\n     * @param subMesh the submesh being rendered\r\n     */\r\n    public override bindForSubMesh(_uniformBuffer: UniformBuffer, _scene: Scene, _engine: AbstractEngine, subMesh: SubMesh): void {\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        if (this._isCompound) {\r\n            effect.setArray3(\"partPickingColors\", this._partPickingColors);\r\n        } else {\r\n            effect.setFloat3(\"pickingColor\", this._pickingColor[0], this._pickingColor[1], this._pickingColor[2]);\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GaussianSplattingGpuPickingMaterialPlugin\", GaussianSplattingGpuPickingMaterialPlugin);\r\n"]}