{"version":3,"file":"gaussianSplattingSolidColorMaterialPlugin.js","sourceRoot":"","sources":["../../../../../dev/core/src/Materials/GaussianSplatting/gaussianSplattingSolidColorMaterialPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Nullable } from \"../../types\";\r\nimport type { Scene } from \"../../scene\";\r\nimport type { AbstractEngine } from \"../../Engines/abstractEngine\";\r\nimport type { SubMesh } from \"../../Meshes/subMesh\";\r\nimport type { UniformBuffer } from \"../uniformBuffer\";\r\nimport type { MaterialDefines } from \"../materialDefines\";\r\nimport { Color3 } from \"../../Maths/math.color\";\r\nimport { MaterialPluginBase } from \"../materialPluginBase\";\r\nimport { ShaderLanguage } from \"../shaderLanguage\";\r\nimport { RegisterClass } from \"../../Misc/typeStore\";\r\nimport { GaussianSplattingMaxPartCount } from \"./gaussianSplattingMaterial\";\r\nimport type { GaussianSplattingMaterial } from \"./gaussianSplattingMaterial\";\r\n\r\n/**\r\n * Plugin for GaussianSplattingMaterial that replaces per-splat colors with a\r\n * solid color per compound-mesh part. Each part index maps to a single Color3\r\n * value, which is looked up in a uniform array in the fragment shader.\r\n */\r\nexport class GaussianSplattingSolidColorMaterialPlugin extends MaterialPluginBase {\r\n    private _partColors: Color3[];\r\n    private _maxPartCount: number;\r\n\r\n    /**\r\n     * Creates a new GaussianSplatSolidColorPlugin.\r\n     * @param material The GaussianSplattingMaterial to attach the plugin to.\r\n     * @param partColors A map from part index to the solid Color3 for that part.\r\n     * @param maxPartCount The maximum number of parts supported. This determines the size of the uniform array.\r\n     */\r\n    constructor(material: GaussianSplattingMaterial, partColors: Color3[], maxPartCount = GaussianSplattingMaxPartCount) {\r\n        super(material, \"GaussianSplatSolidColor\", 200);\r\n\r\n        this._partColors = partColors;\r\n        this._maxPartCount = maxPartCount;\r\n        this._enable(true);\r\n    }\r\n\r\n    /**\r\n     * Updates the part colors dynamically.\r\n     * @param partColors A map from part index to the solid Color3 for that part.\r\n     */\r\n    public updatePartColors(partColors: Color3[]): void {\r\n        this._partColors = partColors;\r\n    }\r\n\r\n    // --- Plugin overrides ---\r\n\r\n    /**\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"GaussianSplattingSolidColorMaterialPlugin\";\r\n    }\r\n\r\n    /**\r\n     * Indicates this plugin supports both GLSL and WGSL.\r\n     * @param shaderLanguage the shader language to check\r\n     * @returns true for GLSL and WGSL\r\n     */\r\n    public override isCompatible(shaderLanguage: ShaderLanguage): boolean {\r\n        switch (shaderLanguage) {\r\n            case ShaderLanguage.GLSL:\r\n            case ShaderLanguage.WGSL:\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Always ready — no textures or async resources to wait on.\r\n     * @param _defines the defines\r\n     * @param _scene the scene\r\n     * @param _engine the engine\r\n     * @param _subMesh the submesh\r\n     * @returns true\r\n     */\r\n    public override isReadyForSubMesh(_defines: MaterialDefines, _scene: Scene, _engine: AbstractEngine, _subMesh: SubMesh): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns custom shader code fragments to inject solid-color rendering.\r\n     *\r\n     * @param shaderType \"vertex\" or \"fragment\"\r\n     * @param shaderLanguage the shader language to use (default: GLSL)\r\n     * @returns null or a map of injection point names to code strings\r\n     */\r\n    public override getCustomCode(shaderType: string, shaderLanguage = ShaderLanguage.GLSL): Nullable<{ [pointName: string]: string }> {\r\n        const maxPartCount = this._maxPartCount ?? GaussianSplattingMaxPartCount;\r\n\r\n        if (shaderLanguage === ShaderLanguage.WGSL) {\r\n            return this._getCustomCodeWGSL(shaderType, maxPartCount);\r\n        }\r\n        return this._getCustomCodeGLSL(shaderType, maxPartCount);\r\n    }\r\n\r\n    private _getCustomCodeGLSL(shaderType: string, maxPartCount: number): Nullable<{ [pointName: string]: string }> {\r\n        if (shaderType === \"vertex\") {\r\n            return {\r\n                CUSTOM_VERTEX_DEFINITIONS: `varying float vPartIndex;`,\r\n                CUSTOM_VERTEX_UPDATE: `\r\n#if IS_COMPOUND\r\n    vPartIndex = float(splat.partIndex);\r\n#else\r\n    vPartIndex = 0.0;\r\n#endif\r\n                `,\r\n            };\r\n        } else if (shaderType === \"fragment\") {\r\n            return {\r\n                CUSTOM_FRAGMENT_DEFINITIONS: `\r\nvarying float vPartIndex;\r\nuniform vec3 partColors[${maxPartCount}];\r\n                `,\r\n                CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: `\r\nint partIdx = int(vPartIndex + 0.5);\r\nfinalColor = vec4(partColors[partIdx], finalColor.w);\r\n                `,\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private _getCustomCodeWGSL(shaderType: string, maxPartCount: number): Nullable<{ [pointName: string]: string }> {\r\n        if (shaderType === \"vertex\") {\r\n            return {\r\n                CUSTOM_VERTEX_DEFINITIONS: `varying vPartIndex: f32;`,\r\n                CUSTOM_VERTEX_UPDATE: `\r\n#if IS_COMPOUND\r\n    vertexOutputs.vPartIndex = f32(splat.partIndex);\r\n#else\r\n    vertexOutputs.vPartIndex = 0.0;\r\n#endif\r\n                `,\r\n            };\r\n        } else if (shaderType === \"fragment\") {\r\n            return {\r\n                CUSTOM_FRAGMENT_DEFINITIONS: `\r\nvarying vPartIndex: f32;\r\nuniform partColors: array<vec3f, ${maxPartCount}>;\r\n                `,\r\n                CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR: `\r\nvar partIdx: i32 = i32(fragmentInputs.vPartIndex + 0.5);\r\nfinalColor = vec4f(uniforms.partColors[partIdx], finalColor.w);\r\n                `,\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Registers the `partColors` uniform with the engine so that\r\n     * the Effect can resolve its location.\r\n     * @returns uniform descriptions\r\n     */\r\n    public override getUniforms(): {\r\n        ubo?: Array<{ name: string; size?: number; type?: string; arraySize?: number }>;\r\n        vertex?: string;\r\n        fragment?: string;\r\n        externalUniforms?: string[];\r\n    } {\r\n        return {\r\n            externalUniforms: [\"partColors\"],\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Binds the `partColors` uniform array each frame.\r\n     * @param _uniformBuffer the uniform buffer (unused — we bind directly on the effect)\r\n     * @param _scene the current scene\r\n     * @param _engine the current engine\r\n     * @param subMesh the submesh being rendered\r\n     */\r\n    public override bindForSubMesh(_uniformBuffer: UniformBuffer, _scene: Scene, _engine: AbstractEngine, subMesh: SubMesh): void {\r\n        const effect = subMesh.effect;\r\n        if (!effect) {\r\n            return;\r\n        }\r\n\r\n        const colorArray: number[] = [];\r\n        for (let i = 0; i < this._maxPartCount; i++) {\r\n            const color = this._partColors[i] ?? new Color3(0, 0, 0);\r\n            colorArray.push(color.r, color.g, color.b);\r\n        }\r\n\r\n        effect.setArray3(\"partColors\", colorArray);\r\n    }\r\n}\r\n\r\nRegisterClass(\"BABYLON.GaussianSplattingSolidColorMaterialPlugin\", GaussianSplattingSolidColorMaterialPlugin);\r\n"]}