{"version":3,"file":"vertexPullingHelper.functions.js","sourceRoot":"","sources":["../../../../dev/core/src/Materials/vertexPullingHelper.functions.ts"],"names":[],"mappings":"AAwBA,6CAA6C;AAC7C,MAAM,2BAA2B,GAAG,IAAI,OAAO,EAAiD,CAAC;AAEjG;;;;GAIG;AACH,MAAM,UAAU,4BAA4B,CAAC,QAAkB;IAC3D,MAAM,aAAa,GAAG,QAAQ,CAAC,gBAAgB,EAAE,CAAC;IAClD,IAAI,CAAC,aAAa,EAAE,CAAC;QACjB,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,oBAAoB;IACpB,IAAI,QAAQ,GAAG,2BAA2B,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;IACzD,IAAI,CAAC,QAAQ,EAAE,CAAC;QACZ,QAAQ,GAAG,IAAI,GAAG,EAAkC,CAAC;QACrD,2BAA2B,CAAC,GAAG,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;IACxD,CAAC;SAAM,CAAC;QACJ,yDAAyD;QACzD,IAAI,WAAW,GAAG,KAAK,CAAC;QACxB,KAAK,MAAM,EAAE,IAAI,aAAa,EAAE,CAAC;YAC7B,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC;gBACpB,WAAW,GAAG,IAAI,CAAC;gBACnB,MAAM;YACV,CAAC;QACL,CAAC;QACD,IAAI,CAAC,WAAW,EAAE,CAAC;YACf,OAAO,QAAQ,CAAC;QACpB,CAAC;IACL,CAAC;IAED,2BAA2B;IAC3B,KAAK,MAAM,EAAE,IAAI,aAAa,EAAE,CAAC;QAC7B,MAAM,YAAY,GAAG,aAAa,CAAC,EAAE,CAAC,CAAC;QACvC,IAAI,YAAY,EAAE,CAAC;YACf,MAAM,MAAM,GAAG,YAAY,CAAC,UAAU,CAAC;YACvC,MAAM,MAAM,GAAG,YAAY,CAAC,UAAU,CAAC;YACvC,MAAM,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC;YAE/B,QAAQ,CAAC,GAAG,CAAC,EAAE,EAAE;gBACb,MAAM,EAAE,MAAM;gBACd,MAAM,EAAE,MAAM;gBACd,IAAI,EAAE,IAAI;aACb,CAAC,CAAC;QACP,CAAC;IACL,CAAC;IAED,OAAO,QAAQ,CAAC;AACpB,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,yBAAyB,CAAC,MAAc,EAAE,QAA6C;IACnG,QAAQ,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,SAAS,EAAE,EAAE;QACjC,MAAM,WAAW,GAAG,MAAM,SAAS,OAAO,CAAC;QAC3C,yCAAyC;QACzC,MAAM,CAAC,SAAS,CAAC,WAAW,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,IAAI,CAAC,CAAC;IACvE,CAAC,CAAC,CAAC;AACP,CAAC","sourcesContent":["import type { Effect } from \"./effect\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Geometry } from \"../Meshes/geometry\";\r\n\r\n/**\r\n * Interface representing metadata for vertex pulling\r\n */\r\nexport interface IVertexPullingMetadata {\r\n    /**\r\n     * Offset in vertex buffer where data starts\r\n     */\r\n    offset: number;\r\n\r\n    /**\r\n     * Stride between elements in the vertex buffer\r\n     */\r\n    stride: number;\r\n\r\n    /**\r\n     * Type of the vertex buffer (e.g., float, int)\r\n     */\r\n    type: number; // VertexBuffer type constant\r\n}\r\n\r\n// Store vertex pulling metadata per geometry\r\nconst _VertexPullingMetadataCache = new WeakMap<Geometry, Map<string, IVertexPullingMetadata>>();\r\n\r\n/**\r\n * Prepares vertex pulling uniforms for the given attributes and mesh\r\n * @param geometry The geometry containing the vertex buffers\r\n * @returns A map of attribute names to their metadata, or null if unavailable\r\n */\r\nexport function PrepareVertexPullingUniforms(geometry: Geometry): Nullable<Map<string, IVertexPullingMetadata>> {\r\n    const vertexBuffers = geometry.getVertexBuffers();\r\n    if (!vertexBuffers) {\r\n        return null;\r\n    }\r\n\r\n    // Check cache first\r\n    let metadata = _VertexPullingMetadataCache.get(geometry);\r\n    if (!metadata) {\r\n        metadata = new Map<string, IVertexPullingMetadata>();\r\n        _VertexPullingMetadataCache.set(geometry, metadata);\r\n    } else {\r\n        // Return cached metadata if it exists and hasn't changed\r\n        let needsUpdate = false;\r\n        for (const vb in vertexBuffers) {\r\n            if (!metadata.has(vb)) {\r\n                needsUpdate = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!needsUpdate) {\r\n            return metadata;\r\n        }\r\n    }\r\n\r\n    // Build or update metadata\r\n    for (const vb in vertexBuffers) {\r\n        const vertexBuffer = vertexBuffers[vb];\r\n        if (vertexBuffer) {\r\n            const offset = vertexBuffer.byteOffset;\r\n            const stride = vertexBuffer.byteStride;\r\n            const type = vertexBuffer.type;\r\n\r\n            metadata.set(vb, {\r\n                offset: offset,\r\n                stride: stride,\r\n                type: type,\r\n            });\r\n        }\r\n    }\r\n\r\n    return metadata;\r\n}\r\n\r\n/**\r\n * Bind vertex pulling uniforms to the effect\r\n * @param effect The effect to bind the uniforms to\r\n * @param metadata The vertex pulling metadata\r\n */\r\nexport function BindVertexPullingUniforms(effect: Effect, metadata: Map<string, IVertexPullingMetadata>): void {\r\n    metadata.forEach((data, attribute) => {\r\n        const uniformName = `vp_${attribute}_info`;\r\n        // Pack into vec3: (offset, stride, type)\r\n        effect.setFloat3(uniformName, data.offset, data.stride, data.type);\r\n    });\r\n}\r\n"]}