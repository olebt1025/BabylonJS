{"version":3,"file":"textureMerger.js","sourceRoot":"","sources":["../../../../../dev/core/src/Materials/Textures/textureMerger.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Scene } from \"../../scene\";\nimport type { IProceduralTextureCreationOptions } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\nimport { ProceduralTexture } from \"./Procedurals/proceduralTexture\";\nimport type { BaseTexture } from \"./baseTexture\";\nimport type { TextureSize } from \"./textureCreationOptions\";\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\nimport { Constants } from \"../../Engines/constants\";\nimport type { Texture } from \"./texture\";\n\n/**\n * Configuration for a texture input source\n */\nexport interface ITextureChannelInput {\n    /** The texture to use as input */\n    texture: BaseTexture;\n    /** Source channel to read from (0=R, 1=G, 2=B, 3=A) */\n    sourceChannel: number;\n}\n\n/**\n * Configuration for a constant value input source\n */\nexport interface IConstantChannelInput {\n    /** Constant value between 0.0 and 1.0 */\n    value: number;\n}\n\n/**\n * Union type for channel input sources\n */\nexport type ChannelInput = ITextureChannelInput | IConstantChannelInput;\n\n/**\n * Configuration for texture merging operation\n */\nexport interface ITextureMergeConfiguration {\n    /** Configuration for red output channel */\n    red: ChannelInput;\n    /** Configuration for green output channel (optional, defaults to 0) */\n    green?: ChannelInput;\n    /** Configuration for blue output channel (optional, defaults to 0) */\n    blue?: ChannelInput;\n    /** Configuration for alpha output channel (optional, defaults to 1) */\n    alpha?: ChannelInput;\n    /** Output texture size. If not specified, uses the largest input texture size */\n    outputSize?: TextureSize;\n    /** Whether to generate mipmaps for the output texture */\n    generateMipMaps?: boolean;\n}\n\nconst _ShaderName = \"textureMerger\";\n\n/**\n * @internal\n * Check if a channel input is a texture input\n * @param input The channel input to check\n * @returns True if the input is a texture input, false otherwise\n */\nfunction IsTextureInput(input: ChannelInput): input is ITextureChannelInput {\n    return \"texture\" in input;\n}\n\n/**\n * @internal\n * Check if a channel input is a constant input\n * @param input The channel input to check\n * @returns True if the input is a constant input, false otherwise\n */\nfunction IsConstantInput(input: ChannelInput): input is IConstantChannelInput {\n    return \"value\" in input;\n}\n\n/**\n * @internal\n * Copy texture transformation properties from one texture to another\n * @param source The source texture\n * @param destination The destination texture\n */\nfunction CopyTextureTransform(source: Texture, destination: Texture) {\n    destination.uOffset = source.uOffset;\n    destination.vOffset = source.vOffset;\n    destination.uScale = source.uScale;\n    destination.vScale = source.vScale;\n    destination.uAng = source.uAng;\n    destination.vAng = source.vAng;\n    destination.wAng = source.wAng;\n    destination.uRotationCenter = source.uRotationCenter;\n    destination.vRotationCenter = source.vRotationCenter;\n}\n\n/**\n * @internal\n * Merge multiple texture channels into a single texture\n * @param name Name for the resulting texture\n * @param config Merge configuration\n * @param scene Scene to create the texture in\n * @returns The merged texture\n */\nexport async function MergeTexturesAsync(name: string, config: ITextureMergeConfiguration, scene: Scene): Promise<ProceduralTexture> {\n    const channels = [config.red, config.green, config.blue, config.alpha];\n    const textureInputs: BaseTexture[] = [];\n    const textureInputMap: number[] = []; // Maps channel index to texture input index (-1 for constants)\n\n    // Collect unique textures and validate inputs\n    for (let channelIndex = 0; channelIndex < 4; channelIndex++) {\n        const channel = channels[channelIndex];\n        if (channel) {\n            if (IsTextureInput(channel)) {\n                // Validate source channel\n                if (channel.sourceChannel < 0 || channel.sourceChannel > 3) {\n                    throw new Error(\"Source channel must be between 0 and 3 (R, G, B, A)\");\n                }\n\n                // Find or add texture to inputs\n                let textureIndex = textureInputs.indexOf(channel.texture);\n                if (textureIndex === -1) {\n                    textureIndex = textureInputs.length;\n                    textureInputs.push(channel.texture);\n                }\n                textureInputMap[channelIndex] = textureIndex;\n            } else if (IsConstantInput(channel)) {\n                // Validate constant value\n                if (channel.value < 0 || channel.value > 1) {\n                    throw new Error(\"Constant value must be between 0.0 and 1.0\");\n                }\n                textureInputMap[channelIndex] = -1;\n            } else {\n                throw new Error(\"Invalid channel input configuration\");\n            }\n        } else {\n            textureInputMap[channelIndex] = -1;\n        }\n    }\n\n    // Determine output size\n    let outputSize = config.outputSize;\n    if (!outputSize && textureInputs.length > 0) {\n        // Use the largest texture size\n        let maxSize = 0;\n        for (const texture of textureInputs) {\n            const size = texture.getSize();\n            const currentSize = Math.max(size.width, size.height);\n            if (currentSize > maxSize) {\n                maxSize = currentSize;\n                outputSize = size.width === size.height ? maxSize : size;\n            }\n        }\n    }\n    outputSize = outputSize || 512; // Fallback size\n\n    // Generate shader defines\n    const defines: string[] = [];\n    const usedTextures = new Set<number>();\n\n    for (let channelIndex = 0; channelIndex < 4; channelIndex++) {\n        const channel = channels[channelIndex];\n        const channelName = [\"RED\", \"GREEN\", \"BLUE\", \"ALPHA\"][channelIndex];\n\n        if (channel && IsTextureInput(channel)) {\n            defines.push(`${channelName}_FROM_TEXTURE`);\n            const textureIndex = textureInputMap[channelIndex];\n            usedTextures.add(textureIndex);\n        }\n    }\n\n    // Add texture defines for used textures\n    usedTextures.forEach((textureIndex) => {\n        defines.push(`USE_TEXTURE${textureIndex}`);\n    });\n\n    // Create the procedural texture\n    const outputTextureOptions: IProceduralTextureCreationOptions = {\n        type: Constants.TEXTURETYPE_HALF_FLOAT,\n        format: Constants.TEXTUREFORMAT_RGBA,\n        samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n        generateDepthBuffer: false,\n        generateMipMaps: false,\n        shaderLanguage: scene.getEngine().isWebGPU ? ShaderLanguage.WGSL : ShaderLanguage.GLSL,\n        extraInitializationsAsync: async () => {\n            if (scene.getEngine().isWebGPU) {\n                await Promise.all([import(\"../../ShadersWGSL/textureMerger.fragment\")]);\n            } else {\n                await Promise.all([import(\"../../Shaders/textureMerger.fragment\")]);\n            }\n        },\n    };\n    const proceduralTexture = new ProceduralTexture(name, outputSize, _ShaderName, scene, outputTextureOptions);\n    proceduralTexture.refreshRate = -1; // Do not auto-refresh\n\n    // Set the defines\n    proceduralTexture.defines = defines.length > 0 ? \"#define \" + defines.join(\"\\n#define \") + \"\\n\" : \"\";\n\n    // Set up texture inputs\n    for (let i = 0; i < textureInputs.length; i++) {\n        CopyTextureTransform(textureInputs[i] as Texture, proceduralTexture);\n        proceduralTexture.setTexture(`inputTexture${i}`, textureInputs[i]);\n    }\n\n    // Set up channel configuration\n    for (let channelIndex = 0; channelIndex < 4; channelIndex++) {\n        const channel = channels[channelIndex];\n        const channelName = [\"red\", \"green\", \"blue\", \"alpha\"][channelIndex];\n\n        if (channel && IsTextureInput(channel)) {\n            const textureIndex = textureInputMap[channelIndex];\n            proceduralTexture.setInt(`${channelName}TextureIndex`, textureIndex);\n            proceduralTexture.setInt(`${channelName}SourceChannel`, channel.sourceChannel);\n        } else {\n            // Use constant value (either provided or default)\n            let constantValue: number;\n            if (channel && IsConstantInput(channel)) {\n                constantValue = channel.value;\n            } else {\n                // Use default values: 0 for RGB, 1 for alpha\n                constantValue = channelIndex === 3 ? 1.0 : 0.0;\n            }\n            proceduralTexture.setFloat(`${channelName}ConstantValue`, constantValue);\n        }\n    }\n\n    return await new Promise<ProceduralTexture>((resolve, reject) => {\n        // Compile and render\n        proceduralTexture.executeWhenReady(() => {\n            try {\n                proceduralTexture.render();\n                resolve(proceduralTexture);\n            } catch (error) {\n                reject(error instanceof Error ? error : new Error(String(error)));\n            }\n        });\n    });\n}\n\n/**\n * @internal\n * Create a texture input configuration\n * @param texture The texture to read from\n * @param sourceChannel The channel to read (0=R, 1=G, 2=B, 3=A)\n * @returns Texture channel input configuration\n */\nexport function CreateTextureInput(texture: BaseTexture, sourceChannel: number): ITextureChannelInput {\n    return { texture, sourceChannel };\n}\n\n/**\n * @internal\n * Create a constant value input configuration\n * @param value The constant value (0.0-1.0)\n * @returns Constant channel input configuration\n */\nexport function CreateConstantInput(value: number): IConstantChannelInput {\n    return { value };\n}\n\n/**\n * @internal\n * Create a simple RGBA channel packing configuration\n * @param red Input for red channel\n * @param green Input for green channel (optional, defaults to 0)\n * @param blue Input for blue channel (optional, defaults to 0)\n * @param alpha Input for alpha channel (optional, defaults to 1)\n * @returns Texture merge configuration\n */\nexport function CreateRGBAConfiguration(red: ChannelInput, green?: ChannelInput, blue?: ChannelInput, alpha?: ChannelInput): ITextureMergeConfiguration {\n    return { red, green, blue, alpha };\n}\n"]}