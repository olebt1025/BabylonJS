{"version":3,"file":"areaLightsTextureTools.js","sourceRoot":"","sources":["../../../../dev/core/src/Misc/areaLightsTextureTools.ts"],"names":[],"mappings":"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","sourcesContent":["import type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport type { InternalTexture } from \"core/Materials/Textures/internalTexture\";\r\nimport { EffectRenderer, EffectWrapper } from \"core/Materials/effectRenderer\";\r\nimport type { ThinTexture } from \"core/Materials/Textures/thinTexture\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { ShaderLanguage } from \"core/Materials/shaderLanguage\";\r\nimport { Vector2 } from \"core/Maths/math.vector\";\r\nimport { WhenTextureReadyAsync } from \"core/Misc/textureTools\";\r\nimport { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Constants } from \"core/Engines/constants\";\r\n\r\ntype KernelData = {\r\n    kernel: Float32Array;\r\n    kernelSize: number;\r\n    kernelHalfSize: number;\r\n};\r\n\r\n/**\r\n * Class used for fast copy from one texture to another\r\n */\r\nexport class AreaLightTextureTools {\r\n    private _engine: AbstractEngine;\r\n    private _renderer: EffectRenderer;\r\n    private _effectWrapper: EffectWrapper;\r\n    private _source: BaseTexture;\r\n    private _scalingRange: Vector2;\r\n    private _kernelLibrary: KernelData[] = [];\r\n    private readonly _blurSize = 5;\r\n    private readonly _alphaFactor = 0.5;\r\n\r\n    /** Shader language used */\r\n    protected _shaderLanguage = ShaderLanguage.GLSL;\r\n\r\n    /**\r\n     * Gets the shader language\r\n     */\r\n    public get shaderLanguage(): ShaderLanguage {\r\n        return this._shaderLanguage;\r\n    }\r\n\r\n    private _textureIsInternal(texture: InternalTexture | ThinTexture): texture is InternalTexture {\r\n        return (texture as ThinTexture)?.getInternalTexture === undefined;\r\n    }\r\n\r\n    /**\r\n     * Constructs a new instance of the class\r\n     * @param engine The engine to use for the copy\r\n     */\r\n    constructor(engine: AbstractEngine) {\r\n        this._engine = engine;\r\n        this._renderer = new EffectRenderer(this._engine);\r\n        this._scalingRange = new Vector2();\r\n\r\n        for (let i = 0; i < 512; i++) {\r\n            const kernelSize = this._blurSize + (i + 1) * 2;\r\n            const alpha = (kernelSize / 2.0) * this._alphaFactor;\r\n            this._kernelLibrary.push(this._generateGaussianKernel(kernelSize, alpha));\r\n        }\r\n    }\r\n\r\n    private _shadersLoaded = false;\r\n    private _createEffect(): EffectWrapper {\r\n        const engine = this._engine;\r\n        let isWebGPU = false;\r\n\r\n        if (engine?.isWebGPU) {\r\n            this._shaderLanguage = ShaderLanguage.WGSL;\r\n            isWebGPU = true;\r\n        }\r\n\r\n        const effectWrapper = new EffectWrapper({\r\n            engine: engine,\r\n            name: \"AreaLightTextureProcessing\",\r\n            fragmentShader: \"areaLightTextureProcessing\",\r\n            useShaderStore: true,\r\n            uniformNames: [\"scalingRange\"],\r\n            samplerNames: [\"textureSampler\"],\r\n            defines: [],\r\n            shaderLanguage: this._shaderLanguage,\r\n            extraInitializationsAsync: async () => {\r\n                if (isWebGPU) {\r\n                    await import(\"../ShadersWGSL/areaLightTextureProcessing.fragment\");\r\n                } else {\r\n                    await import(\"../Shaders/areaLightTextureProcessing.fragment\");\r\n                }\r\n            },\r\n        });\r\n\r\n        effectWrapper.onApplyObservable.add(() => {\r\n            engine.depthCullingState.depthMask = false;\r\n            if (this._textureIsInternal(this._source)) {\r\n                effectWrapper.effect._bindTexture(\"textureSampler\", this._source);\r\n            } else {\r\n                effectWrapper.effect.setTexture(\"textureSampler\", this._source);\r\n            }\r\n            effectWrapper.effect.setVector2(\"scalingRange\", this._scalingRange);\r\n        });\r\n\r\n        return effectWrapper;\r\n    }\r\n\r\n    /**\r\n     * Indicates if the effect is ready to be used for the copy\r\n     * @returns true if \"copy\" can be called without delay, else false\r\n     */\r\n    public isReady(): boolean {\r\n        return this._shadersLoaded && !!this._effectWrapper?.effect?.isReady();\r\n    }\r\n\r\n    /**\r\n     * Pre-processes the texture to be used with RectAreaLight emissionTexture.\r\n     * @param source The texture to pre-process\r\n     * @returns A promise that resolves with the pre-processed texture\r\n     */\r\n    public async processAsync(source: BaseTexture): Promise<Nullable<BaseTexture>> {\r\n        if (!this._shadersLoaded) {\r\n            this._effectWrapper = this._createEffect();\r\n            await this._effectWrapper.effect.whenCompiledAsync();\r\n            this._shadersLoaded = true;\r\n        }\r\n\r\n        if (!source.isReady()) {\r\n            await WhenTextureReadyAsync(source);\r\n        }\r\n\r\n        this._scalingRange.x = 0.125;\r\n        this._scalingRange.y = 0.875;\r\n\r\n        this._source = source;\r\n        const oldWrapU = this._source.wrapU;\r\n        const oldWrapV = this._source.wrapV;\r\n\r\n        this._source.wrapU = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n        this._source.wrapV = Constants.TEXTURE_MIRROR_ADDRESSMODE;\r\n\r\n        const result = await this._scaleImageDownAsync(source);\r\n        await this._applyProgressiveBlurAsync(result);\r\n\r\n        result.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n        result.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\r\n\r\n        this._source.wrapU = oldWrapU;\r\n        this._source.wrapV = oldWrapV;\r\n\r\n        return result;\r\n    }\r\n\r\n    private async _scaleImageDownAsync(source: BaseTexture): Promise<BaseTexture> {\r\n        const renderTarget = this._engine.createRenderTargetTexture(\r\n            { width: 1024, height: 1024 },\r\n            {\r\n                generateDepthBuffer: false,\r\n                generateMipMaps: true,\r\n                generateStencilBuffer: false,\r\n                samplingMode: Constants.TEXTURE_TRILINEAR_SAMPLINGMODE,\r\n                type: Constants.TEXTURE_2D,\r\n                format: Constants.TEXTUREFORMAT_RGBA,\r\n            }\r\n        );\r\n\r\n        this._source = source;\r\n        const engineDepthMask = this._engine.getDepthWrite(); // for some reasons, depthWrite is not restored by EffectRenderer.restoreStates\r\n        this._renderer.render(this._effectWrapper, renderTarget);\r\n        this._engine.setDepthWrite(engineDepthMask);\r\n        return new BaseTexture(this._engine, renderTarget.texture);\r\n    }\r\n\r\n    private _generateGaussianKernel(size: number, sigma: number): KernelData {\r\n        if (size % 2 === 0) {\r\n            throw new Error(\"Kernel size must be odd.\");\r\n        }\r\n\r\n        const kernel = new Float32Array(size);\r\n        let sum = 0.0;\r\n        const halfSize = Math.floor(size / 2);\r\n\r\n        for (let i = -halfSize; i <= halfSize; ++i) {\r\n            const value = Math.exp(-(i * i) / (2.0 * sigma * sigma));\r\n            const index = i + halfSize;\r\n            kernel[index] = value;\r\n            sum += value;\r\n        }\r\n\r\n        for (let i = 0; i < kernel.length; i++) {\r\n            kernel[i] /= sum;\r\n        }\r\n\r\n        return { kernel, kernelSize: size, kernelHalfSize: halfSize };\r\n    }\r\n\r\n    private _mirrorIndex(x: number, width: number): number {\r\n        if (x < 0) {\r\n            x = -x;\r\n        }\r\n        if (x >= width) {\r\n            x = 2 * width - 2 - x;\r\n        }\r\n        return x;\r\n    }\r\n\r\n    private _applyGaussianBlurRange(input: Uint8Array, output: Uint8Array, width: number, height: number, channels: number, kernelLibrary: KernelData[]) {\r\n        const marginStart = Math.floor(width * 0.125);\r\n        const marginEnd = Math.floor(width * 0.875);\r\n\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                let targetKernel = 0;\r\n\r\n                if (x <= marginStart) {\r\n                    targetKernel = Math.max(targetKernel, Math.abs(x - marginStart));\r\n                }\r\n                if (y <= marginStart) {\r\n                    targetKernel = Math.max(targetKernel, Math.abs(y - marginStart));\r\n                }\r\n                if (x >= marginEnd) {\r\n                    targetKernel = Math.max(targetKernel, Math.abs(x - marginEnd));\r\n                }\r\n                if (y >= marginEnd) {\r\n                    targetKernel = Math.max(targetKernel, Math.abs(y - marginEnd));\r\n                }\r\n\r\n                const kernelData = kernelLibrary[targetKernel];\r\n                const { kernel, kernelHalfSize } = kernelData;\r\n\r\n                for (let c = 0; c < channels - 1; c++) {\r\n                    let sum = 0.0;\r\n                    for (let kx = -kernelHalfSize; kx <= kernelHalfSize; kx++) {\r\n                        const px = this._mirrorIndex(x + kx, width);\r\n                        const weight = kernel[kx + kernelHalfSize];\r\n                        const pixelData = input[(y * width + px) * channels + c];\r\n                        sum += pixelData * weight;\r\n                    }\r\n                    output[(y * width + x) * channels + c] = Math.max(0, Math.min(255, Math.round(sum)));\r\n                }\r\n                // copy alpha if present\r\n                if (channels > 3) {\r\n                    output[(y * width + x) * channels + (channels - 1)] = input[(y * width + x) * channels + (channels - 1)];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _transposeImage(input: Uint8Array, width: number, height: number, channels: number, output: Uint8Array): void {\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0; x < width; x++) {\r\n                const srcBase = (y * width + x) * channels;\r\n                const dstBase = (x * height + y) * channels;\r\n                for (let c = 0; c < channels; c++) {\r\n                    output[dstBase + c] = input[srcBase + c];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private async _applyProgressiveBlurAsync(source: BaseTexture): Promise<void> {\r\n        const pixelData = await source.readPixels();\r\n\r\n        if (!pixelData) {\r\n            return;\r\n        }\r\n\r\n        const internalTexture = source.getInternalTexture();\r\n\r\n        if (!internalTexture) {\r\n            return;\r\n        }\r\n\r\n        const rourcePixel = new Uint8Array(pixelData.buffer);\r\n        const result = new Uint8Array(rourcePixel.length);\r\n\r\n        this._applyGaussianBlurRange(rourcePixel, result, internalTexture.width, internalTexture.height, 4, this._kernelLibrary);\r\n        this._transposeImage(result, internalTexture.width, internalTexture.height, 4, rourcePixel);\r\n        this._applyGaussianBlurRange(rourcePixel, result, internalTexture.width, internalTexture.height, 4, this._kernelLibrary);\r\n        this._transposeImage(result, internalTexture.width, internalTexture.height, 4, rourcePixel);\r\n        this._engine.updateRawTexture(internalTexture, rourcePixel, internalTexture.format, false);\r\n    }\r\n\r\n    /**\r\n     * Releases all the resources used by the class\r\n     */\r\n    public dispose(): void {\r\n        this._effectWrapper?.dispose();\r\n        this._renderer.dispose();\r\n    }\r\n}\r\n"]}