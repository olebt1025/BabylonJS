import { Vector3, Quaternion, TmpVectors, Matrix } from "../Maths/math.vector.js";
import { Logger } from "../Misc/logger.js";
/**
 * Represents an animator avatar that manages skeletons and morph target managers for a hierarchical transform node and mesh structure.
 * This class is used to group and manage animation-related resources (skeletons and morph targets) associated with a root transform node and its descendants.
 */
export class AnimatorAvatar {
    /**
     * Map of morph target names to their corresponding MorphTarget instances.
     * The keys are constructed using the format "meshName_morphTargetName".
     */
    get mapMorphTargetNameToMorphTarget() {
        if (!this._mapMorphTargetNameToMorphTarget) {
            this._buildMorphTargetMap();
        }
        return this._mapMorphTargetNameToMorphTarget;
    }
    /**
     * Creates an instance of AnimatorAvatar.
     * @param name - The name to assign to this avatar and its root node
     * @param rootNode - The root node of the avatar hierarchy. This node and its descendants will be scanned for skeletons and morph target managers. If not provided, you are expected to manually manage skeletons and morph target managers.
     * @param _disposeResources - Indicates whether to dispose of resources (skeletons, morph target managers, root node and descendants + materials and textures) when the avatar is disposed (true by default)
     */
    constructor(name, rootNode, _disposeResources = true) {
        this.name = name;
        this.rootNode = rootNode;
        this._disposeResources = _disposeResources;
        /**
         * Indicates whether to show warnings during retargeting operations.
         */
        this.showWarnings = true;
        this.skeletons = new Set();
        this.morphTargetManagers = new Set();
        if (!rootNode) {
            return;
        }
        rootNode.name = name;
        if (!rootNode.rotationQuaternion) {
            rootNode.rotationQuaternion = new Quaternion();
        }
        rootNode
            .getChildMeshes(false, (node) => {
            const mesh = node;
            return mesh.getTotalVertices && mesh.getTotalVertices() > 0;
        })
            .forEach((mesh) => {
            if (mesh.skeleton) {
                this.skeletons.add(mesh.skeleton);
            }
            if (mesh.morphTargetManager) {
                mesh.morphTargetManager.meshName = mesh.name;
                mesh.morphTargetManager.numMaxInfluencers = mesh.morphTargetManager.numTargets;
                this.morphTargetManagers.add(mesh.morphTargetManager);
            }
        });
        this._computeBoneWorldMatrices();
    }
    /**
     * Finds a bone in the avatar's skeletons by its linked transform node or the name of the linked transform node.
     * @param nameOrTransformNode The linked transform node or the name of the linked transform node
     * @returns The found bone or null if not found
     */
    findBone(nameOrTransformNode) {
        const isName = !this._isTransformNode(nameOrTransformNode);
        const iterator = this.skeletons.keys();
        let bone = null;
        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
            const skeleton = key.value;
            if (isName) {
                bone = skeleton.findBoneFromLinkedTransformNodeName(nameOrTransformNode);
            }
            else {
                bone = skeleton.findBoneFromLinkedTransformNode(nameOrTransformNode);
            }
            if (bone) {
                return bone;
            }
        }
        return null;
    }
    /**
     * Make sures that the animation group passed as the first parameter will animate the bones in the skeleton(s) / the morphs in the morph target manager(s) of the avatar.
     * Retargeting is based on the names of the targets (TransformNode or MorphTarget) in the animation and the names of the bones in the skeleton / morph targets in the morph target manager.
     * Note that you can use the mapNodeNames option to specify a mapping between source transform node names and target bone names in case they are different.
     * If no bones with the same name as a target (TransformNode) of a targeted animation are found, the targeted animation is removed from the animation group.
     * Same for morph targets.
     * Note that for the time being, we only support a source animation group which animates transform nodes, not bones!
     * That's typically the case when the source animation group is created from a glTF file, as glTF animations always target transform nodes.
     * @param sourceAnimationGroup The animation group to retarget
     * @param options Options for retargeting the animation group (optional)
     * @returns The retargeted (new) animation group
     */
    retargetAnimationGroup(sourceAnimationGroup, options) {
        const localOptions = {
            animationGroupName: sourceAnimationGroup.name,
            fixAnimations: true,
            checkHierarchy: true,
            retargetAnimationKeys: true,
            fixGroundReference: true,
            fixRootPosition: true,
            ...options,
        };
        // Make sure that all world matrices are up to date, both in the bone hierarchy and in the animation transform node hierarchy
        this._computeBoneWorldMatrices();
        const mapNodeNames = localOptions.mapNodeNames ?? new Map();
        const lstTransformNodes = new Set();
        const sourceTransformNodeNameToNode = new Map();
        for (let i = 0; i < sourceAnimationGroup.targetedAnimations.length; ++i) {
            const ta = sourceAnimationGroup.targetedAnimations[i];
            if (ta.target.getClassName?.() === "TransformNode" && !lstTransformNodes.has(ta.target)) {
                const tn = ta.target;
                lstTransformNodes.add(tn);
                if (!tn.rotationQuaternion) {
                    tn.rotationQuaternion = Quaternion.FromEulerAngles(tn.rotation.x, tn.rotation.y, tn.rotation.z);
                    tn.rotation.setAll(0);
                }
                sourceTransformNodeNameToNode.set(mapNodeNames.get(tn.name) ?? tn.name, {
                    node: tn,
                    initialTransformations: {
                        position: tn.position.clone(),
                        scaling: tn.scaling.clone(),
                        quaternion: tn.rotationQuaternion.clone(),
                    },
                });
            }
        }
        lstTransformNodes.forEach((node) => {
            node.computeWorldMatrix(true);
        });
        // Clone the source animation and retarget it
        const animationGroup = sourceAnimationGroup.clone(localOptions.animationGroupName, undefined, true, true);
        const mapTransformNodeToRootNode = new Map();
        const lstAnims = new Set();
        for (let i = 0; i < animationGroup.targetedAnimations.length; ++i) {
            const ta = animationGroup.targetedAnimations[i];
            const animation = ta.animation;
            if (lstAnims.has(animation)) {
                if (this.showWarnings) {
                    Logger.Warn(`RetargetAnimationGroup - Avatar '${this.name}', AnimationGroup '${animationGroup.name}': animation '${animation.name}' is used multiple times in the same animation group: duplicated animations are not supported, the retargeted animation may not work as expected.`);
                }
            }
            lstAnims.add(animation);
            switch (animation.targetProperty) {
                case "influence": {
                    if (!this._retargetMorphTarget(ta, animationGroup.name)) {
                        animationGroup.targetedAnimations.splice(i, 1);
                        i--;
                    }
                    break;
                }
                case "position":
                case "rotationQuaternion":
                case "scaling": {
                    if (ta.target.getClassName?.() !== "TransformNode") {
                        break;
                    }
                    const sourceTransformNode = ta.target;
                    const sourceTransformNodeName = mapNodeNames.get(sourceTransformNode.name) ?? sourceTransformNode.name;
                    const targetBone = this.findBone(sourceTransformNodeName);
                    if (!targetBone) {
                        if (this.showWarnings) {
                            Logger.Warn(`RetargetAnimationGroup - Avatar '${this.name}', AnimationGroup '${animationGroup.name}': "${sourceTransformNodeName}" bone not found in any skeleton of avatar: animation removed.`);
                            animationGroup.targetedAnimations.splice(i, 1);
                            i--;
                        }
                        break;
                    }
                    if (!targetBone._linkedTransformNode) {
                        if (this.showWarnings) {
                            Logger.Warn(`RetargetAnimationGroup - Avatar '${this.name}', AnimationGroup '${animationGroup.name}': bone "${targetBone.name}" has no linked transform node: skipping retargeting.`);
                        }
                        break;
                    }
                    if (!this._retargetTransformNodeToBone(ta, sourceTransformNode, targetBone, animationGroup.name, mapTransformNodeToRootNode, mapNodeNames, !!localOptions.checkHierarchy)) {
                        animationGroup.targetedAnimations.splice(i, 1);
                        i--;
                    }
                    else if (localOptions.retargetAnimationKeys) {
                        this._retargetAnimationKeys(ta.animation, sourceTransformNode, targetBone);
                    }
                    break;
                }
            }
        }
        if (localOptions.fixAnimations) {
            this._fixAnimationGroup(animationGroup);
        }
        if (localOptions.fixGroundReference || localOptions.fixRootPosition) {
            const msg = localOptions.fixGroundReference && localOptions.fixRootPosition
                ? "Ground reference and root position fixing processes skipped."
                : localOptions.fixGroundReference
                    ? "Ground reference fixing process skipped."
                    : "Root position fixing process skipped.";
            const res = this._findVerticalAxis(msg, animationGroup, mapNodeNames.get(localOptions.rootNodeName) ?? localOptions.rootNodeName, sourceTransformNodeNameToNode, mapNodeNames.get(localOptions.groundReferenceNodeName) ?? localOptions.groundReferenceNodeName, localOptions.groundReferenceVerticalAxis);
            if (res) {
                const { verticalAxis, sourceRootTransformNode, targetRootTransformNode, targetRootPositionAnimation, sourceGroundReferenceTransformNode, targetGroundReferenceTransformNode, proportionRatio, } = res;
                if (localOptions.fixRootPosition) {
                    this._fixRootPosition(sourceAnimationGroup, animationGroup, sourceRootTransformNode, targetRootTransformNode, targetRootPositionAnimation, proportionRatio);
                    this._resetStates(sourceTransformNodeNameToNode);
                }
                if (localOptions.fixGroundReference) {
                    this._fixGroundReference(sourceAnimationGroup, animationGroup, verticalAxis, targetRootTransformNode, targetRootPositionAnimation, sourceGroundReferenceTransformNode, targetGroundReferenceTransformNode);
                    this._resetStates(sourceTransformNodeNameToNode);
                }
            }
        }
        return animationGroup;
    }
    /**
     * Disposes of the avatar and releases all associated resources.
     * This will dispose all skeletons, morph target managers, and the root mesh with its descendants (including materials and textures).
     * If disposeResources was set to false in the constructor, this method does nothing.
     */
    dispose() {
        if (!this._disposeResources) {
            return;
        }
        const iterator = this.skeletons.keys();
        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
            key.value.dispose();
        }
        const iterator2 = this.morphTargetManagers.keys();
        for (let key = iterator2.next(); key.done !== true; key = iterator2.next()) {
            key.value.dispose();
        }
        this.rootNode?.dispose(false, true);
    }
    _computeBoneWorldMatrices() {
        this.skeletons.forEach((skeleton) => {
            skeleton.bones.forEach((bone) => {
                bone._linkedTransformNode?.computeWorldMatrix(true);
            });
        });
    }
    _isTransformNode(nameOrTransformNode) {
        return typeof nameOrTransformNode !== "string";
    }
    _buildMorphTargetMap() {
        this._mapMorphTargetNameToMorphTarget = new Map();
        this.morphTargetManagers.forEach((manager) => {
            const numTargets = manager.numTargets;
            for (let t = 0; t < numTargets; ++t) {
                const target = manager.getTarget(t);
                const key = manager.meshName + "_" + target.name;
                this._mapMorphTargetNameToMorphTarget.set(key, target);
            }
        });
    }
    _retargetMorphTarget(ta, animationGroupName) {
        const morphTarget = ta.target;
        const key = morphTarget.morphTargetManager?.meshName + "_" + morphTarget.name;
        if (!this.mapMorphTargetNameToMorphTarget.has(key)) {
            if (this.showWarnings) {
                Logger.Warn(`RetargetAnimationGroup - Avatar '${this.name}', AnimationGroup '${animationGroupName}': "${morphTarget.name}" morph target not found in morph target manager of mesh "${morphTarget.morphTargetManager?.meshName}": animation removed`);
            }
            return false;
        }
        ta.target = this.mapMorphTargetNameToMorphTarget.get(key);
        return true;
    }
    _retargetTransformNodeToBone(ta, sourceTransformNode, targetBone, animationGroupName, mapTransformNodeToRootNode, mapNodeNames, checkHierarchy) {
        if (checkHierarchy) {
            let rootNode = mapTransformNodeToRootNode.get(sourceTransformNode);
            if (!rootNode) {
                rootNode = this._getRootNode(sourceTransformNode);
                mapTransformNodeToRootNode.set(sourceTransformNode, rootNode);
            }
            if (!this._checkParentHierarchy(targetBone, rootNode, mapNodeNames)) {
                if (this.showWarnings) {
                    Logger.Warn(`RetargetAnimationGroup - Avatar '${this.name}', AnimationGroup '${animationGroupName}': parent hierarchy mismatch between bone "${targetBone.name}" and transform node "${sourceTransformNode.name}": animation removed`);
                }
                return false;
            }
        }
        ta.target = targetBone._linkedTransformNode;
        return true;
    }
    _retargetAnimationKeys(animation, sourceTransformNode, targetBone) {
        const keys = animation.getKeys();
        const targetTransformNode = targetBone._linkedTransformNode;
        const targetWorldMatrix = targetTransformNode.getWorldMatrix();
        const targetParentWorldMatrix = targetTransformNode.parent ? targetTransformNode.parent.getWorldMatrix() : Matrix.IdentityReadOnly;
        const targetParentInverseWorldMatrix = targetParentWorldMatrix.invertToRef(TmpVectors.Matrix[0]);
        const sourceInverseWorld = sourceTransformNode.getWorldMatrix().invertToRef(TmpVectors.Matrix[1]);
        const sourceParentWorld = sourceTransformNode.parent ? sourceTransformNode.parent.getWorldMatrix() : Matrix.IdentityReadOnly;
        switch (animation.targetProperty) {
            case "rotationQuaternion": {
                for (const key of keys) {
                    const quaternion = key.value;
                    const localMat = Matrix.ComposeToRef(sourceTransformNode.scaling, quaternion, sourceTransformNode.position, TmpVectors.Matrix[2]);
                    sourceInverseWorld.multiplyToRef(localMat, localMat).multiplyToRef(sourceParentWorld, localMat);
                    targetWorldMatrix.multiplyToRef(localMat, localMat).multiplyToRef(targetParentInverseWorldMatrix, localMat).decompose(undefined, quaternion, undefined);
                }
                break;
            }
            case "position": {
                for (const key of keys) {
                    const position = key.value;
                    const localMat = Matrix.ComposeToRef(sourceTransformNode.scaling, sourceTransformNode.rotationQuaternion, position, TmpVectors.Matrix[2]);
                    sourceInverseWorld.multiplyToRef(localMat, localMat).multiplyToRef(sourceParentWorld, localMat);
                    targetWorldMatrix.multiplyToRef(localMat, localMat).multiplyToRef(targetParentInverseWorldMatrix, localMat).decompose(undefined, undefined, position);
                }
                break;
            }
            case "scaling": {
                for (const key of keys) {
                    const scaling = key.value;
                    const localMat = Matrix.ComposeToRef(scaling, sourceTransformNode.rotationQuaternion, sourceTransformNode.position, TmpVectors.Matrix[2]);
                    sourceInverseWorld.multiplyToRef(localMat, localMat).multiplyToRef(sourceParentWorld, localMat);
                    targetWorldMatrix.multiplyToRef(localMat, localMat).multiplyToRef(targetParentInverseWorldMatrix, localMat).decompose(scaling, undefined, undefined);
                }
                break;
            }
        }
    }
    /**
     * This method does two things:
     *   - It deletes a targeted animation if a bone corresponding to the target cannot be found
     *   - It corrects quaternion animations when two consecutive quaternions are orthogonal to each other. When this happens, in 99.99% of cases it's an error
     *     in the animation data, as two consecutive rotations should normally be close to each other and not have a large gap.
     *     The fix is to copy the first quaternion into the second.
     * @param animationGroup The animation group to fix
     * @internal
     */
    _fixAnimationGroup(animationGroup) {
        for (let i = 0; i < animationGroup.targetedAnimations.length; ++i) {
            const ta = animationGroup.targetedAnimations[i];
            switch (ta.animation.targetProperty) {
                case "position":
                case "rotationQuaternion":
                case "scaling": {
                    if (ta.target.getClassName() !== "TransformNode") {
                        break;
                    }
                    const transformNode = ta.target;
                    const bone = this.findBone(transformNode);
                    if (!bone) {
                        if (this.showWarnings) {
                            Logger.Warn(`FixAnimationGroup - Avatar '${this.name}', AnimationGroup '${animationGroup.name}': no bone in any skeleton of the avatar ${this.name} animates the transform node ${transformNode.name}: animation removed`);
                        }
                        animationGroup.targetedAnimations.splice(i, 1);
                        i--;
                        continue;
                    }
                    ta.target = bone._linkedTransformNode;
                    if (ta.animation.targetProperty === "rotationQuaternion") {
                        this._fixAnimationQuaternion(ta.animation);
                    }
                }
            }
        }
    }
    _fixAnimationQuaternion(animation, epsilon = 0.001) {
        const keys = animation.getKeys();
        for (let i = 0; i < keys.length - 1; ++i) {
            const curQuat = keys[i].value;
            const nextQuat = keys[i + 1].value;
            if (Math.abs(Quaternion.Dot(curQuat, nextQuat)) < epsilon) {
                keys[i + 1].value = curQuat.clone();
                i += 1;
            }
        }
    }
    _getRootNode(node) {
        let current = node;
        while (current.parent) {
            current = current.parent;
        }
        return current;
    }
    /**
     * Checks whether the parent hierarchy of a bone matches that of a given transform node. Checks are performed by name.
     * It works by first finding the transform node in the descendants of the root transform node that matches the bone's linked transform node.
     * Then it traverses up the hierarchy of both the bone and the transform node, comparing their names at each level.
     * @param bone The bone to check
     * @param rootTransformNode The root transform node to check against
     * @returns True if the hierarchies match, false otherwise
     * @internal
     */
    _checkParentHierarchy(bone, rootTransformNode, mapNodeNames) {
        const children = rootTransformNode.getDescendants(false, (node) => (mapNodeNames.get(node.name) ?? node.name) === bone._linkedTransformNode.name);
        if (!children || children.length !== 1) {
            if (this.showWarnings) {
                Logger.Warn(`RetargetAnimationGroup - Avatar '${this.name}', CheckParentHierarchy: unable to find a corresponding transform node to bone name ${bone._linkedTransformNode.name} in the source animation.`);
            }
            return false;
        }
        let transformNode = children[0];
        while (bone) {
            const name = mapNodeNames.get(transformNode?.name ?? "") ?? transformNode?.name;
            if (bone._linkedTransformNode.name !== name) {
                if (this.showWarnings) {
                    Logger.Warn(`RetargetAnimationGroup - Avatar '${this.name}', CheckParentHierarchy: bone name ${bone._linkedTransformNode.name} is different from transform node name ${name}.`);
                }
                return false;
            }
            bone = bone.parent;
            transformNode = transformNode.parent;
        }
        return true;
    }
    _getRootNodeName(rootNodeName, transformNodeNameToNode) {
        if (rootNodeName) {
            return rootNodeName;
        }
        // Look for the first bone that doesn't have a parent
        const iterator = this.skeletons.keys();
        for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
            const skeleton = key.value;
            for (const bone of skeleton.bones) {
                if (!bone.parent) {
                    // Make sure there's a transform node with that name in the source animation
                    if (transformNodeNameToNode.get(bone.name)) {
                        return bone.name;
                    }
                }
            }
        }
        return;
    }
    _findVerticalAxis(msg, animationGroup, remappedRootNodeName, sourceTransformNodeNameToNode, remappedGroundReferenceNodeName, groundReferenceVerticalAxis) {
        if (!remappedGroundReferenceNodeName) {
            if (this.showWarnings) {
                Logger.Warn(`RetargetAnimationGroup - Avatar '${this.name}', AnimationGroup '${animationGroup.name}': you must provide the name of the ground reference node (option parameter "groundReferenceNodeName"). ${msg}`);
            }
            return null;
        }
        remappedRootNodeName = this._getRootNodeName(remappedRootNodeName, sourceTransformNodeNameToNode);
        if (!remappedRootNodeName) {
            if (this.showWarnings) {
                Logger.Warn(`RetargetAnimationGroup - Avatar '${this.name}', AnimationGroup '${animationGroup.name}': unable to find a suitable root node in the source animation. You should provide its name through the "rootNodeName" optional parameter. ${msg}`);
            }
            return null;
        }
        const sourceRootTransformNode = sourceTransformNodeNameToNode.get(remappedRootNodeName)?.node;
        const sourceGroundReferenceTransformNode = sourceTransformNodeNameToNode.get(remappedGroundReferenceNodeName)?.node;
        if (!sourceRootTransformNode) {
            if (this.showWarnings) {
                Logger.Warn(`RetargetAnimationGroup - Avatar '${this.name}', AnimationGroup '${animationGroup.name}': unable to find the transform node corresponding to "${remappedRootNodeName}" in the source animation. This transform node either doesn't exist or is not animated. ${msg}`);
            }
            return null;
        }
        if (!sourceGroundReferenceTransformNode) {
            if (this.showWarnings) {
                Logger.Warn(`RetargetAnimationGroup - Avatar '${this.name}', AnimationGroup '${animationGroup.name}': unable to find the transform node corresponding to "${remappedGroundReferenceNodeName}" in the source animation. This transform node either doesn't exist or is not animated. ${msg}`);
            }
            return null;
        }
        // Look for the position animation + target node of the root node name (generally the hips) in the retargeted animation
        let targetRootPositionAnimation;
        let targetRootTransformNode;
        for (let i = 0; i < animationGroup.targetedAnimations.length; ++i) {
            const ta = animationGroup.targetedAnimations[i];
            const target = ta.target;
            const animation = ta.animation;
            if (target.name === remappedRootNodeName && animation.targetProperty === "position") {
                targetRootPositionAnimation = animation;
                targetRootTransformNode = ta.target;
                break;
            }
        }
        if (!targetRootPositionAnimation || !targetRootTransformNode) {
            if (this.showWarnings) {
                Logger.Warn(`RetargetAnimationGroup - Avatar '${this.name}', AnimationGroup '${animationGroup.name}': unable to find a "position" animation for the node "${remappedRootNodeName}". ${msg}`);
            }
            return null;
        }
        const targetGroundReferenceTransformNode = this.findBone(remappedGroundReferenceNodeName)?._linkedTransformNode;
        if (!targetGroundReferenceTransformNode) {
            if (this.showWarnings) {
                Logger.Warn(`RetargetAnimationGroup - Avatar '${this.name}', AnimationGroup '${animationGroup.name}': unable to find the transform node corresponding to the bone "${remappedGroundReferenceNodeName}" in the avatar skeleton. Ensure that this bone exists and is linked to a transform node. ${msg}`);
            }
            return null;
        }
        sourceRootTransformNode.computeWorldMatrix(true);
        sourceGroundReferenceTransformNode.computeWorldMatrix(true);
        // Determine the vertical axis
        const sourceRootGroundReferenceDiff = sourceRootTransformNode.getAbsolutePosition().subtract(sourceGroundReferenceTransformNode.getAbsolutePosition());
        let verticalAxis = 0;
        if (groundReferenceVerticalAxis) {
            switch (groundReferenceVerticalAxis) {
                case "Y":
                    verticalAxis = 1;
                    break;
                case "Z":
                    verticalAxis = 2;
                    break;
            }
        }
        else {
            // No axis provided: assume the vertical axis is the one with the larger difference between the reference and the ground reference transform nodes
            if (Math.abs(sourceRootGroundReferenceDiff.y) > Math.abs(sourceRootGroundReferenceDiff.x)) {
                verticalAxis = 1;
            }
            if (Math.abs(sourceRootGroundReferenceDiff.z) > Math.abs(sourceRootGroundReferenceDiff.y)) {
                verticalAxis = 2;
            }
        }
        const targetRootGroundReferenceDiff = targetRootTransformNode.getAbsolutePosition().subtract(targetGroundReferenceTransformNode.getAbsolutePosition());
        return {
            verticalAxis,
            sourceRootTransformNode,
            sourceGroundReferenceTransformNode,
            targetRootTransformNode,
            targetRootPositionAnimation,
            targetGroundReferenceTransformNode,
            proportionRatio: verticalAxis === 0
                ? targetRootGroundReferenceDiff.x / sourceRootGroundReferenceDiff.x
                : verticalAxis === 1
                    ? targetRootGroundReferenceDiff.y / sourceRootGroundReferenceDiff.y
                    : targetRootGroundReferenceDiff.z / sourceRootGroundReferenceDiff.z,
        };
    }
    _resetStates(sourceTransformNodeNameToNode) {
        this.skeletons.forEach((skeleton) => skeleton.returnToRest());
        sourceTransformNodeNameToNode.forEach((data) => {
            const { node, initialTransformations } = data;
            node.position = initialTransformations.position;
            node.scaling = initialTransformations.scaling;
            node.rotationQuaternion = initialTransformations.quaternion;
            node.computeWorldMatrix(true);
        });
    }
    _fixRootPosition(sourceAnimationGroup, animationGroup, sourceRootTransformNode, targetRootTransformNode, targetRootPositionAnimation, proportionRatio) {
        const targetNodeInverseParentWorldMatrix = targetRootTransformNode.parent?.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]) ?? Matrix.IdentityReadOnly;
        sourceRootTransformNode.computeWorldMatrix(true);
        targetRootTransformNode.computeWorldMatrix(true);
        const sourceWorldPosition = sourceRootTransformNode.absolutePosition.clone();
        const targetWorldPosition = targetRootTransformNode.absolutePosition.clone();
        sourceAnimationGroup.play(false);
        animationGroup.play(false);
        // Loop over the position animation of the root transform node
        for (const key of targetRootPositionAnimation.getKeys()) {
            const frame = key.frame;
            // Advance the source and retargeted animations to this frame
            sourceAnimationGroup.goToFrame(frame);
            sourceAnimationGroup.pause();
            animationGroup.goToFrame(frame);
            animationGroup.pause();
            sourceRootTransformNode.computeWorldMatrix(true);
            const offset = sourceRootTransformNode.absolutePosition.subtractToRef(sourceWorldPosition, TmpVectors.Vector3[0]);
            offset.scaleInPlace(proportionRatio);
            offset.addInPlace(targetWorldPosition);
            Vector3.TransformNormalToRef(offset, targetNodeInverseParentWorldMatrix, key.value);
        }
        sourceAnimationGroup.stop();
        animationGroup.stop();
    }
    _fixGroundReference(sourceAnimationGroup, animationGroup, verticalAxis, targetRootTransformNode, targetRootPositionAnimation, sourceGroundReferenceTransformNode, targetGroundReferenceTransformNode) {
        const targetNodeInverseParentWorldMatrix = targetRootTransformNode.parent?.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]) ?? Matrix.IdentityReadOnly;
        sourceAnimationGroup.play(false);
        animationGroup.play(false);
        // Loop over the position animation of the root transform node
        for (const key of targetRootPositionAnimation.getKeys()) {
            const frame = key.frame;
            // Advance the source and retargeted animations to this frame
            sourceAnimationGroup.goToFrame(frame);
            sourceAnimationGroup.pause();
            animationGroup.goToFrame(frame);
            animationGroup.pause();
            sourceGroundReferenceTransformNode.computeWorldMatrix(true);
            targetGroundReferenceTransformNode.computeWorldMatrix(true);
            // Calculate the offset to apply to the root position in the target to have the ground reference at the same height in the source and target animations
            const diffGroundReferences = targetGroundReferenceTransformNode.absolutePosition.subtractToRef(sourceGroundReferenceTransformNode.absolutePosition, TmpVectors.Vector3[0]);
            const offset = verticalAxis === 0 ? diffGroundReferences.x : verticalAxis === 1 ? diffGroundReferences.y : diffGroundReferences.z;
            const localOffset = Vector3.TransformNormalToRef(new Vector3(verticalAxis === 0 ? offset : 0, verticalAxis === 1 ? offset : 0, verticalAxis === 2 ? offset : 0), targetNodeInverseParentWorldMatrix, TmpVectors.Vector3[1]);
            key.value.subtractInPlace(localOffset);
        }
        sourceAnimationGroup.stop();
        animationGroup.stop();
    }
}
//# sourceMappingURL=animatorAvatar.js.map