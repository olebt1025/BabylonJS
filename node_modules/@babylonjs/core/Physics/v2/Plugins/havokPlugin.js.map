{"version":3,"file":"havokPlugin.js","sourceRoot":"","sources":["../../../../../../dev/core/src/Physics/v2/Plugins/havokPlugin.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-unsafe-return */\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport { Matrix, Quaternion, TmpVectors, Vector3 } from \"../../../Maths/math.vector\";\r\nimport {\r\n    PhysicsShapeType,\r\n    PhysicsConstraintType,\r\n    PhysicsMotionType,\r\n    PhysicsConstraintMotorType,\r\n    PhysicsConstraintAxis,\r\n    PhysicsConstraintAxisLimitMode,\r\n    PhysicsEventType,\r\n    PhysicsPrestepType,\r\n    PhysicsActivationControl,\r\n} from \"../IPhysicsEnginePlugin\";\r\nimport type {\r\n    PhysicsShapeParameters,\r\n    IPhysicsEnginePluginV2,\r\n    PhysicsMassProperties,\r\n    IPhysicsCollisionEvent,\r\n    IBasePhysicsCollisionEvent,\r\n    ConstrainedBodyPair,\r\n} from \"../IPhysicsEnginePlugin\";\r\nimport type { IRaycastQuery } from \"../../physicsRaycastResult\";\r\nimport { PhysicsRaycastResult } from \"../../physicsRaycastResult\";\r\nimport { Logger } from \"../../../Misc/logger\";\r\nimport type { PhysicsBody } from \"../physicsBody\";\r\nimport type { PhysicsConstraint, Physics6DoFConstraint } from \"../physicsConstraint\";\r\nimport type { PhysicsMaterial } from \"../physicsMaterial\";\r\nimport { PhysicsMaterialCombineMode } from \"../physicsMaterial\";\r\nimport { PhysicsShape } from \"../physicsShape\";\r\nimport { BoundingBox } from \"../../../Culling/boundingBox\";\r\nimport type { TransformNode } from \"../../../Meshes/transformNode\";\r\nimport { Mesh } from \"../../../Meshes/mesh\";\r\nimport { InstancedMesh } from \"../../../Meshes/instancedMesh\";\r\nimport type { Scene } from \"../../../scene\";\r\nimport { VertexBuffer } from \"../../../Buffers/buffer\";\r\nimport { BuildArray } from \"../../../Misc/arrayTools\";\r\nimport { Observable } from \"../../../Misc/observable\";\r\nimport type { Nullable, FloatArray } from \"../../../types\";\r\nimport type { IPhysicsPointProximityQuery } from \"../../physicsPointProximityQuery\";\r\nimport type { ProximityCastResult } from \"../../proximityCastResult\";\r\nimport type { IPhysicsShapeProximityCastQuery } from \"../../physicsShapeProximityCastQuery\";\r\nimport type { IPhysicsShapeCastQuery } from \"../../physicsShapeCastQuery\";\r\nimport type { ShapeCastResult } from \"../../shapeCastResult\";\r\nimport { FloatingOriginCurrentScene } from \"../../../Materials/floatingOriginMatrixOverrides\";\r\ndeclare let HK: any;\r\n\r\n/**\r\n * Helper to keep a reference to plugin memory.\r\n * Used to avoid https://github.com/emscripten-core/emscripten/issues/7294\r\n * @internal\r\n */\r\ninterface PluginMemoryRef {\r\n    /** The offset from the beginning of the plugin's heap */\r\n    offset: number;\r\n    /** The number of identically-sized objects the buffer contains */\r\n    numObjects: number;\r\n}\r\n\r\nclass MeshAccumulator {\r\n    /**\r\n     * Constructor of the mesh accumulator\r\n     * @param mesh - The mesh used to compute the world matrix.\r\n     * @param collectIndices - use mesh indices\r\n     * @param scene - The scene used to determine the right handed system.\r\n     *\r\n     * Merge mesh and its children so whole hierarchy can be used as a mesh shape or convex hull\r\n     */\r\n    public constructor(mesh: Mesh, collectIndices: boolean, scene: Scene) {\r\n        this._isRightHanded = scene.useRightHandedSystem;\r\n        this._collectIndices = collectIndices;\r\n    }\r\n\r\n    /**\r\n     * Adds a mesh to the physics engine.\r\n     * @param mesh The mesh to add.\r\n     * @param includeChildren Whether to include the children of the mesh.\r\n     *\r\n     * This method adds a mesh to the physics engine by computing the world matrix,\r\n     * multiplying it with the body from world matrix, and then transforming the\r\n     * coordinates of the mesh's vertices. It also adds the indices of the mesh\r\n     * to the physics engine. If includeChildren is true, it will also add the\r\n     * children of the mesh to the physics engine, ignoring any children which\r\n     * have a physics impostor. This is useful for creating a physics engine\r\n     * that accurately reflects the mesh and its children.\r\n     */\r\n    public addNodeMeshes(mesh: TransformNode, includeChildren: boolean): void {\r\n        // Force absoluteScaling to be computed; we're going to use that to bake\r\n        // the scale of any parent nodes into this shape, as physics engines\r\n        // usually use rigid transforms, so can't handle arbitrary scale.\r\n        mesh.computeWorldMatrix(true);\r\n        const rootScaled = TmpVectors.Matrix[0];\r\n        Matrix.ScalingToRef(mesh.absoluteScaling.x, mesh.absoluteScaling.y, mesh.absoluteScaling.z, rootScaled);\r\n\r\n        if (mesh instanceof Mesh) {\r\n            this._addMesh(mesh, rootScaled);\r\n        } else if (mesh instanceof InstancedMesh) {\r\n            this._addMesh(mesh.sourceMesh, rootScaled);\r\n        }\r\n\r\n        if (includeChildren) {\r\n            const worldToRoot = TmpVectors.Matrix[1];\r\n            mesh.computeWorldMatrix().invertToRef(worldToRoot);\r\n            const worldToRootScaled = TmpVectors.Matrix[2];\r\n            worldToRoot.multiplyToRef(rootScaled, worldToRootScaled);\r\n\r\n            const children = mesh.getChildMeshes(false);\r\n            //  Ignore any children which have a physics body.\r\n            //  Other plugin implementations do not have this check, which appears to be\r\n            //  a bug, as otherwise, the mesh will have a duplicate collider\r\n            const transformNodes = children.filter((m: any) => !m.physicsBody);\r\n\r\n            for (const m of transformNodes) {\r\n                const childToWorld = m.computeWorldMatrix();\r\n                const childToRootScaled = TmpVectors.Matrix[3];\r\n                childToWorld.multiplyToRef(worldToRootScaled, childToRootScaled);\r\n\r\n                if (m instanceof Mesh) {\r\n                    this._addMesh(m, childToRootScaled);\r\n                } else if (m instanceof InstancedMesh) {\r\n                    this._addMesh(m.sourceMesh, childToRootScaled);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addMesh(mesh: Mesh, meshToRoot: Matrix): void {\r\n        const vertexData = mesh.getVerticesData(VertexBuffer.PositionKind) || [];\r\n        const numVerts = vertexData.length / 3;\r\n        const indexOffset = this._vertices.length;\r\n        for (let v = 0; v < numVerts; v++) {\r\n            const pos = new Vector3(vertexData[v * 3 + 0], vertexData[v * 3 + 1], vertexData[v * 3 + 2]);\r\n            this._vertices.push(Vector3.TransformCoordinates(pos, meshToRoot));\r\n        }\r\n\r\n        if (this._collectIndices) {\r\n            const meshIndices = mesh.getIndices();\r\n            if (meshIndices) {\r\n                for (let i = 0; i < meshIndices.length; i += 3) {\r\n                    // Havok wants the correct triangle winding to enable the interior triangle optimization\r\n                    if (this._isRightHanded) {\r\n                        this._indices.push(meshIndices[i + 0] + indexOffset);\r\n                        this._indices.push(meshIndices[i + 1] + indexOffset);\r\n                        this._indices.push(meshIndices[i + 2] + indexOffset);\r\n                    } else {\r\n                        this._indices.push(meshIndices[i + 2] + indexOffset);\r\n                        this._indices.push(meshIndices[i + 1] + indexOffset);\r\n                        this._indices.push(meshIndices[i + 0] + indexOffset);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allocate and populate the vertex positions inside the physics plugin.\r\n     *\r\n     * @param plugin - The plugin to allocate the memory in.\r\n     * @returns An array of floats, whose backing memory is inside the plugin. The array contains the\r\n     * positions of the mesh vertices, where a position is defined by three floats. You must call\r\n     * freeBuffer() on the returned array once you have finished with it, in order to free the\r\n     * memory inside the plugin..\r\n     */\r\n    public getVertices(plugin: any): PluginMemoryRef {\r\n        const nFloats = this._vertices.length * 3;\r\n        const bytesPerFloat = 4;\r\n        const nBytes = nFloats * bytesPerFloat;\r\n        const bufferBegin = plugin._malloc(nBytes);\r\n\r\n        const ret = new Float32Array(plugin.HEAPU8.buffer, bufferBegin, nFloats);\r\n        for (let i = 0; i < this._vertices.length; i++) {\r\n            ret[i * 3 + 0] = this._vertices[i].x;\r\n            ret[i * 3 + 1] = this._vertices[i].y;\r\n            ret[i * 3 + 2] = this._vertices[i].z;\r\n        }\r\n\r\n        return { offset: bufferBegin, numObjects: nFloats };\r\n    }\r\n\r\n    public freeBuffer(plugin: any, arr: PluginMemoryRef) {\r\n        plugin._free(arr.offset);\r\n    }\r\n\r\n    /**\r\n     * Allocate and populate the triangle indices inside the physics plugin\r\n     *\r\n     * @param plugin - The plugin to allocate the memory in.\r\n     * @returns A new Int32Array, whose backing memory is inside the plugin. The array contains the indices\r\n     * of the triangle positions, where a single triangle is defined by three indices. You must call\r\n     * freeBuffer() on this array once you have finished with it, to free the memory inside the plugin..\r\n     */\r\n    public getTriangles(plugin: any): PluginMemoryRef {\r\n        const bytesPerInt = 4;\r\n        const nBytes = this._indices.length * bytesPerInt;\r\n        const bufferBegin = plugin._malloc(nBytes);\r\n        const ret = new Int32Array(plugin.HEAPU8.buffer, bufferBegin, this._indices.length);\r\n        for (let i = 0; i < this._indices.length; i++) {\r\n            ret[i] = this._indices[i];\r\n        }\r\n\r\n        return { offset: bufferBegin, numObjects: this._indices.length };\r\n    }\r\n\r\n    private _isRightHanded: boolean;\r\n    private _collectIndices: boolean;\r\n    private _vertices: Vector3[] = []; /// Vertices in body space\r\n    private _indices: number[] = [];\r\n}\r\n\r\nclass BodyPluginData {\r\n    public constructor(bodyId: any) {\r\n        this.hpBodyId = bodyId;\r\n        this.userMassProps = { centerOfMass: undefined, mass: undefined, inertia: undefined, inertiaOrientation: undefined };\r\n    }\r\n\r\n    public hpBodyId: any;\r\n\r\n    public worldTransformOffset: number;\r\n\r\n    public userMassProps: PhysicsMassProperties;\r\n\r\n    /**\r\n     * Reference to the world region this body belongs to.\r\n     * Used for floating origin mode to ensure consistent coordinate transformation.\r\n     * Will be undefined for non-floating-origin worlds (uses the default world).\r\n     */\r\n    public worldRegion?: PhysicsWorldRegion;\r\n}\r\n\r\n/*\r\nclass ShapePath\r\n{\r\n    public colliderId: number;\r\n    public pathData: number;\r\n}\r\n*/\r\n\r\nclass CollisionContactPoint {\r\n    public bodyId: bigint = BigInt(0); //0,2\r\n    //public colliderId: number = 0; //2,4\r\n    //public shapePath: ShapePath = new ShapePath(); //4,8\r\n    public position: Vector3 = new Vector3(); //8,11\r\n    public normal: Vector3 = new Vector3(); //11,14\r\n    //public triIdx: number = 0; //14,15\r\n}\r\n\r\nclass CollisionEvent {\r\n    public contactOnA: CollisionContactPoint = new CollisionContactPoint(); //1\r\n    public contactOnB: CollisionContactPoint = new CollisionContactPoint();\r\n    public impulseApplied: number = 0;\r\n    public type: number = 0;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    static readToRef(buffer: any, offset: number, eventOut: CollisionEvent) {\r\n        const intBuf = new Int32Array(buffer, offset);\r\n        const floatBuf = new Float32Array(buffer, offset);\r\n        const offA = 2;\r\n        eventOut.contactOnA.bodyId = BigInt(intBuf[offA]); //<todo Need to get the high+low words!\r\n        eventOut.contactOnA.position.set(floatBuf[offA + 8], floatBuf[offA + 9], floatBuf[offA + 10]);\r\n        eventOut.contactOnA.normal.set(floatBuf[offA + 11], floatBuf[offA + 12], floatBuf[offA + 13]);\r\n        const offB = 18;\r\n        eventOut.contactOnB.bodyId = BigInt(intBuf[offB]);\r\n        eventOut.contactOnB.position.set(floatBuf[offB + 8], floatBuf[offB + 9], floatBuf[offB + 10]);\r\n        eventOut.contactOnB.normal.set(floatBuf[offB + 11], floatBuf[offB + 12], floatBuf[offB + 13]);\r\n        eventOut.impulseApplied = floatBuf[offB + 13 + 3];\r\n        eventOut.type = intBuf[0];\r\n    }\r\n}\r\n\r\nclass TriggerEvent {\r\n    public bodyIdA: bigint = BigInt(0);\r\n    public bodyIdB: bigint = BigInt(0);\r\n    public type: number = 0;\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    static readToRef(buffer: any, offset: number, eventOut: TriggerEvent) {\r\n        const intBuf = new Int32Array(buffer, offset);\r\n        eventOut.type = intBuf[0];\r\n        eventOut.bodyIdA = BigInt(intBuf[2]);\r\n        eventOut.bodyIdB = BigInt(intBuf[6]);\r\n    }\r\n}\r\n\r\nexport interface HavokPluginParameters {\r\n    /**\r\n     * Maximum number of raycast hits to process\r\n     */\r\n    maxQueryCollectorHits?: number;\r\n    /**\r\n     * Radius of each floating origin world region.\r\n     * Bodies within this radius of a world region's origin will use that world.\r\n     * Bodies created outside existing regions will create a new region.\r\n     * Default is 100000 units.\r\n     */\r\n    floatingOriginWorldRadius?: number;\r\n}\r\n\r\n/**\r\n * Represents a physics world region with a fixed floating origin.\r\n * Bodies within a certain radius of this origin are simulated in this world.\r\n * @internal\r\n */\r\ninterface PhysicsWorldRegion {\r\n    /** The Havok world handle */\r\n    world: any;\r\n    /** The fixed floating origin for this world region (in world coordinates) */\r\n    floatingOrigin: Vector3;\r\n    /** The gravity for this world region (can be different per region for planetary scenarios) */\r\n    gravity: number[];\r\n}\r\n\r\n/**\r\n * The Havok Physics plugin\r\n */\r\nexport class HavokPlugin implements IPhysicsEnginePluginV2 {\r\n    /**\r\n     * Reference to the WASM library\r\n     */\r\n    public _hknp: any = {};\r\n    /**\r\n     * Created Havok world which physics bodies are added to (default world for non-floating-origin)\r\n     */\r\n    public world: any;\r\n    /**\r\n     * Name of the plugin\r\n     */\r\n    public name: string = \"HavokPlugin\";\r\n    /**\r\n     * We only have a single raycast in-flight right now\r\n     */\r\n    private _queryCollector;\r\n    private _multiQueryCollector: any = undefined;\r\n    private _fixedTimeStep: number = 1 / 60;\r\n    private _maxQueryCollectorHits: number = 1;\r\n    private _tmpVec3 = BuildArray(3, Vector3.Zero);\r\n    private _bodies = new Map<bigint, { body: PhysicsBody; index: number }>();\r\n    private _shapes = new Map<bigint, PhysicsShape>();\r\n    private _bodyCollisionObservable = new Map<bigint, Observable<IPhysicsCollisionEvent>>();\r\n    // Map from constraint id to the pair of bodies, where the first is the parent and the second is the child\r\n    private _constraintToBodyIdPair = new Map<bigint, [bigint, bigint]>();\r\n    private _bodyCollisionEndedObservable = new Map<bigint, Observable<IBasePhysicsCollisionEvent>>();\r\n    /**\r\n     * Array of world regions. The first region is always the default world with origin at Vector3.Zero.\r\n     * Additional regions are created as needed for floating origin mode.\r\n     */\r\n    private _worldRegions: PhysicsWorldRegion[] = [];\r\n    /**\r\n     * Stored gravity value to apply to new world regions.\r\n     */\r\n    private _currentGravity: number[] = [0, -9.81, 0];\r\n    /**\r\n     * Radius of each floating origin world region.\r\n     * Bodies within this radius of a world region's origin will use that world.\r\n     */\r\n    private _floatingOriginWorldRadius: number = 100000;\r\n\r\n    /**\r\n     * Finds an existing world region that contains the given world position,\r\n     * or creates a new world region centered at that position.\r\n     *\r\n     * When floatingOriginMode is enabled, we use multiple Havok worlds to maintain\r\n     * float32 precision across a large world. Each world region has its own fixed\r\n     * floating origin, and bodies within that region are simulated relative to it.\r\n     *\r\n     * @param worldPosition - The world position of the body being created\r\n     * @returns The world region to use for this body\r\n     */\r\n    private _getOrCreateWorldRegion(worldPosition: Vector3): PhysicsWorldRegion {\r\n        // Check if floating origin mode is enabled\r\n        const scene = FloatingOriginCurrentScene.getScene();\r\n        if (!scene?.floatingOriginMode) {\r\n            // When floating origin mode is disabled, use the default world region\r\n            return this._worldRegions[0];\r\n        }\r\n\r\n        // Find an existing region that contains this position\r\n        for (const region of this._worldRegions) {\r\n            const distance = Vector3.Distance(worldPosition, region.floatingOrigin);\r\n            if (distance <= this._floatingOriginWorldRadius) {\r\n                return region;\r\n            }\r\n        }\r\n\r\n        // No existing region found - create a new one centered at this position\r\n        const newWorld = this._hknp.HP_World_Create()[1];\r\n\r\n        // Apply stored gravity to new world\r\n        this._hknp.HP_World_SetGravity(newWorld, this._currentGravity);\r\n\r\n        // Copy velocity limits from main world\r\n        this._hknp.HP_World_SetSpeedLimit(newWorld, this.getMaxLinearVelocity(), this.getMaxAngularVelocity());\r\n\r\n        const newRegion: PhysicsWorldRegion = {\r\n            world: newWorld,\r\n            floatingOrigin: worldPosition.clone(),\r\n            gravity: [...this._currentGravity],\r\n        };\r\n\r\n        this._worldRegions.push(newRegion);\r\n        return newRegion;\r\n    }\r\n\r\n    /**\r\n     * Checks if a body's world position has left its current region and, if so,\r\n     * moves it to the correct region (existing or newly created).\r\n     * This preserves linear and angular velocity across the transition.\r\n     *\r\n     * @param pluginData - The plugin data for the body (or instance) to check\r\n     */\r\n    private _reRegionBodyPluginData(pluginData: BodyPluginData): void {\r\n        const currentRegion = pluginData.worldRegion;\r\n        if (!currentRegion) {\r\n            return;\r\n        }\r\n\r\n        // Read the body's current local transform from Havok\r\n        const bodyTransform = this._hknp.HP_Body_GetQTransform(pluginData.hpBodyId)[1];\r\n        const localPos = bodyTransform[0];\r\n        const orientation = bodyTransform[1];\r\n\r\n        // Compute world position = local position + floating origin\r\n        const worldPos = TmpVectors.Vector3[2];\r\n        worldPos.set(localPos[0] + currentRegion.floatingOrigin._x, localPos[1] + currentRegion.floatingOrigin._y, localPos[2] + currentRegion.floatingOrigin._z);\r\n\r\n        // Check if still within the current region.\r\n        // Use a 20% hysteresis margin so that bodies near the boundary\r\n        // don't oscillate between regions every frame.\r\n        const distToCurrent = Vector3.Distance(worldPos, currentRegion.floatingOrigin);\r\n        if (distToCurrent <= this._floatingOriginWorldRadius * 1.2) {\r\n            return; // still in region (with hysteresis), nothing to do\r\n        }\r\n\r\n        // Body has left its region. Use velocity to look ahead and find the best\r\n        // region to join. This prevents creating throwaway intermediate regions\r\n        // when a fast body is heading toward an existing region (e.g. a target).\r\n        const linVel = this._hknp.HP_Body_GetLinearVelocity(pluginData.hpBodyId)[1];\r\n        const angVel = this._hknp.HP_Body_GetAngularVelocity(pluginData.hpBodyId)[1];\r\n\r\n        // Project position forward by one second of travel to find a suitable existing region.\r\n        // This is purely for region selection  the body's actual position is not changed.\r\n        const lookAheadPos = TmpVectors.Vector3[3];\r\n        lookAheadPos.set(worldPos._x + linVel[0], worldPos._y + linVel[1], worldPos._z + linVel[2]);\r\n\r\n        // Try to find the best region: first check if look-ahead position falls in an existing region\r\n        let newRegion = this._findExistingRegion(lookAheadPos);\r\n        if (!newRegion || newRegion === currentRegion) {\r\n            // Fall back to current position\r\n            newRegion = this._findExistingRegion(worldPos);\r\n        }\r\n        if (!newRegion || newRegion === currentRegion) {\r\n            // No existing region works  create one at the current position\r\n            newRegion = this._getOrCreateWorldRegion(worldPos);\r\n        }\r\n        if (newRegion === currentRegion) {\r\n            return;\r\n        }\r\n\r\n        // Remove from old world\r\n        this._hknp.HP_World_RemoveBody(currentRegion.world, pluginData.hpBodyId);\r\n\r\n        // Set transform relative to the new region's floating origin\r\n        const newOffset = newRegion.floatingOrigin;\r\n        const newLocalPos = [worldPos._x - newOffset._x, worldPos._y - newOffset._y, worldPos._z - newOffset._z];\r\n        this._hknp.HP_Body_SetQTransform(pluginData.hpBodyId, [newLocalPos, orientation]);\r\n\r\n        // Add to new world\r\n        this._hknp.HP_World_AddBody(newRegion.world, pluginData.hpBodyId, false);\r\n\r\n        // Restore velocity\r\n        this._hknp.HP_Body_SetLinearVelocity(pluginData.hpBodyId, linVel);\r\n        this._hknp.HP_Body_SetAngularVelocity(pluginData.hpBodyId, angVel);\r\n\r\n        // Update the region reference and world transform offset\r\n        pluginData.worldRegion = newRegion;\r\n        pluginData.worldTransformOffset = this._hknp.HP_Body_GetWorldTransformOffset(pluginData.hpBodyId)[1];\r\n\r\n        // Garbage-collect the old region if it has no bodies left and it's not the default world\r\n        if (currentRegion !== this._worldRegions[0]) {\r\n            const bodyCount = this._hknp.HP_World_GetNumBodies(currentRegion.world)[1];\r\n            if (bodyCount === 0) {\r\n                this._hknp.HP_World_Release(currentRegion.world);\r\n                const idx = this._worldRegions.indexOf(currentRegion);\r\n                if (idx > 0) {\r\n                    this._worldRegions.splice(idx, 1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Searches existing world regions for one that contains the given position.\r\n     * @param worldPosition - The world position to find a region for\r\n     * @returns null if no existing region contains it (does NOT create a new one).\r\n     */\r\n    private _findExistingRegion(worldPosition: Vector3): PhysicsWorldRegion | null {\r\n        const scene = FloatingOriginCurrentScene.getScene();\r\n        if (!scene?.floatingOriginMode) {\r\n            return this._worldRegions[0];\r\n        }\r\n\r\n        for (const region of this._worldRegions) {\r\n            const distance = Vector3.Distance(worldPosition, region.floatingOrigin);\r\n            if (distance <= this._floatingOriginWorldRadius) {\r\n                return region;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Observable for collision started and collision continued events\r\n     */\r\n    public onCollisionObservable = new Observable<IPhysicsCollisionEvent>();\r\n    /**\r\n     * Observable for collision ended events\r\n     */\r\n    public onCollisionEndedObservable = new Observable<IBasePhysicsCollisionEvent>();\r\n    /**\r\n     * Observable for trigger entered and trigger exited events\r\n     */\r\n    public onTriggerCollisionObservable = new Observable<IBasePhysicsCollisionEvent>();\r\n\r\n    public constructor(\r\n        private _useDeltaForWorldStep: boolean = true,\r\n        hpInjection: any = HK,\r\n        parameters: HavokPluginParameters = {}\r\n    ) {\r\n        if (typeof hpInjection === \"function\") {\r\n            Logger.Error(\"Havok is not ready. Please make sure you await HK() before using the plugin.\");\r\n            return;\r\n        } else {\r\n            this._hknp = hpInjection;\r\n        }\r\n\r\n        if (!this.isSupported()) {\r\n            Logger.Error(\"Havok is not available. Please make sure you included the js file.\");\r\n            return;\r\n        }\r\n        this.world = this._hknp.HP_World_Create()[1];\r\n\r\n        // Add the default world as the first region with origin at zero\r\n        this._worldRegions.push({\r\n            world: this.world,\r\n            floatingOrigin: Vector3.Zero(),\r\n            gravity: [...this._currentGravity],\r\n        });\r\n\r\n        this._queryCollector = this._hknp.HP_QueryCollector_Create(1)[1];\r\n        this.setMaxQueryCollectorHits(parameters.maxQueryCollectorHits ?? 1);\r\n        this._floatingOriginWorldRadius = parameters.floatingOriginWorldRadius ?? 100000;\r\n    }\r\n    /**\r\n     * If this plugin is supported\r\n     * @returns true if its supported\r\n     */\r\n    public isSupported(): boolean {\r\n        return this._hknp !== undefined;\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity of the physics world.\r\n     *\r\n     * @param gravity - The gravity vector to set.\r\n     * @param worldPosition - Optional world position to specify which region's gravity to set.\r\n     *                        If provided, only the region containing this position will be updated.\r\n     *                        If not provided, all regions will be updated (default behavior).\r\n     *                        This is useful for planetary scenarios where gravity direction varies by location.\r\n     */\r\n    public setGravity(gravity: Vector3, worldPosition?: Vector3): void {\r\n        const gravityArray = this._bVecToV3(gravity);\r\n\r\n        if (worldPosition) {\r\n            // Set gravity for a specific region based on world position\r\n            const region = this._getOrCreateWorldRegion(worldPosition);\r\n            region.gravity = gravityArray;\r\n            this._hknp.HP_World_SetGravity(region.world, gravityArray);\r\n        } else {\r\n            // Set gravity for all regions (default behavior)\r\n            this._currentGravity = gravityArray;\r\n            for (const region of this._worldRegions) {\r\n                region.gravity = gravityArray;\r\n                this._hknp.HP_World_SetGravity(region.world, gravityArray);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the gravity of the physics world or a specific region.\r\n     *\r\n     * @param worldPosition - Optional world position to get the gravity for that region.\r\n     *                        If not provided, returns the default gravity.\r\n     * @returns The gravity vector.\r\n     */\r\n    public getGravity(worldPosition?: Vector3): Vector3 {\r\n        if (worldPosition) {\r\n            const region = this._getOrCreateWorldRegion(worldPosition);\r\n            return new Vector3(region.gravity[0], region.gravity[1], region.gravity[2]);\r\n        }\r\n        return new Vector3(this._currentGravity[0], this._currentGravity[1], this._currentGravity[2]);\r\n    }\r\n\r\n    /**\r\n     * Sets the fixed time step for the physics engine.\r\n     *\r\n     * @param timeStep - The fixed time step to use for the physics engine.\r\n     *\r\n     */\r\n    public setTimeStep(timeStep: number): void {\r\n        this._fixedTimeStep = timeStep;\r\n    }\r\n\r\n    /**\r\n     * Gets the fixed time step used by the physics engine.\r\n     *\r\n     * @returns The fixed time step used by the physics engine.\r\n     *\r\n     */\r\n    public getTimeStep(): number {\r\n        return this._fixedTimeStep;\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum number of raycast hits to process.\r\n     *\r\n     * @param maxQueryCollectorHits - The maximum number of raycast hits to process.\r\n     */\r\n    public setMaxQueryCollectorHits(maxQueryCollectorHits: number): void {\r\n        if (maxQueryCollectorHits === this._maxQueryCollectorHits) {\r\n            return;\r\n        }\r\n\r\n        if (this._multiQueryCollector) {\r\n            this._hknp.HP_QueryCollector_Release(this._multiQueryCollector);\r\n            this._multiQueryCollector = undefined;\r\n        }\r\n\r\n        if (maxQueryCollectorHits > 1) {\r\n            this._multiQueryCollector = this._hknp.HP_QueryCollector_Create(maxQueryCollectorHits)[1];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the maximum number of raycast hits to process.\r\n     *\r\n     * @returns The maximum number of raycast hits to process.\r\n     */\r\n    public getMaxQueryCollectorHits(): number {\r\n        return this._maxQueryCollectorHits;\r\n    }\r\n\r\n    /**\r\n     * Executes a single step of the physics engine.\r\n     *\r\n     * @param delta The time delta in seconds since the last step.\r\n     * @param physicsBodies An array of physics bodies to be simulated.\r\n     *\r\n     * This method is useful for simulating the physics engine. It sets the physics body transformation,\r\n     * steps the world, syncs the physics body, and notifies collisions. This allows for the physics engine\r\n     * to accurately simulate the physics bodies in the world.\r\n     */\r\n    public executeStep(delta: number, physicsBodies: Array<PhysicsBody>): void {\r\n        // Re-region bodies that have moved outside their current world region\r\n        // BEFORE pre-step and stepping, so the body participates in the correct\r\n        // world's step and its body buffer transform is valid when sync reads it.\r\n        if (this._worldRegions.length > 1 || FloatingOriginCurrentScene.getScene()?.floatingOriginMode) {\r\n            for (const physicsBody of physicsBodies) {\r\n                if (physicsBody._pluginDataInstances.length > 0) {\r\n                    for (const instance of physicsBody._pluginDataInstances) {\r\n                        this._reRegionBodyPluginData(instance);\r\n                    }\r\n                } else if (physicsBody._pluginData) {\r\n                    this._reRegionBodyPluginData(physicsBody._pluginData);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const physicsBody of physicsBodies) {\r\n            if (physicsBody.disablePreStep) {\r\n                continue;\r\n            }\r\n            this.setPhysicsBodyTransformation(physicsBody, physicsBody.transformNode);\r\n        }\r\n\r\n        const deltaTime = this._useDeltaForWorldStep ? delta : this._fixedTimeStep;\r\n\r\n        // Step all world regions\r\n        for (const region of this._worldRegions) {\r\n            this._hknp.HP_World_SetIdealStepTime(region.world, deltaTime);\r\n            this._hknp.HP_World_Step(region.world, deltaTime);\r\n        }\r\n\r\n        for (const physicsBody of physicsBodies) {\r\n            if (!physicsBody.disableSync) {\r\n                this.sync(physicsBody);\r\n            }\r\n        }\r\n\r\n        // Notify collisions and triggers for all world regions\r\n        for (const region of this._worldRegions) {\r\n            this._notifyCollisions(region.world);\r\n            this._notifyTriggers(region.world);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the version of the physics engine plugin.\r\n     *\r\n     * @returns The version of the physics engine plugin.\r\n     *\r\n     * This method is useful for determining the version of the physics engine plugin that is currently running.\r\n     */\r\n    public getPluginVersion(): number {\r\n        return 2;\r\n    }\r\n\r\n    /**\r\n     * Set the maximum allowed linear and angular velocities\r\n     * @param maxLinearVelocity maximum allowed linear velocity\r\n     * @param maxAngularVelocity maximum allowed angular velocity\r\n     */\r\n    setVelocityLimits(maxLinearVelocity: number, maxAngularVelocity: number): void {\r\n        for (const region of this._worldRegions) {\r\n            this._hknp.HP_World_SetSpeedLimit(region.world, maxLinearVelocity, maxAngularVelocity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns maximum allowed linear velocity\r\n     */\r\n    getMaxLinearVelocity(): number {\r\n        const limits = this._hknp.HP_World_GetSpeedLimit(this.world);\r\n        return limits[1];\r\n    }\r\n\r\n    /**\r\n     * @returns maximum allowed angular velocity\r\n     */\r\n    getMaxAngularVelocity(): number {\r\n        const limits = this._hknp.HP_World_GetSpeedLimit(this.world);\r\n        return limits[2];\r\n    }\r\n\r\n    /**\r\n     * Initializes a physics body with the given position and orientation.\r\n     *\r\n     * @param body - The physics body to initialize.\r\n     * @param motionType - The motion type of the body.\r\n     * @param position - The position of the body.\r\n     * @param orientation - The orientation of the body.\r\n     * This code is useful for initializing a physics body with the given position and orientation.\r\n     * It creates a plugin data for the body and adds it to the world. It then converts the position\r\n     * and orientation to a transform and sets the body's transform to the given values.\r\n     */\r\n    public initBody(body: PhysicsBody, motionType: PhysicsMotionType, position: Vector3, orientation: Quaternion): void {\r\n        body._pluginData = new BodyPluginData(this._hknp.HP_Body_Create()[1]);\r\n\r\n        this._internalSetMotionType(body._pluginData, motionType);\r\n\r\n        // Get the world region for this body's position\r\n        const worldRegion = this._getOrCreateWorldRegion(position);\r\n        body._pluginData.worldRegion = worldRegion;\r\n        const offset = worldRegion.floatingOrigin;\r\n        const transform = [[position._x - offset._x, position._y - offset._y, position._z - offset._z], this._bQuatToV4(orientation)];\r\n        this._hknp.HP_Body_SetQTransform(body._pluginData.hpBodyId, transform);\r\n        this._hknp.HP_World_AddBody(worldRegion.world, body._pluginData.hpBodyId, body.startAsleep);\r\n        this._bodies.set(body._pluginData.hpBodyId[0], { body: body, index: 0 });\r\n    }\r\n\r\n    /**\r\n     * Removes a body from the world. To dispose of a body, it is necessary to remove it from the world first.\r\n     *\r\n     * @param body - The body to remove.\r\n     */\r\n    public removeBody(body: PhysicsBody): void {\r\n        if (body._pluginDataInstances && body._pluginDataInstances.length > 0) {\r\n            for (const instance of body._pluginDataInstances) {\r\n                this._bodyCollisionObservable.delete(instance.hpBodyId[0]);\r\n                this._hknp.HP_World_RemoveBody(instance.worldRegion.world, instance.hpBodyId);\r\n                this._bodies.delete(instance.hpBodyId[0]);\r\n            }\r\n        }\r\n        if (body._pluginData) {\r\n            this._bodyCollisionObservable.delete(body._pluginData.hpBodyId[0]);\r\n            this._hknp.HP_World_RemoveBody(body._pluginData.worldRegion.world, body._pluginData.hpBodyId);\r\n            this._bodies.delete(body._pluginData.hpBodyId[0]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the body instances for a given physics body and mesh.\r\n     *\r\n     * @param body - The physics body to initialize.\r\n     * @param motionType - How the body will be handled by the engine\r\n     * @param mesh - The mesh to initialize.\r\n     *\r\n     * This code is useful for creating a physics body from a mesh. It creates a\r\n     * body instance for each instance of the mesh and adds it to the world. It also\r\n     * sets the position of the body instance to the position of the mesh instance.\r\n     * This allows for the physics engine to accurately simulate the mesh in the\r\n     * world.\r\n     */\r\n    public initBodyInstances(body: PhysicsBody, motionType: PhysicsMotionType, mesh: Mesh): void {\r\n        const instancesCount = mesh._thinInstanceDataStorage?.instancesCount ?? 0;\r\n        const matrixData = mesh._thinInstanceDataStorage.matrixData;\r\n        if (!matrixData) {\r\n            return; // TODO: error handling\r\n        }\r\n        this._createOrUpdateBodyInstances(body, motionType, matrixData, 0, instancesCount, false);\r\n        for (let index = 0; index < body._pluginDataInstances.length; index++) {\r\n            const bodyId = body._pluginDataInstances[index];\r\n            this._bodies.set(bodyId.hpBodyId[0], { body: body, index: index });\r\n        }\r\n    }\r\n\r\n    private _createOrUpdateBodyInstances(body: PhysicsBody, motionType: PhysicsMotionType, matrixData: Float32Array, startIndex: number, endIndex: number, update: boolean): void {\r\n        const rotation = TmpVectors.Quaternion[0];\r\n        const rotationMatrix = Matrix.Identity();\r\n        const worldPos = TmpVectors.Vector3[0];\r\n\r\n        for (let i = startIndex; i < endIndex; i++) {\r\n            // Get world position for this instance\r\n            worldPos.set(matrixData[i * 16 + 12], matrixData[i * 16 + 13], matrixData[i * 16 + 14]);\r\n\r\n            let hkbody;\r\n            let pluginData: BodyPluginData;\r\n            if (!update) {\r\n                hkbody = this._hknp.HP_Body_Create()[1];\r\n                pluginData = new BodyPluginData(hkbody);\r\n\r\n                if (body._pluginDataInstances.length) {\r\n                    // If an instance already exists, copy any user-provided mass properties\r\n                    pluginData.userMassProps = body._pluginDataInstances[0].userMassProps;\r\n                }\r\n            } else {\r\n                pluginData = body._pluginDataInstances[i];\r\n                hkbody = pluginData.hpBodyId;\r\n            }\r\n\r\n            // Get the world region for this instance's position\r\n            const worldRegion = this._getOrCreateWorldRegion(worldPos);\r\n            const offset = worldRegion.floatingOrigin;\r\n\r\n            // Subtract floating origin offset to get small coordinates for Havok (float32 precision)\r\n            const position = [worldPos._x - offset._x, worldPos._y - offset._y, worldPos._z - offset._z];\r\n\r\n            rotationMatrix.setRowFromFloats(0, matrixData[i * 16 + 0], matrixData[i * 16 + 1], matrixData[i * 16 + 2], 0);\r\n            rotationMatrix.setRowFromFloats(1, matrixData[i * 16 + 4], matrixData[i * 16 + 5], matrixData[i * 16 + 6], 0);\r\n            rotationMatrix.setRowFromFloats(2, matrixData[i * 16 + 8], matrixData[i * 16 + 9], matrixData[i * 16 + 10], 0);\r\n            Quaternion.FromRotationMatrixToRef(rotationMatrix, rotation);\r\n            const transform = [position, [rotation.x, rotation.y, rotation.z, rotation.w]];\r\n            this._hknp.HP_Body_SetQTransform(hkbody, transform);\r\n            if (!update) {\r\n                this._internalSetMotionType(pluginData, motionType);\r\n                this._internalUpdateMassProperties(pluginData);\r\n                body._pluginDataInstances.push(pluginData);\r\n                // Add to the appropriate world\r\n                pluginData.worldRegion = worldRegion;\r\n                this._hknp.HP_World_AddBody(worldRegion.world, hkbody, body.startAsleep);\r\n                pluginData.worldTransformOffset = this._hknp.HP_Body_GetWorldTransformOffset(hkbody)[1];\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update the internal body instances for a given physics body to match the instances in a mesh.\r\n     * @param body the body that will be updated\r\n     * @param mesh the mesh with reference instances\r\n     */\r\n    public updateBodyInstances(body: PhysicsBody, mesh: Mesh): void {\r\n        const instancesCount = mesh._thinInstanceDataStorage?.instancesCount ?? 0;\r\n        const matrixData = mesh._thinInstanceDataStorage.matrixData;\r\n        if (!matrixData) {\r\n            return; // TODO: error handling\r\n        }\r\n        const pluginInstancesCount = body._pluginDataInstances.length;\r\n        const motionType = this.getMotionType(body);\r\n\r\n        if (instancesCount > pluginInstancesCount) {\r\n            this._createOrUpdateBodyInstances(body, motionType, matrixData, pluginInstancesCount, instancesCount, false);\r\n            const firstBodyShape = this._hknp.HP_Body_GetShape(body._pluginDataInstances[0].hpBodyId)[1];\r\n            // firstBodyShape[0] might be 0 in the case where thin instances data is set (with thinInstancesSetBuffer call) after body creation\r\n            // in that case, use the shape provided at body creation.\r\n            if (!firstBodyShape[0]) {\r\n                firstBodyShape[0] = body.shape?._pluginData[0];\r\n            }\r\n            for (let i = pluginInstancesCount; i < instancesCount; i++) {\r\n                this._hknp.HP_Body_SetShape(body._pluginDataInstances[i].hpBodyId, firstBodyShape);\r\n                this._internalUpdateMassProperties(body._pluginDataInstances[i]);\r\n                this._bodies.set(body._pluginDataInstances[i].hpBodyId[0], { body: body, index: i });\r\n            }\r\n        } else if (instancesCount < pluginInstancesCount) {\r\n            const instancesToRemove = pluginInstancesCount - instancesCount;\r\n            for (let i = 0; i < instancesToRemove; i++) {\r\n                const hkbody = body._pluginDataInstances.pop();\r\n                this._bodies.delete(hkbody.hpBodyId[0]);\r\n                this._hknp.HP_World_RemoveBody(hkbody.worldRegion.world, hkbody.hpBodyId);\r\n                this._hknp.HP_Body_Release(hkbody.hpBodyId);\r\n            }\r\n            this._createOrUpdateBodyInstances(body, motionType, matrixData, 0, instancesCount, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Synchronizes the transform of a physics body with its transform node.\r\n     * @param body - The physics body to synchronize.\r\n     *\r\n     * This function is useful for keeping the physics body's transform in sync with its transform node.\r\n     * This is important for ensuring that the physics body is accurately represented in the physics engine.\r\n     */\r\n    sync(body: PhysicsBody): void {\r\n        this.syncTransform(body, body.transformNode);\r\n    }\r\n\r\n    /**\r\n     * Synchronizes the transform of a physics body with the transform of its\r\n     * corresponding transform node.\r\n     *\r\n     * @param body - The physics body to synchronize.\r\n     * @param transformNode - The destination Transform Node.\r\n     *\r\n     * This code is useful for synchronizing the position and orientation of a\r\n     * physics body with the position and orientation of its corresponding\r\n     * transform node. This is important for ensuring that the physics body and\r\n     * the transform node are in the same position and orientation in the scene.\r\n     * This is necessary for the physics engine to accurately simulate the\r\n     * physical behavior of the body.\r\n     */\r\n    syncTransform(body: PhysicsBody, transformNode: TransformNode): void {\r\n        // Get the floating origin offset - this was subtracted when positions were sent to Havok\r\n        // We need to add it back to get the correct world position\r\n\r\n        if (body._pluginDataInstances.length) {\r\n            // instances\r\n            const m = transformNode as Mesh;\r\n            const matrixData = m._thinInstanceDataStorage.matrixData;\r\n            if (!matrixData) {\r\n                return; // TODO: error handling\r\n            }\r\n            const instancesCount = body._pluginDataInstances.length;\r\n            for (let i = 0; i < instancesCount; i++) {\r\n                const pluginData = body._pluginDataInstances[i];\r\n                // Use instance's world region offset\r\n                const instanceOffset = pluginData.worldRegion.floatingOrigin;\r\n                // Get body buffer from the instance's own world region (not always the default world)\r\n                const bodyBuffer = this._hknp.HP_World_GetBodyBuffer(pluginData.worldRegion.world)[1];\r\n                const bufOffset = pluginData.worldTransformOffset;\r\n                const transformBuffer = new Float32Array(this._hknp.HEAPU8.buffer, bodyBuffer + bufOffset, 16);\r\n                const index = i * 16;\r\n\r\n                for (let mi = 0; mi < 15; mi++) {\r\n                    if ((mi & 3) != 3) {\r\n                        matrixData[index + mi] = transformBuffer[mi];\r\n                    }\r\n                }\r\n                // Add back the floating origin offset to get world position\r\n                // (Havok stores position - offset, so we add offset back)\r\n                matrixData[index + 12] += instanceOffset._x;\r\n                matrixData[index + 13] += instanceOffset._y;\r\n                matrixData[index + 14] += instanceOffset._z;\r\n                matrixData[index + 15] = 1;\r\n            }\r\n            m.thinInstanceBufferUpdated(\"matrix\");\r\n        } else {\r\n            try {\r\n                const bodyTransform = this._hknp.HP_Body_GetQTransform(body._pluginData.hpBodyId)[1];\r\n                const bodyTranslation = bodyTransform[0];\r\n                const bodyOrientation = bodyTransform[1];\r\n                const quat = TmpVectors.Quaternion[0];\r\n                // Use body's world region offset\r\n                const offset = body._pluginData.worldRegion.floatingOrigin;\r\n\r\n                quat.set(bodyOrientation[0], bodyOrientation[1], bodyOrientation[2], bodyOrientation[3]);\r\n\r\n                // Add back the floating origin offset to get world position\r\n                const worldX = bodyTranslation[0] + offset._x;\r\n                const worldY = bodyTranslation[1] + offset._y;\r\n                const worldZ = bodyTranslation[2] + offset._z;\r\n\r\n                const parent = transformNode.parent as TransformNode;\r\n                // transform position/orientation in parent space\r\n                if (parent && !parent.getWorldMatrix().isIdentity()) {\r\n                    parent.computeWorldMatrix(true);\r\n                    // Save scaling for future use\r\n                    TmpVectors.Vector3[1].copyFrom(transformNode.scaling);\r\n\r\n                    quat.normalize();\r\n                    const finalTransform = TmpVectors.Matrix[0];\r\n                    const finalTranslation = TmpVectors.Vector3[0];\r\n                    finalTranslation.copyFromFloats(worldX, worldY, worldZ);\r\n                    Matrix.ComposeToRef(transformNode.absoluteScaling, quat, finalTranslation, finalTransform);\r\n\r\n                    const parentInverseTransform = TmpVectors.Matrix[1];\r\n                    parent.getWorldMatrix().invertToRef(parentInverseTransform);\r\n\r\n                    const localTransform = TmpVectors.Matrix[2];\r\n                    finalTransform.multiplyToRef(parentInverseTransform, localTransform);\r\n                    localTransform.decomposeToTransformNode(transformNode);\r\n                    transformNode.rotationQuaternion?.normalize();\r\n                    // Keep original scaling. Re-injecting scaling can introduce discontinuity between frames. Basically, it grows or shrinks.\r\n                    transformNode.scaling.copyFrom(TmpVectors.Vector3[1]);\r\n                } else {\r\n                    transformNode.position.set(worldX, worldY, worldZ);\r\n                    if (transformNode.rotationQuaternion) {\r\n                        transformNode.rotationQuaternion.copyFrom(quat);\r\n                    } else {\r\n                        quat.toEulerAnglesToRef(transformNode.rotation);\r\n                    }\r\n                }\r\n            } catch (e) {\r\n                Logger.Error(`Syncing transform failed for node ${transformNode.name}: ${e.message}...`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the shape of a physics body.\r\n     * @param body - The physics body to set the shape for.\r\n     * @param shape - The physics shape to set.\r\n     *\r\n     * This function is used to set the shape of a physics body. It is useful for\r\n     * creating a physics body with a specific shape, such as a box or a sphere,\r\n     * which can then be used to simulate physical interactions in a physics engine.\r\n     * This function is especially useful for meshes with multiple instances, as it\r\n     * will set the shape for each instance of the mesh.\r\n     */\r\n    public setShape(body: PhysicsBody, shape: Nullable<PhysicsShape>): void {\r\n        const shapeHandle = shape && shape._pluginData ? shape._pluginData : BigInt(0);\r\n        if (!(body.transformNode instanceof Mesh) || !body.transformNode._thinInstanceDataStorage?.matrixData) {\r\n            this._hknp.HP_Body_SetShape(body._pluginData.hpBodyId, shapeHandle);\r\n            this._internalUpdateMassProperties(body._pluginData);\r\n            return;\r\n        }\r\n        const m = body.transformNode;\r\n        const instancesCount = m._thinInstanceDataStorage?.instancesCount ?? 0;\r\n        for (let i = 0; i < instancesCount; i++) {\r\n            this._hknp.HP_Body_SetShape(body._pluginDataInstances[i].hpBodyId, shapeHandle);\r\n            this._internalUpdateMassProperties(body._pluginDataInstances[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns a reference to the first instance of the plugin data for a physics body.\r\n     * @param body\r\n     * @param instanceIndex\r\n     * @returns a reference to the first instance\r\n     */\r\n    private _getPluginReference(body: PhysicsBody, instanceIndex?: number): BodyPluginData {\r\n        return body._pluginDataInstances?.length ? body._pluginDataInstances[instanceIndex ?? 0] : body._pluginData;\r\n    }\r\n\r\n    /**\r\n     * Gets the shape of a physics body. This will create a new shape object\r\n     *\r\n     * @param body - The physics body.\r\n     * @returns The shape of the physics body.\r\n     *\r\n     */\r\n    public getShape(body: PhysicsBody): Nullable<PhysicsShape> {\r\n        const pluginRef = this._getPluginReference(body);\r\n        const shapePluginData = this._hknp.HP_Body_GetShape(pluginRef.hpBodyId)[1];\r\n        if (shapePluginData != 0) {\r\n            const scene = body.transformNode.getScene();\r\n            return new PhysicsShape({ pluginData: shapePluginData }, scene);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the type of a physics shape.\r\n     * @param shape - The physics shape to get the type for.\r\n     * @returns The type of the physics shape.\r\n     *\r\n     */\r\n    public getShapeType(shape: PhysicsShape): PhysicsShapeType {\r\n        if (shape.type) {\r\n            return shape.type;\r\n        } else {\r\n            //<todo This returns a native type!\r\n            return this._hknp.HP_Shape_GetType(shape._pluginData);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the event mask of a physics body.\r\n     * @param body - The physics body to set the event mask for.\r\n     * @param eventMask - The event mask to set.\r\n     * @param instanceIndex - The index of the instance to set the event mask for\r\n     *\r\n     * This function is useful for setting the event mask of a physics body, which is used to determine which events the body will respond to. This is important for ensuring that the physics engine is able to accurately simulate the behavior of the body in the game world.\r\n     */\r\n    public setEventMask(body: PhysicsBody, eventMask: number, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (bodyPluginData) => {\r\n                this._hknp.HP_Body_SetEventMask(bodyPluginData.hpBodyId, eventMask);\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Retrieves the event mask of a physics body.\r\n     *\r\n     * @param body - The physics body to retrieve the event mask from.\r\n     * @param instanceIndex - The index of the instance to retrieve the event mask from.\r\n     * @returns The event mask of the physics body.\r\n     *\r\n     */\r\n    public getEventMask(body: PhysicsBody, instanceIndex?: number): number {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        return this._hknp.HP_Body_GetEventMask(pluginRef.hpBodyId)[1];\r\n    }\r\n\r\n    private _fromMassPropertiesTuple(massPropsTuple: any[]): PhysicsMassProperties {\r\n        return {\r\n            centerOfMass: Vector3.FromArray(massPropsTuple[0]),\r\n            mass: massPropsTuple[1],\r\n            inertia: Vector3.FromArray(massPropsTuple[2]),\r\n            inertiaOrientation: Quaternion.FromArray(massPropsTuple[3]),\r\n        };\r\n    }\r\n\r\n    private _internalUpdateMassProperties(pluginData: BodyPluginData) {\r\n        // Recompute the mass based on the shape\r\n        const newProps = this._internalComputeMassProperties(pluginData);\r\n        const massProps = pluginData.userMassProps;\r\n\r\n        // Override the computed values with any the user has set\r\n        if (massProps.centerOfMass) {\r\n            newProps[0] = massProps.centerOfMass.asArray();\r\n        }\r\n        if (massProps.mass != undefined) {\r\n            newProps[1] = massProps.mass;\r\n        }\r\n        if (massProps.inertia) {\r\n            newProps[2] = massProps.inertia.asArray();\r\n        }\r\n        if (massProps.inertiaOrientation) {\r\n            newProps[3] = massProps.inertiaOrientation.asArray();\r\n        }\r\n        this._hknp.HP_Body_SetMassProperties(pluginData.hpBodyId, newProps);\r\n    }\r\n\r\n    public _internalSetMotionType(pluginData: BodyPluginData, motionType: PhysicsMotionType): void {\r\n        switch (motionType) {\r\n            case PhysicsMotionType.STATIC:\r\n                this._hknp.HP_Body_SetMotionType(pluginData.hpBodyId, this._hknp.MotionType.STATIC);\r\n                break;\r\n            case PhysicsMotionType.ANIMATED:\r\n                this._hknp.HP_Body_SetMotionType(pluginData.hpBodyId, this._hknp.MotionType.KINEMATIC);\r\n                break;\r\n            case PhysicsMotionType.DYNAMIC:\r\n                this._hknp.HP_Body_SetMotionType(pluginData.hpBodyId, this._hknp.MotionType.DYNAMIC);\r\n                break;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * sets the motion type of a physics body.\r\n     * @param body - The physics body to set the motion type for.\r\n     * @param motionType - The motion type to set.\r\n     * @param instanceIndex - The index of the instance to set the motion type for. If undefined, the motion type of all the bodies will be set.\r\n     */\r\n    public setMotionType(body: PhysicsBody, motionType: PhysicsMotionType, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginData) => {\r\n                this._internalSetMotionType(pluginData, motionType);\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the motion type of a physics body.\r\n     * @param body - The physics body to get the motion type from.\r\n     * @param instanceIndex - The index of the instance to get the motion type from. If not specified, the motion type of the first instance will be returned.\r\n     * @returns The motion type of the physics body.\r\n     */\r\n    public getMotionType(body: PhysicsBody, instanceIndex?: number): PhysicsMotionType {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        const type = this._hknp.HP_Body_GetMotionType(pluginRef.hpBodyId)[1];\r\n        switch (type) {\r\n            case this._hknp.MotionType.STATIC:\r\n                return PhysicsMotionType.STATIC;\r\n            case this._hknp.MotionType.KINEMATIC:\r\n                return PhysicsMotionType.ANIMATED;\r\n            case this._hknp.MotionType.DYNAMIC:\r\n                return PhysicsMotionType.DYNAMIC;\r\n        }\r\n        throw new Error(\"Unknown motion type: \" + type);\r\n    }\r\n\r\n    /**\r\n     * sets the activation control mode of a physics body, for instance if you need the body to never sleep.\r\n     * @param body - The physics body to set the activation control mode.\r\n     * @param controlMode - The activation control mode.\r\n     */\r\n    public setActivationControl(body: PhysicsBody, controlMode: PhysicsActivationControl): void {\r\n        switch (controlMode) {\r\n            case PhysicsActivationControl.ALWAYS_ACTIVE:\r\n                this._hknp.HP_Body_SetActivationControl(body._pluginData.hpBodyId, this._hknp.ActivationControl.ALWAYS_ACTIVE);\r\n                break;\r\n            case PhysicsActivationControl.ALWAYS_INACTIVE:\r\n                this._hknp.HP_Body_SetActivationControl(body._pluginData.hpBodyId, this._hknp.ActivationControl.ALWAYS_INACTIVE);\r\n                break;\r\n            case PhysicsActivationControl.SIMULATION_CONTROLLED:\r\n                this._hknp.HP_Body_SetActivationControl(body._pluginData.hpBodyId, this._hknp.ActivationControl.SIMULATION_CONTROLLED);\r\n                break;\r\n        }\r\n    }\r\n\r\n    private _internalComputeMassProperties(pluginData: BodyPluginData): any[] {\r\n        const shapeRes = this._hknp.HP_Body_GetShape(pluginData.hpBodyId);\r\n        if (shapeRes[0] == this._hknp.Result.RESULT_OK) {\r\n            const shapeMass = this._hknp.HP_Shape_BuildMassProperties(shapeRes[1]);\r\n            if (shapeMass[0] == this._hknp.Result.RESULT_OK) {\r\n                return shapeMass[1];\r\n            }\r\n        }\r\n\r\n        // Failed; return a unit inertia\r\n        return [[0, 0, 0], 1, [1, 1, 1], [0, 0, 0, 1]];\r\n    }\r\n\r\n    /**\r\n     * Computes the mass properties of a physics body, from it's shape\r\n     *\r\n     * @param body - The physics body to copmute the mass properties of\r\n     * @param instanceIndex - The index of the instance to compute the mass properties of.\r\n     * @returns The mass properties of the physics body.\r\n     */\r\n    public computeMassProperties(body: PhysicsBody, instanceIndex?: number): PhysicsMassProperties {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        const computed = this._internalComputeMassProperties(pluginRef);\r\n        return this._fromMassPropertiesTuple(computed);\r\n    }\r\n\r\n    /**\r\n     * Sets the mass properties of a physics body.\r\n     *\r\n     * @param body - The physics body to set the mass properties of.\r\n     * @param massProps - The mass properties to set.\r\n     * @param instanceIndex - The index of the instance to set the mass properties of. If undefined, the mass properties of all the bodies will be set.\r\n     * This function is useful for setting the mass properties of a physics body,\r\n     * such as its mass, inertia, and center of mass. This is important for\r\n     * accurately simulating the physics of the body in the physics engine.\r\n     *\r\n     */\r\n    public setMassProperties(body: PhysicsBody, massProps: PhysicsMassProperties, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginData) => {\r\n                pluginData.userMassProps = massProps;\r\n                this._internalUpdateMassProperties(pluginData);\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n    /**\r\n     * Gets the mass properties of a physics body.\r\n     * @param body - The physics body to get the mass properties from.\r\n     * @param instanceIndex - The index of the instance to get the mass properties from. If not specified, the mass properties of the first instance will be returned.\r\n     * @returns The mass properties of the physics body.\r\n     */\r\n    public getMassProperties(body: PhysicsBody, instanceIndex?: number): PhysicsMassProperties {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        const massPropsTuple = this._hknp.HP_Body_GetMassProperties(pluginRef.hpBodyId)[1];\r\n        return this._fromMassPropertiesTuple(massPropsTuple);\r\n    }\r\n\r\n    /**\r\n     * Sets the linear damping of the given body.\r\n     * @param body - The body to set the linear damping for.\r\n     * @param damping - The linear damping to set.\r\n     * @param instanceIndex - The index of the instance to set the linear damping for. If not specified, the linear damping of the first instance will be set.\r\n     *\r\n     * This method is useful for controlling the linear damping of a body in a physics engine.\r\n     * Linear damping is a force that opposes the motion of the body, and is proportional to the velocity of the body.\r\n     * This method allows the user to set the linear damping of a body, which can be used to control the motion of the body.\r\n     */\r\n    public setLinearDamping(body: PhysicsBody, damping: number, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginData) => {\r\n                this._hknp.HP_Body_SetLinearDamping(pluginData.hpBodyId, damping);\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the linear damping of the given body.\r\n     * @param body - The body to get the linear damping from.\r\n     * @param instanceIndex - The index of the instance to get the linear damping from. If not specified, the linear damping of the first instance will be returned.\r\n     * @returns The linear damping of the given body.\r\n     *\r\n     * This method is useful for getting the linear damping of a body in a physics engine.\r\n     * Linear damping is a force that opposes the motion of the body and is proportional to the velocity of the body.\r\n     * It is used to simulate the effects of air resistance and other forms of friction.\r\n     */\r\n    public getLinearDamping(body: PhysicsBody, instanceIndex?: number): number {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        return this._hknp.HP_Body_GetLinearDamping(pluginRef.hpBodyId)[1];\r\n    }\r\n\r\n    /**\r\n     * Sets the angular damping of a physics body.\r\n     * @param body - The physics body to set the angular damping for.\r\n     * @param damping - The angular damping value to set.\r\n     * @param instanceIndex - The index of the instance to set the angular damping for. If not specified, the angular damping of the first instance will be set.\r\n     *\r\n     * This function is useful for controlling the angular velocity of a physics body.\r\n     * By setting the angular damping, the body's angular velocity will be reduced over time, allowing for more realistic physics simulations.\r\n     */\r\n    public setAngularDamping(body: PhysicsBody, damping: number, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginData) => {\r\n                this._hknp.HP_Body_SetAngularDamping(pluginData.hpBodyId, damping);\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the angular damping of a physics body.\r\n     * @param body - The physics body to get the angular damping from.\r\n     * @param instanceIndex - The index of the instance to get the angular damping from. If not specified, the angular damping of the first instance will be returned.\r\n     * @returns The angular damping of the body.\r\n     *\r\n     * This function is useful for retrieving the angular damping of a physics body,\r\n     * which is used to control the rotational motion of the body. The angular damping is a value between 0 and 1, where 0 is no damping and 1 is full damping.\r\n     */\r\n    public getAngularDamping(body: PhysicsBody, instanceIndex?: number): number {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        return this._hknp.HP_Body_GetAngularDamping(pluginRef.hpBodyId)[1];\r\n    }\r\n\r\n    /**\r\n     * Sets the linear velocity of a physics body.\r\n     * @param body - The physics body to set the linear velocity of.\r\n     * @param linVel - The linear velocity to set.\r\n     * @param instanceIndex - The index of the instance to set the linear velocity of. If not specified, the linear velocity of the first instance will be set.\r\n     *\r\n     * This function is useful for setting the linear velocity of a physics body, which is necessary for simulating\r\n     * motion in a physics engine. The linear velocity is the speed and direction of the body's movement.\r\n     */\r\n    public setLinearVelocity(body: PhysicsBody, linVel: Vector3, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginData) => {\r\n                this._hknp.HP_Body_SetLinearVelocity(pluginData.hpBodyId, this._bVecToV3(linVel));\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the linear velocity of a physics body and stores it in a given vector.\r\n     * @param body - The physics body to get the linear velocity from.\r\n     * @param linVel - The vector to store the linear velocity in.\r\n     * @param instanceIndex - The index of the instance to get the linear velocity from. If not specified, the linear velocity of the first instance will be returned.\r\n     *\r\n     * This function is useful for retrieving the linear velocity of a physics body,\r\n     * which can be used to determine the speed and direction of the body. This\r\n     * information can be used to simulate realistic physics behavior in a game.\r\n     */\r\n    public getLinearVelocityToRef(body: PhysicsBody, linVel: Vector3, instanceIndex?: number): void {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        const lv = this._hknp.HP_Body_GetLinearVelocity(pluginRef.hpBodyId)[1];\r\n        this._v3ToBvecRef(lv, linVel);\r\n    }\r\n\r\n    /*\r\n     * Apply an operation either to all instances of a body, if instanceIndex is not specified, or to a specific instance.\r\n     */\r\n    private _applyToBodyOrInstances(body: PhysicsBody, fnToApply: (pluginRef: any) => void, instanceIndex?: number): void {\r\n        if (body._pluginDataInstances?.length > 0 && instanceIndex === undefined) {\r\n            for (let i = 0; i < body._pluginDataInstances.length; i++) {\r\n                fnToApply(body._pluginDataInstances[i]);\r\n            }\r\n        } else {\r\n            fnToApply(this._getPluginReference(body, instanceIndex));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Applies an impulse to a physics body at a given location.\r\n     * @param body - The physics body to apply the impulse to.\r\n     * @param impulse - The impulse vector to apply.\r\n     * @param location - The location in world space to apply the impulse.\r\n     * @param instanceIndex - The index of the instance to apply the impulse to. If not specified, the impulse will be applied to all instances.\r\n     *\r\n     * This method is useful for applying an impulse to a physics body at a given location.\r\n     * This can be used to simulate physical forces such as explosions, collisions, and gravity.\r\n     */\r\n    public applyImpulse(body: PhysicsBody, impulse: Vector3, location: Vector3, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginRef) => {\r\n                const offset = pluginRef.worldRegion.floatingOrigin;\r\n                this._hknp.HP_Body_ApplyImpulse(pluginRef.hpBodyId, this._bVecToV3WithOffset(location, offset), this._bVecToV3(impulse));\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Applies an angular impulse(torque) to a physics body\r\n     * @param body - The physics body to apply the impulse to.\r\n     * @param angularImpulse - The torque value\r\n     * @param instanceIndex - The index of the instance to apply the impulse to. If not specified, the impulse will be applied to all instances.\r\n     */\r\n    public applyAngularImpulse(body: PhysicsBody, angularImpulse: Vector3, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginRef) => {\r\n                this._hknp.HP_Body_ApplyAngularImpulse(pluginRef.hpBodyId, this._bVecToV3(angularImpulse));\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n    /**\r\n     * Applies a force to a physics body at a given location.\r\n     * @param body - The physics body to apply the impulse to.\r\n     * @param force - The force vector to apply.\r\n     * @param location - The location in world space to apply the impulse.\r\n     * @param instanceIndex - The index of the instance to apply the force to. If not specified, the force will be applied to all instances.\r\n     *\r\n     * This method is useful for applying a force to a physics body at a given location.\r\n     * This can be used to simulate physical forces such as explosions, collisions, and gravity.\r\n     */\r\n    public applyForce(body: PhysicsBody, force: Vector3, location: Vector3, instanceIndex?: number): void {\r\n        force.scaleToRef(this.getTimeStep(), this._tmpVec3[0]);\r\n        this.applyImpulse(body, this._tmpVec3[0], location, instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Applies a torque to a physics body.\r\n     * @param body - The physics body to apply the torque to.\r\n     * @param torque - The torque vector.\r\n     * @param instanceIndex - The index of the instance to apply the torque to. If not specified, the torque will be applied to all instances.\r\n     *\r\n     * This method is useful for applying a torque to a physics body.\r\n     * This can be used to simulate rotational forces such as motors, angular momentum, and rotational dynamics.\r\n     */\r\n    public applyTorque(body: PhysicsBody, torque: Vector3, instanceIndex?: number): void {\r\n        torque.scaleToRef(this.getTimeStep(), this._tmpVec3[0]);\r\n        this.applyAngularImpulse(body, this._tmpVec3[0], instanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Sets the angular velocity of a physics body.\r\n     *\r\n     * @param body - The physics body to set the angular velocity of.\r\n     * @param angVel - The angular velocity to set.\r\n     * @param instanceIndex - The index of the instance to set the angular velocity of. If not specified, the angular velocity of the first instance will be set.\r\n     *\r\n     * This function is useful for setting the angular velocity of a physics body in a physics engine.\r\n     * This allows for more realistic simulations of physical objects, as they can be given a rotational velocity.\r\n     */\r\n    public setAngularVelocity(body: PhysicsBody, angVel: Vector3, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginRef) => {\r\n                this._hknp.HP_Body_SetAngularVelocity(pluginRef.hpBodyId, this._bVecToV3(angVel));\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets the angular velocity of a body.\r\n     * @param body - The body to get the angular velocity from.\r\n     * @param angVel - The vector3 to store the angular velocity.\r\n     * @param instanceIndex - The index of the instance to get the angular velocity from. If not specified, the angular velocity of the first instance will be returned.\r\n     *\r\n     * This method is useful for getting the angular velocity of a body in a physics engine. It\r\n     * takes the body and a vector3 as parameters and stores the angular velocity of the body\r\n     * in the vector3. This is useful for getting the angular velocity of a body in order to\r\n     * calculate the motion of the body in the physics engine.\r\n     */\r\n    public getAngularVelocityToRef(body: PhysicsBody, angVel: Vector3, instanceIndex?: number): void {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        const av = this._hknp.HP_Body_GetAngularVelocity(pluginRef.hpBodyId)[1];\r\n        this._v3ToBvecRef(av, angVel);\r\n    }\r\n\r\n    /**\r\n     * Sets the transformation of the given physics body to the given transform node.\r\n     * @param body The physics body to set the transformation for.\r\n     * @param node The transform node to set the transformation from.\r\n     * Sets the transformation of the given physics body to the given transform node.\r\n     *\r\n     * This function is useful for setting the transformation of a physics body to a\r\n     * transform node, which is necessary for the physics engine to accurately simulate\r\n     * the motion of the body. It also takes into account instances of the transform\r\n     * node, which is necessary for accurate simulation of multiple bodies with the\r\n     * same transformation.\r\n     */\r\n    public setPhysicsBodyTransformation(body: PhysicsBody, node: TransformNode) {\r\n        if (body.getPrestepType() == PhysicsPrestepType.TELEPORT) {\r\n            const transformNode = body.transformNode;\r\n            if (body.numInstances > 0) {\r\n                // instances\r\n                const m = transformNode as Mesh;\r\n                const matrixData = m._thinInstanceDataStorage.matrixData;\r\n                if (!matrixData) {\r\n                    return; // TODO: error handling\r\n                }\r\n                const instancesCount = body.numInstances;\r\n                this._createOrUpdateBodyInstances(body, body.getMotionType(), matrixData, 0, instancesCount, true);\r\n            } else {\r\n                // Check if the node's new world position requires a region change.\r\n                // This ensures teleports (e.g. toggling disablePreStep after moving\r\n                // the transform node) immediately land in the correct region with\r\n                // correct local coordinates, avoiding a one-frame precision glitch.\r\n                const pluginData = body._pluginData;\r\n                if (pluginData.worldRegion && (this._worldRegions.length > 1 || FloatingOriginCurrentScene.getScene()?.floatingOriginMode)) {\r\n                    // Get world position of the node\r\n                    const worldPos = TmpVectors.Vector3[3];\r\n                    if (node.parent) {\r\n                        node.computeWorldMatrix(true);\r\n                        worldPos.copyFrom(node.absolutePosition);\r\n                    } else {\r\n                        worldPos.copyFrom(node.position);\r\n                    }\r\n\r\n                    const currentRegion = pluginData.worldRegion;\r\n                    const distToCurrent = Vector3.Distance(worldPos, currentRegion.floatingOrigin);\r\n                    if (distToCurrent > this._floatingOriginWorldRadius * 1.2) {\r\n                        // Teleporting outside current region - re-region before setting transform\r\n                        const newRegion = this._getOrCreateWorldRegion(worldPos);\r\n                        if (newRegion !== currentRegion) {\r\n                            // Save velocity before removing from old world\r\n                            const linVel = this._hknp.HP_Body_GetLinearVelocity(pluginData.hpBodyId)[1];\r\n                            const angVel = this._hknp.HP_Body_GetAngularVelocity(pluginData.hpBodyId)[1];\r\n\r\n                            // Remove from old world, add to new world\r\n                            this._hknp.HP_World_RemoveBody(currentRegion.world, pluginData.hpBodyId);\r\n                            this._hknp.HP_World_AddBody(newRegion.world, pluginData.hpBodyId, false);\r\n\r\n                            // Restore velocity\r\n                            this._hknp.HP_Body_SetLinearVelocity(pluginData.hpBodyId, linVel);\r\n                            this._hknp.HP_Body_SetAngularVelocity(pluginData.hpBodyId, angVel);\r\n\r\n                            // Update region reference and cached world transform offset\r\n                            pluginData.worldRegion = newRegion;\r\n                            pluginData.worldTransformOffset = this._hknp.HP_Body_GetWorldTransformOffset(pluginData.hpBodyId)[1];\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Set transform using the (possibly updated) region offset\r\n                const offset = body._pluginData.worldRegion.floatingOrigin;\r\n                this._hknp.HP_Body_SetQTransform(body._pluginData.hpBodyId, this._getTransformInfos(node, offset));\r\n            }\r\n        } else if (body.getPrestepType() == PhysicsPrestepType.ACTION) {\r\n            this.setTargetTransform(body, node.absolutePosition, node.absoluteRotationQuaternion);\r\n        } else if (body.getPrestepType() == PhysicsPrestepType.DISABLED) {\r\n            Logger.Warn(\"Prestep type is set to DISABLED. Unable to set physics body transformation.\");\r\n        } else {\r\n            Logger.Warn(\"Invalid prestep type set to physics body.\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the target transformation (position and rotation) of the body, such that the body will set its velocity to reach that target\r\n     * @param body The physics body to set the target transformation for.\r\n     * @param position The target position\r\n     * @param rotation The target rotation\r\n     * @param instanceIndex The index of the instance in an instanced body\r\n     */\r\n    public setTargetTransform(body: PhysicsBody, position: Vector3, rotation: Quaternion, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginRef) => {\r\n                const offset = pluginRef.worldRegion.floatingOrigin;\r\n                this._hknp.HP_Body_SetTargetQTransform(pluginRef.hpBodyId, [this._bVecToV3WithOffset(position, offset), this._bQuatToV4(rotation)]);\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Sets the gravity factor of a body\r\n     * @param body the physics body to set the gravity factor for\r\n     * @param factor the gravity factor\r\n     * @param instanceIndex the index of the instance in an instanced body\r\n     */\r\n    public setGravityFactor(body: PhysicsBody, factor: number, instanceIndex?: number): void {\r\n        this._applyToBodyOrInstances(\r\n            body,\r\n            (pluginRef) => {\r\n                this._hknp.HP_Body_SetGravityFactor(pluginRef.hpBodyId, factor);\r\n            },\r\n            instanceIndex\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Get the gravity factor of a body\r\n     * @param body the physics body to get the gravity factor from\r\n     * @param instanceIndex the index of the instance in an instanced body. If not specified, the gravity factor of the first instance will be returned.\r\n     * @returns the gravity factor\r\n     */\r\n    public getGravityFactor(body: PhysicsBody, instanceIndex?: number): number {\r\n        const pluginRef = this._getPluginReference(body, instanceIndex);\r\n        return this._hknp.HP_Body_GetGravityFactor(pluginRef.hpBodyId)[1];\r\n    }\r\n\r\n    /**\r\n     * Disposes a physics body.\r\n     *\r\n     * @param body - The physics body to dispose.\r\n     *\r\n     * This method is useful for releasing the resources associated with a physics body when it is no longer needed.\r\n     * This is important for avoiding memory leaks in the physics engine.\r\n     */\r\n    public disposeBody(body: PhysicsBody): void {\r\n        if (body._pluginDataInstances && body._pluginDataInstances.length > 0) {\r\n            for (const instance of body._pluginDataInstances) {\r\n                this._hknp.HP_Body_Release(instance.hpBodyId);\r\n                instance.hpBodyId = undefined;\r\n            }\r\n        }\r\n        if (body._pluginData) {\r\n            this._hknp.HP_Body_Release(body._pluginData.hpBodyId);\r\n            body._pluginData.hpBodyId = undefined;\r\n        }\r\n    }\r\n\r\n    private _createOptionsFromGroundMesh(options: PhysicsShapeParameters) {\r\n        const mesh = options.groundMesh;\r\n        if (!mesh) {\r\n            return;\r\n        }\r\n        let pos = <FloatArray>mesh.getVerticesData(VertexBuffer.PositionKind);\r\n        const transform = mesh.computeWorldMatrix(true);\r\n        // convert rawVerts to object space\r\n        const transformedVertices: number[] = [];\r\n        let index: number;\r\n        for (index = 0; index < pos.length; index += 3) {\r\n            Vector3.FromArrayToRef(pos, index, TmpVectors.Vector3[0]);\r\n            Vector3.TransformCoordinatesToRef(TmpVectors.Vector3[0], transform, TmpVectors.Vector3[1]);\r\n            TmpVectors.Vector3[1].toArray(transformedVertices, index);\r\n        }\r\n        pos = transformedVertices;\r\n\r\n        const arraySize = ~~(Math.sqrt(pos.length / 3) - 1);\r\n        const boundingInfo = mesh.getBoundingInfo();\r\n        const dim = Math.min(boundingInfo.boundingBox.extendSizeWorld.x, boundingInfo.boundingBox.extendSizeWorld.z);\r\n        const minX = boundingInfo.boundingBox.minimumWorld.x;\r\n        const minY = boundingInfo.boundingBox.minimumWorld.y;\r\n        const minZ = boundingInfo.boundingBox.minimumWorld.z;\r\n\r\n        const matrix = new Float32Array((arraySize + 1) * (arraySize + 1));\r\n\r\n        const elementSize = (dim * 2) / arraySize;\r\n\r\n        for (let i = 0; i < matrix.length; i++) {\r\n            matrix[i] = minY;\r\n        }\r\n        for (let i = 0; i < pos.length; i = i + 3) {\r\n            const x = Math.round((pos[i + 0] - minX) / elementSize);\r\n            const z = arraySize - Math.round((pos[i + 2] - minZ) / elementSize);\r\n            const y = pos[i + 1] - minY;\r\n\r\n            matrix[z * (arraySize + 1) + x] = y;\r\n        }\r\n\r\n        options.numHeightFieldSamplesX = arraySize + 1;\r\n        options.numHeightFieldSamplesZ = arraySize + 1;\r\n        options.heightFieldSizeX = boundingInfo.boundingBox.extendSizeWorld.x * 2;\r\n        options.heightFieldSizeZ = boundingInfo.boundingBox.extendSizeWorld.z * 2;\r\n        options.heightFieldData = matrix;\r\n    }\r\n\r\n    /**\r\n     * Initializes a physics shape with the given type and parameters.\r\n     * @param shape - The physics shape to initialize.\r\n     * @param type - The type of shape to initialize.\r\n     * @param options - The parameters for the shape.\r\n     *\r\n     * This code is useful for initializing a physics shape with the given type and parameters.\r\n     * It allows for the creation of a sphere, box, capsule, container, cylinder, mesh, and heightfield.\r\n     * Depending on the type of shape, different parameters are required.\r\n     * For example, a sphere requires a radius, while a box requires extents and a rotation.\r\n     */\r\n    public initShape(shape: PhysicsShape, type: PhysicsShapeType, options: PhysicsShapeParameters): void {\r\n        switch (type) {\r\n            case PhysicsShapeType.SPHERE:\r\n                {\r\n                    const radius = options.radius || 1;\r\n                    const center = options.center ? this._bVecToV3(options.center) : [0, 0, 0];\r\n                    shape._pluginData = this._hknp.HP_Shape_CreateSphere(center, radius)[1];\r\n                }\r\n                break;\r\n            case PhysicsShapeType.BOX:\r\n                {\r\n                    const rotation = options.rotation ? this._bQuatToV4(options.rotation) : [0, 0, 0, 1];\r\n                    const extent = options.extents ? this._bVecToV3(options.extents) : [1, 1, 1];\r\n                    const center = options.center ? this._bVecToV3(options.center) : [0, 0, 0];\r\n                    shape._pluginData = this._hknp.HP_Shape_CreateBox(center, rotation, extent)[1];\r\n                }\r\n                break;\r\n            case PhysicsShapeType.CAPSULE:\r\n                {\r\n                    const pointA = options.pointA ? this._bVecToV3(options.pointA) : [0, 0, 0];\r\n                    const pointB = options.pointB ? this._bVecToV3(options.pointB) : [0, 1, 0];\r\n                    const radius = options.radius || 0;\r\n                    shape._pluginData = this._hknp.HP_Shape_CreateCapsule(pointA, pointB, radius)[1];\r\n                }\r\n                break;\r\n            case PhysicsShapeType.CONTAINER:\r\n                {\r\n                    shape._pluginData = this._hknp.HP_Shape_CreateContainer()[1];\r\n                }\r\n                break;\r\n            case PhysicsShapeType.CYLINDER:\r\n                {\r\n                    const pointA = options.pointA ? this._bVecToV3(options.pointA) : [0, 0, 0];\r\n                    const pointB = options.pointB ? this._bVecToV3(options.pointB) : [0, 1, 0];\r\n                    const radius = options.radius || 0;\r\n                    shape._pluginData = this._hknp.HP_Shape_CreateCylinder(pointA, pointB, radius)[1];\r\n                }\r\n                break;\r\n            case PhysicsShapeType.CONVEX_HULL:\r\n            case PhysicsShapeType.MESH:\r\n                {\r\n                    const mesh = options.mesh;\r\n                    if (mesh) {\r\n                        const includeChildMeshes = !!options.includeChildMeshes;\r\n                        const needIndices = type != PhysicsShapeType.CONVEX_HULL;\r\n                        const accum = new MeshAccumulator(mesh, needIndices, mesh?.getScene());\r\n                        accum.addNodeMeshes(mesh, includeChildMeshes);\r\n\r\n                        const positions = accum.getVertices(this._hknp);\r\n                        const numVec3s = positions.numObjects / 3;\r\n\r\n                        if (type == PhysicsShapeType.CONVEX_HULL) {\r\n                            shape._pluginData = this._hknp.HP_Shape_CreateConvexHull(positions.offset, numVec3s)[1];\r\n                        } else {\r\n                            const triangles = accum.getTriangles(this._hknp);\r\n                            const numTriangles = triangles.numObjects / 3;\r\n                            shape._pluginData = this._hknp.HP_Shape_CreateMesh(positions.offset, numVec3s, triangles.offset, numTriangles)[1];\r\n                            accum.freeBuffer(this._hknp, triangles);\r\n                        }\r\n                        accum.freeBuffer(this._hknp, positions);\r\n                    } else {\r\n                        throw new Error(\"No mesh provided to create physics shape.\");\r\n                    }\r\n                }\r\n                break;\r\n            case PhysicsShapeType.HEIGHTFIELD:\r\n                {\r\n                    if (options.groundMesh) {\r\n                        // update options with datas from groundMesh\r\n                        this._createOptionsFromGroundMesh(options);\r\n                    }\r\n                    if (options.numHeightFieldSamplesX && options.numHeightFieldSamplesZ && options.heightFieldSizeX && options.heightFieldSizeZ && options.heightFieldData) {\r\n                        const totalNumHeights = options.numHeightFieldSamplesX * options.numHeightFieldSamplesZ;\r\n                        const numBytes = totalNumHeights * 4;\r\n                        const bufferBegin = this._hknp._malloc(numBytes);\r\n\r\n                        const heightBuffer = new Float32Array(this._hknp.HEAPU8.buffer, bufferBegin, totalNumHeights);\r\n                        for (let x = 0; x < options.numHeightFieldSamplesX; x++) {\r\n                            for (let z = 0; z < options.numHeightFieldSamplesZ; z++) {\r\n                                const hkBufferIndex = z * options.numHeightFieldSamplesX + x;\r\n                                const bjsBufferIndex = (options.numHeightFieldSamplesX - 1 - x) * options.numHeightFieldSamplesZ + z;\r\n                                heightBuffer[hkBufferIndex] = options.heightFieldData[bjsBufferIndex];\r\n                            }\r\n                        }\r\n\r\n                        const scaleX = options.heightFieldSizeX / (options.numHeightFieldSamplesX - 1);\r\n                        const scaleZ = options.heightFieldSizeZ / (options.numHeightFieldSamplesZ - 1);\r\n                        shape._pluginData = this._hknp.HP_Shape_CreateHeightField(\r\n                            options.numHeightFieldSamplesX,\r\n                            options.numHeightFieldSamplesZ,\r\n                            [scaleX, 1, scaleZ],\r\n                            bufferBegin\r\n                        )[1];\r\n\r\n                        this._hknp._free(bufferBegin);\r\n                    } else {\r\n                        throw new Error(\"Missing required heightfield parameters\");\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                throw new Error(\"Unsupported Shape Type.\");\r\n                break;\r\n        }\r\n\r\n        this._shapes.set(shape._pluginData[0], shape);\r\n    }\r\n\r\n    /**\r\n     * Sets the shape filter membership mask of a body\r\n     * @param shape - The physics body to set the shape filter membership mask for.\r\n     * @param membershipMask - The shape filter membership mask to set.\r\n     */\r\n    public setShapeFilterMembershipMask(shape: PhysicsShape, membershipMask: number): void {\r\n        const collideWith = this._hknp.HP_Shape_GetFilterInfo(shape._pluginData)[1][1];\r\n        this._hknp.HP_Shape_SetFilterInfo(shape._pluginData, [membershipMask, collideWith]);\r\n    }\r\n\r\n    /**\r\n     * Gets the shape filter membership mask of a body\r\n     * @param shape - The physics body to get the shape filter membership mask from.\r\n     * @returns The shape filter membership mask of the given body.\r\n     */\r\n    public getShapeFilterMembershipMask(shape: PhysicsShape): number {\r\n        return this._hknp.HP_Shape_GetFilterInfo(shape._pluginData)[1][0];\r\n    }\r\n\r\n    /**\r\n     * Sets the shape filter collide mask of a body\r\n     * @param shape - The physics body to set the shape filter collide mask for.\r\n     * @param collideMask - The shape filter collide mask to set.\r\n     */\r\n    public setShapeFilterCollideMask(shape: PhysicsShape, collideMask: number): void {\r\n        const membership = this._hknp.HP_Shape_GetFilterInfo(shape._pluginData)[1][0];\r\n        this._hknp.HP_Shape_SetFilterInfo(shape._pluginData, [membership, collideMask]);\r\n    }\r\n\r\n    /**\r\n     * Gets the shape filter collide mask of a body\r\n     * @param shape - The physics body to get the shape filter collide mask from.\r\n     * @returns The shape filter collide mask of the given body.\r\n     */\r\n    public getShapeFilterCollideMask(shape: PhysicsShape): number {\r\n        return this._hknp.HP_Shape_GetFilterInfo(shape._pluginData)[1][1];\r\n    }\r\n\r\n    /**\r\n     * Sets the material of a physics shape.\r\n     * @param shape - The physics shape to set the material of.\r\n     * @param material - The material to set.\r\n     *\r\n     */\r\n    public setMaterial(shape: PhysicsShape, material: PhysicsMaterial): void {\r\n        const dynamicFriction = material.friction ?? 0.5;\r\n        const staticFriction = material.staticFriction ?? dynamicFriction;\r\n        const restitution = material.restitution ?? 0.0;\r\n        const frictionCombine = material.frictionCombine ?? PhysicsMaterialCombineMode.MINIMUM;\r\n        const restitutionCombine = material.restitutionCombine ?? PhysicsMaterialCombineMode.MAXIMUM;\r\n\r\n        const hpMaterial = [staticFriction, dynamicFriction, restitution, this._materialCombineToNative(frictionCombine), this._materialCombineToNative(restitutionCombine)];\r\n        this._hknp.HP_Shape_SetMaterial(shape._pluginData, hpMaterial);\r\n    }\r\n\r\n    /**\r\n     * Gets the material associated with a physics shape.\r\n     * @param shape - The shape to get the material from.\r\n     * @returns The material associated with the shape.\r\n     */\r\n    public getMaterial(shape: PhysicsShape): PhysicsMaterial {\r\n        const hkMaterial = this._hknp.HP_Shape_GetMaterial(shape._pluginData)[1];\r\n        return {\r\n            staticFriction: hkMaterial[0],\r\n            friction: hkMaterial[1],\r\n            restitution: hkMaterial[2],\r\n            frictionCombine: this._nativeToMaterialCombine(hkMaterial[3]),\r\n            restitutionCombine: this._nativeToMaterialCombine(hkMaterial[4]),\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Sets the density of a physics shape.\r\n     * @param shape - The physics shape to set the density of.\r\n     * @param density - The density to set.\r\n     *\r\n     */\r\n    public setDensity(shape: PhysicsShape, density: number): void {\r\n        this._hknp.HP_Shape_SetDensity(shape._pluginData, density);\r\n    }\r\n\r\n    /**\r\n     * Calculates the density of a given physics shape.\r\n     *\r\n     * @param shape - The physics shape to calculate the density of.\r\n     * @returns The density of the given physics shape.\r\n     *\r\n     */\r\n    public getDensity(shape: PhysicsShape): number {\r\n        return this._hknp.HP_Shape_GetDensity(shape._pluginData)[1];\r\n    }\r\n\r\n    /**\r\n     * Gets the transform infos of a given transform node.\r\n     * This code is useful for getting the position and orientation of a given transform node.\r\n     * It first checks if the node has a rotation quaternion, and if not, it creates one from the node's rotation.\r\n     * It then creates an array containing the position and orientation of the node and returns it.\r\n     * @param node - The transform node.\r\n     * @param offset - The floating origin offset to apply.\r\n     * @returns An array containing the position and orientation of the node.\r\n     */\r\n    private _getTransformInfos(node: TransformNode, offset?: Vector3): any[] {\r\n        if (node.parent) {\r\n            node.computeWorldMatrix(true);\r\n            return [this._bVecToV3WithOffset(node.absolutePosition, offset), this._bQuatToV4(node.absoluteRotationQuaternion)];\r\n        }\r\n\r\n        let orientation = TmpVectors.Quaternion[0];\r\n        if (node.rotationQuaternion) {\r\n            orientation = node.rotationQuaternion;\r\n        } else {\r\n            const r = node.rotation;\r\n            Quaternion.FromEulerAnglesToRef(r.x, r.y, r.z, orientation);\r\n        }\r\n        const transform = [this._bVecToV3WithOffset(node.position, offset), this._bQuatToV4(orientation)];\r\n        return transform;\r\n    }\r\n\r\n    /**\r\n     * Adds a child shape to the given shape.\r\n     * @param shape - The parent shape.\r\n     * @param newChild - The child shape to add.\r\n     * @param translation - The relative translation of the child from the parent shape\r\n     * @param rotation - The relative rotation of the child from the parent shape\r\n     * @param scale - The relative scale scale of the child from the parent shaep\r\n     *\r\n     */\r\n    public addChild(shape: PhysicsShape, newChild: PhysicsShape, translation?: Vector3, rotation?: Quaternion, scale?: Vector3): void {\r\n        const transformNative = [\r\n            translation ? this._bVecToV3(translation) : [0, 0, 0],\r\n            rotation ? this._bQuatToV4(rotation) : [0, 0, 0, 1],\r\n            scale ? this._bVecToV3(scale) : [1, 1, 1],\r\n        ];\r\n        this._hknp.HP_Shape_AddChild(shape._pluginData, newChild._pluginData, transformNative);\r\n    }\r\n\r\n    /**\r\n     * Removes a child shape from a parent shape.\r\n     * @param shape - The parent shape.\r\n     * @param childIndex - The index of the child shape to remove.\r\n     *\r\n     */\r\n    public removeChild(shape: PhysicsShape, childIndex: number): void {\r\n        this._hknp.HP_Shape_RemoveChild(shape._pluginData, childIndex);\r\n    }\r\n\r\n    /**\r\n     * Returns the number of children of the given shape.\r\n     *\r\n     * @param shape - The shape to get the number of children from.\r\n     * @returns The number of children of the given shape.\r\n     *\r\n     */\r\n    public getNumChildren(shape: PhysicsShape): number {\r\n        return this._hknp.HP_Shape_GetNumChildren(shape._pluginData)[1];\r\n    }\r\n\r\n    /**\r\n     * Marks the shape as a trigger\r\n     * @param shape the shape to mark as a trigger\r\n     * @param isTrigger if the shape is a trigger\r\n     */\r\n    public setTrigger(shape: PhysicsShape, isTrigger: boolean): void {\r\n        this._hknp.HP_Shape_SetTrigger(shape._pluginData, isTrigger);\r\n    }\r\n\r\n    /**\r\n     * Calculates the bounding box of a given physics shape.\r\n     *\r\n     * @param _shape - The physics shape to calculate the bounding box for.\r\n     * @returns The calculated bounding box.\r\n     *\r\n     * This method is useful for physics engines as it allows to calculate the\r\n     * boundaries of a given shape. Knowing the boundaries of a shape is important\r\n     * for collision detection and other physics calculations.\r\n     */\r\n    public getBoundingBox(_shape: PhysicsShape): BoundingBox {\r\n        // get local AABB\r\n        const aabb = this._hknp.HP_Shape_GetBoundingBox(_shape._pluginData, [\r\n            [0, 0, 0],\r\n            [0, 0, 0, 1],\r\n        ])[1];\r\n        TmpVectors.Vector3[0].set(aabb[0][0], aabb[0][1], aabb[0][2]); // min\r\n        TmpVectors.Vector3[1].set(aabb[1][0], aabb[1][1], aabb[1][2]); // max\r\n        const boundingbox = new BoundingBox(TmpVectors.Vector3[0], TmpVectors.Vector3[1], Matrix.IdentityReadOnly);\r\n        return boundingbox;\r\n    }\r\n\r\n    /**\r\n     * Calculates the world bounding box of a given physics body.\r\n     *\r\n     * @param body - The physics body to calculate the bounding box for.\r\n     * @returns The calculated bounding box.\r\n     *\r\n     * This method is useful for physics engines as it allows to calculate the\r\n     * boundaries of a given body.\r\n     */\r\n    public getBodyBoundingBox(body: PhysicsBody): BoundingBox {\r\n        // get local AABB\r\n        const aabb = this.getBoundingBox(body.shape!);\r\n        const boundingbox = new BoundingBox(aabb.minimum, aabb.maximum, body.transformNode.getWorldMatrix());\r\n        return boundingbox;\r\n    }\r\n\r\n    /**\r\n     * Gets the geometry of a physics body.\r\n     *\r\n     * @param body - The physics body.\r\n     * @returns An object containing the positions and indices of the body's geometry.\r\n     *\r\n     */\r\n    public getBodyGeometry(body: PhysicsBody): {\r\n        positions: Float32Array | number[];\r\n        indices: Uint32Array | number[];\r\n    } {\r\n        const dataInfo = body._pluginDataInstances?.length > 0 ? body._pluginDataInstances[0] : body._pluginData;\r\n        const shape = this._hknp.HP_Body_GetShape(dataInfo.hpBodyId)[1];\r\n        const geometryRes = this._hknp.HP_Shape_CreateDebugDisplayGeometry(shape);\r\n\r\n        if (geometryRes[0] != this._hknp.Result.RESULT_OK) {\r\n            return { positions: [], indices: [] };\r\n        }\r\n\r\n        const geometryInfo = this._hknp.HP_DebugGeometry_GetInfo(geometryRes[1])[1];\r\n        const positionsInPlugin = new Float32Array(this._hknp.HEAPU8.buffer, geometryInfo[0], geometryInfo[1] * 3); // 3 floats per position\r\n        const indicesInPlugin = new Uint32Array(this._hknp.HEAPU8.buffer, geometryInfo[2], geometryInfo[3] * 3); // 3 indices per triangle\r\n\r\n        // HP_DebugGeometry_Release will free the buffer in the plugin. To avoid a\r\n        // use-after-free, we need  to make a copy of the data here.\r\n        const positions = positionsInPlugin.slice(0);\r\n        const indices = indicesInPlugin.slice(0);\r\n        this._hknp.HP_DebugGeometry_Release(geometryRes[1]);\r\n        return { positions: positions, indices: indices };\r\n    }\r\n\r\n    /**\r\n     * Releases a physics shape from the physics engine.\r\n     *\r\n     * @param shape - The physics shape to be released.\r\n     *\r\n     * This method is useful for releasing a physics shape from the physics engine, freeing up resources and preventing memory leaks.\r\n     */\r\n    public disposeShape(shape: PhysicsShape): void {\r\n        this._shapes.delete(shape._pluginData[0]);\r\n        this._hknp.HP_Shape_Release(shape._pluginData);\r\n        shape._pluginData = undefined;\r\n    }\r\n\r\n    // constraint\r\n\r\n    /**\r\n     * Initializes a physics constraint with the given parameters.\r\n     *\r\n     * @param constraint - The physics constraint to be initialized.\r\n     * @param body - The main body\r\n     * @param childBody - The child body.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\r\n     * @param childInstanceIndex - If the child body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\r\n     *\r\n     * This function is useful for setting up a physics constraint in a physics engine.\r\n     */\r\n    public initConstraint(constraint: PhysicsConstraint, body: PhysicsBody, childBody: PhysicsBody, instanceIndex?: number, childInstanceIndex?: number): void {\r\n        const type = constraint.type;\r\n        const options = constraint.options;\r\n        if (!type || !options) {\r\n            Logger.Warn(\"No constraint type or options. Constraint is invalid.\");\r\n            return;\r\n        }\r\n        if ((body._pluginDataInstances.length > 0 && instanceIndex === undefined) || (childBody._pluginDataInstances.length > 0 && childInstanceIndex === undefined)) {\r\n            Logger.Warn(\"Body is instanced but no instance index was specified. Constraint will not be applied.\");\r\n            return;\r\n        }\r\n\r\n        constraint._pluginData = constraint._pluginData ?? [];\r\n        const jointId = this._hknp.HP_Constraint_Create()[1];\r\n        constraint._pluginData.push(jointId);\r\n\r\n        // body parenting\r\n        const bodyA = this._getPluginReference(body, instanceIndex).hpBodyId;\r\n        const bodyB = this._getPluginReference(childBody, childInstanceIndex).hpBodyId;\r\n        this._hknp.HP_Constraint_SetParentBody(jointId, bodyA);\r\n        this._hknp.HP_Constraint_SetChildBody(jointId, bodyB);\r\n\r\n        this._constraintToBodyIdPair.set(jointId[0], [bodyA[0], bodyB[0]]);\r\n\r\n        // anchors\r\n        const pivotA = options.pivotA ? this._bVecToV3(options.pivotA) : this._bVecToV3(Vector3.Zero());\r\n        const axisA = options.axisA ?? new Vector3(1, 0, 0);\r\n        const perpAxisA = this._tmpVec3[0];\r\n        if (options.perpAxisA) {\r\n            perpAxisA.copyFrom(options.perpAxisA);\r\n        } else {\r\n            axisA.getNormalToRef(perpAxisA);\r\n        }\r\n        this._hknp.HP_Constraint_SetAnchorInParent(jointId, pivotA, this._bVecToV3(axisA), this._bVecToV3(perpAxisA));\r\n        const pivotB = options.pivotB ? this._bVecToV3(options.pivotB) : this._bVecToV3(Vector3.Zero());\r\n        const axisB = options.axisB ?? new Vector3(1, 0, 0);\r\n        const perpAxisB = this._tmpVec3[0];\r\n        if (options.perpAxisB) {\r\n            perpAxisB.copyFrom(options.perpAxisB);\r\n        } else {\r\n            axisB.getNormalToRef(perpAxisB);\r\n        }\r\n        this._hknp.HP_Constraint_SetAnchorInChild(jointId, pivotB, this._bVecToV3(axisB), this._bVecToV3(perpAxisB));\r\n\r\n        // Save the options that were used for initializing the constraint for debugging purposes\r\n        // Check first to avoid copying the same options multiple times\r\n        if (!constraint._initOptions) {\r\n            constraint._initOptions = {\r\n                axisA: axisA.clone(),\r\n                axisB: axisB.clone(),\r\n                perpAxisA: perpAxisA.clone(),\r\n                perpAxisB: perpAxisB.clone(),\r\n                pivotA: new Vector3(pivotA[0], pivotA[1], pivotA[2]),\r\n                pivotB: new Vector3(pivotB[0], pivotB[1], pivotB[2]),\r\n            };\r\n        }\r\n\r\n        if (type == PhysicsConstraintType.LOCK) {\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_X, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_X, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n        } else if (type == PhysicsConstraintType.DISTANCE) {\r\n            const distance = options.maxDistance || 0;\r\n            const dist3d = this._hknp.ConstraintAxis.LINEAR_DISTANCE;\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, dist3d, this._hknp.ConstraintAxisLimitMode.LIMITED);\r\n            this._hknp.HP_Constraint_SetAxisMinLimit(jointId, dist3d, distance);\r\n            this._hknp.HP_Constraint_SetAxisMaxLimit(jointId, dist3d, distance);\r\n        } else if (type == PhysicsConstraintType.HINGE) {\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_X, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n        } else if (type == PhysicsConstraintType.PRISMATIC) {\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_X, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n        } else if (type == PhysicsConstraintType.SLIDER) {\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.ANGULAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n        } else if (type == PhysicsConstraintType.BALL_AND_SOCKET) {\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_X, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Y, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._hknp.ConstraintAxis.LINEAR_Z, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n        } else if (type == PhysicsConstraintType.SIX_DOF) {\r\n            const sixdofData: Physics6DoFConstraint = <Physics6DoFConstraint>constraint;\r\n            for (const l of sixdofData.limits) {\r\n                const axId = this._constraintAxisToNative(l.axis);\r\n                if ((l.minLimit ?? -1) == 0 && (l.maxLimit ?? -1) == 0) {\r\n                    this._hknp.HP_Constraint_SetAxisMode(jointId, axId, this._hknp.ConstraintAxisLimitMode.LOCKED);\r\n                } else {\r\n                    if (l.minLimit != undefined) {\r\n                        this._hknp.HP_Constraint_SetAxisMode(jointId, axId, this._hknp.ConstraintAxisLimitMode.LIMITED);\r\n                        this._hknp.HP_Constraint_SetAxisMinLimit(jointId, axId, l.minLimit);\r\n                    }\r\n\r\n                    if (l.maxLimit != undefined) {\r\n                        this._hknp.HP_Constraint_SetAxisMode(jointId, axId, this._hknp.ConstraintAxisLimitMode.LIMITED);\r\n                        this._hknp.HP_Constraint_SetAxisMaxLimit(jointId, axId, l.maxLimit);\r\n                    }\r\n                }\r\n                if (l.stiffness) {\r\n                    this._hknp.HP_Constraint_SetAxisStiffness(jointId, axId, l.stiffness);\r\n                }\r\n                if (l.damping) {\r\n                    this._hknp.HP_Constraint_SetAxisDamping(jointId, axId, l.damping);\r\n                }\r\n            }\r\n        } else {\r\n            throw new Error(\"Unsupported Constraint Type.\");\r\n        }\r\n\r\n        const collisionEnabled = !!options.collision;\r\n        this._hknp.HP_Constraint_SetCollisionsEnabled(jointId, collisionEnabled);\r\n        this._hknp.HP_Constraint_SetEnabled(jointId, true);\r\n    }\r\n\r\n    /**\r\n     * Get a list of all the pairs of bodies that are connected by this constraint.\r\n     * @param constraint the constraint to search from\r\n     * @returns a list of parent, child pairs\r\n     */\r\n    getBodiesUsingConstraint(constraint: PhysicsConstraint): ConstrainedBodyPair[] {\r\n        const pairs: ConstrainedBodyPair[] = [];\r\n        for (const jointId of constraint._pluginData) {\r\n            const bodyIds = this._constraintToBodyIdPair.get(jointId[0]);\r\n            if (bodyIds) {\r\n                const parentBodyInfo = this._bodies.get(bodyIds[0]);\r\n                const childBodyInfo = this._bodies.get(bodyIds[1]);\r\n                if (parentBodyInfo && childBodyInfo) {\r\n                    pairs.push({ parentBody: parentBodyInfo.body, parentBodyIndex: parentBodyInfo.index, childBody: childBodyInfo.body, childBodyIndex: childBodyInfo.index });\r\n                }\r\n            }\r\n        }\r\n        return pairs;\r\n    }\r\n\r\n    /**\r\n     * Adds a constraint to the physics engine.\r\n     *\r\n     * @param body - The main body to which the constraint is applied.\r\n     * @param childBody - The body to which the constraint is applied.\r\n     * @param constraint - The constraint to be applied.\r\n     * @param instanceIndex - If this body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\r\n     * @param childInstanceIndex - If the child body is instanced, the index of the instance to which the constraint will be applied. If not specified, no constraint will be applied.\r\n     */\r\n    addConstraint(body: PhysicsBody, childBody: PhysicsBody, constraint: PhysicsConstraint, instanceIndex?: number, childInstanceIndex?: number): void {\r\n        //<todo It's real weird that initConstraint() is called only after adding to a body!\r\n        this.initConstraint(constraint, body, childBody, instanceIndex, childInstanceIndex);\r\n    }\r\n\r\n    /**\r\n     * Enables or disables a constraint in the physics engine.\r\n     * @param constraint - The constraint to enable or disable.\r\n     * @param isEnabled - Whether the constraint should be enabled or disabled.\r\n     *\r\n     */\r\n    public setEnabled(constraint: PhysicsConstraint, isEnabled: boolean): void {\r\n        for (const jointId of constraint._pluginData) {\r\n            this._hknp.HP_Constraint_SetEnabled(jointId, isEnabled);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the enabled state of the given constraint.\r\n     * @param constraint - The constraint to get the enabled state from.\r\n     * @returns The enabled state of the given constraint.\r\n     *\r\n     */\r\n    public getEnabled(constraint: PhysicsConstraint): boolean {\r\n        const firstId = constraint._pluginData && constraint._pluginData[0];\r\n        if (firstId) {\r\n            return this._hknp.HP_Constraint_GetEnabled(firstId)[1];\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Enables or disables collisions for the given constraint.\r\n     * @param constraint - The constraint to enable or disable collisions for.\r\n     * @param isEnabled - Whether collisions should be enabled or disabled.\r\n     *\r\n     */\r\n    public setCollisionsEnabled(constraint: PhysicsConstraint, isEnabled: boolean): void {\r\n        for (const jointId of constraint._pluginData) {\r\n            this._hknp.HP_Constraint_SetCollisionsEnabled(jointId, isEnabled);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets whether collisions are enabled for the given constraint.\r\n     * @param constraint - The constraint to get collisions enabled for.\r\n     * @returns Whether collisions are enabled for the given constraint.\r\n     *\r\n     */\r\n    public getCollisionsEnabled(constraint: PhysicsConstraint): boolean {\r\n        const firstId = constraint._pluginData && constraint._pluginData[0];\r\n        if (firstId) {\r\n            return this._hknp.HP_Constraint_GetCollisionsEnabled(firstId)[1];\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Sets the friction of the given axis of the given constraint.\r\n     *\r\n     * @param constraint - The constraint to set the friction of.\r\n     * @param axis - The axis of the constraint to set the friction of.\r\n     * @param friction - The friction to set.\r\n     *\r\n     */\r\n    public setAxisFriction(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, friction: number): void {\r\n        for (const jointId of constraint._pluginData) {\r\n            this._hknp.HP_Constraint_SetAxisFriction(jointId, this._constraintAxisToNative(axis), friction);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the friction value of the specified axis of the given constraint.\r\n     *\r\n     * @param constraint - The constraint to get the axis friction from.\r\n     * @param axis - The axis to get the friction from.\r\n     * @returns The friction value of the specified axis.\r\n     *\r\n     */\r\n    public getAxisFriction(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): Nullable<number> {\r\n        const firstId = constraint._pluginData && constraint._pluginData[0];\r\n        if (firstId) {\r\n            return this._hknp.HP_Constraint_GetAxisFriction(firstId, this._constraintAxisToNative(axis))[1];\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the limit mode of the specified axis of the given constraint.\r\n     * @param constraint - The constraint to set the axis mode of.\r\n     * @param axis - The axis to set the limit mode of.\r\n     * @param limitMode - The limit mode to set.\r\n     */\r\n    public setAxisMode(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, limitMode: PhysicsConstraintAxisLimitMode): void {\r\n        for (const jointId of constraint._pluginData) {\r\n            this._hknp.HP_Constraint_SetAxisMode(jointId, this._constraintAxisToNative(axis), this._limitModeToNative(limitMode));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the axis limit mode of the given constraint.\r\n     *\r\n     * @param constraint - The constraint to get the axis limit mode from.\r\n     * @param axis - The axis to get the limit mode from.\r\n     * @returns The axis limit mode of the given constraint.\r\n     *\r\n     */\r\n    public getAxisMode(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): Nullable<PhysicsConstraintAxisLimitMode> {\r\n        const firstId = constraint._pluginData && constraint._pluginData[0];\r\n        if (firstId) {\r\n            const mode = this._hknp.HP_Constraint_GetAxisMode(firstId, this._constraintAxisToNative(axis))[1];\r\n            return this._nativeToLimitMode(mode);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the minimum limit of the given axis of the given constraint.\r\n     * @param constraint - The constraint to set the minimum limit of.\r\n     * @param axis - The axis to set the minimum limit of.\r\n     * @param limit - The minimum limit to set.\r\n     *\r\n     */\r\n    public setAxisMinLimit(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, limit: number): void {\r\n        for (const jointId of constraint._pluginData) {\r\n            this._hknp.HP_Constraint_SetAxisMinLimit(jointId, this._constraintAxisToNative(axis), limit);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the minimum limit of the specified axis of the given constraint.\r\n     * @param constraint - The constraint to get the minimum limit from.\r\n     * @param axis - The axis to get the minimum limit from.\r\n     * @returns The minimum limit of the specified axis of the given constraint.\r\n     *\r\n     */\r\n    public getAxisMinLimit(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): Nullable<number> {\r\n        const firstId = constraint._pluginData && constraint._pluginData[0];\r\n        if (firstId) {\r\n            return this._hknp.HP_Constraint_GetAxisMinLimit(firstId, this._constraintAxisToNative(axis))[1];\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum limit of the given axis of the given constraint.\r\n     * @param constraint - The constraint to set the maximum limit of the given axis.\r\n     * @param axis - The axis to set the maximum limit of.\r\n     * @param limit - The maximum limit to set.\r\n     *\r\n     */\r\n    public setAxisMaxLimit(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, limit: number): void {\r\n        for (const jointId of constraint._pluginData) {\r\n            this._hknp.HP_Constraint_SetAxisMaxLimit(jointId, this._constraintAxisToNative(axis), limit);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the maximum limit of the given axis of the given constraint.\r\n     *\r\n     * @param constraint - The constraint to get the maximum limit from.\r\n     * @param axis - The axis to get the maximum limit from.\r\n     * @returns The maximum limit of the given axis of the given constraint.\r\n     *\r\n     */\r\n    public getAxisMaxLimit(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): Nullable<number> {\r\n        const firstId = constraint._pluginData && constraint._pluginData[0];\r\n        if (firstId) {\r\n            return this._hknp.HP_Constraint_GetAxisMaxLimit(firstId, this._constraintAxisToNative(axis))[1];\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the motor type of the given axis of the given constraint.\r\n     * @param constraint - The constraint to set the motor type of.\r\n     * @param axis - The axis of the constraint to set the motor type of.\r\n     * @param motorType - The motor type to set.\r\n     *\r\n     */\r\n    public setAxisMotorType(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, motorType: PhysicsConstraintMotorType): void {\r\n        for (const jointId of constraint._pluginData) {\r\n            this._hknp.HP_Constraint_SetAxisMotorType(jointId, this._constraintAxisToNative(axis), this._constraintMotorTypeToNative(motorType));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the motor type of the specified axis of the given constraint.\r\n     * @param constraint - The constraint to get the motor type from.\r\n     * @param axis - The axis of the constraint to get the motor type from.\r\n     * @returns The motor type of the specified axis of the given constraint.\r\n     *\r\n     */\r\n    public getAxisMotorType(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): Nullable<PhysicsConstraintMotorType> {\r\n        const firstId = constraint._pluginData && constraint._pluginData[0];\r\n        if (firstId) {\r\n            return this._nativeToMotorType(this._hknp.HP_Constraint_GetAxisMotorType(firstId, this._constraintAxisToNative(axis))[1]);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the target of an axis motor of a constraint.\r\n     *\r\n     * @param constraint - The constraint to set the axis motor target of.\r\n     * @param axis - The axis of the constraint to set the motor target of.\r\n     * @param target - The target of the axis motor.\r\n     *\r\n     */\r\n    public setAxisMotorTarget(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, target: number): void {\r\n        for (const jointId of constraint._pluginData) {\r\n            this._hknp.HP_Constraint_SetAxisMotorTarget(jointId, this._constraintAxisToNative(axis), target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the target of the motor of the given axis of the given constraint.\r\n     *\r\n     * @param constraint - The constraint to get the motor target from.\r\n     * @param axis - The axis of the constraint to get the motor target from.\r\n     * @returns The target of the motor of the given axis of the given constraint.\r\n     *\r\n     */\r\n    public getAxisMotorTarget(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): Nullable<number> {\r\n        const firstId = constraint._pluginData && constraint._pluginData[0];\r\n        if (firstId) {\r\n            return this._hknp.HP_Constraint_GetAxisMotorTarget(constraint._pluginData, this._constraintAxisToNative(axis))[1];\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Sets the maximum force that can be applied by the motor of the given constraint axis.\r\n     * @param constraint - The constraint to set the motor max force for.\r\n     * @param axis - The axis of the constraint to set the motor max force for.\r\n     * @param maxForce - The maximum force that can be applied by the motor.\r\n     *\r\n     */\r\n    public setAxisMotorMaxForce(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis, maxForce: number): void {\r\n        for (const jointId of constraint._pluginData) {\r\n            this._hknp.HP_Constraint_SetAxisMotorMaxForce(jointId, this._constraintAxisToNative(axis), maxForce);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the maximum force of the motor of the given constraint axis.\r\n     *\r\n     * @param constraint - The constraint to get the motor maximum force from.\r\n     * @param axis - The axis of the constraint to get the motor maximum force from.\r\n     * @returns The maximum force of the motor of the given constraint axis.\r\n     *\r\n     */\r\n    public getAxisMotorMaxForce(constraint: PhysicsConstraint, axis: PhysicsConstraintAxis): Nullable<number> {\r\n        const firstId = constraint._pluginData && constraint._pluginData[0];\r\n        if (firstId) {\r\n            return this._hknp.HP_Constraint_GetAxisMotorMaxForce(firstId, this._constraintAxisToNative(axis))[1];\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Disposes a physics constraint.\r\n     *\r\n     * @param constraint - The physics constraint to dispose.\r\n     *\r\n     * This method is useful for releasing the resources associated with a physics constraint, such as\r\n     * the Havok constraint, when it is no longer needed. This is important for avoiding memory leaks.\r\n     */\r\n    public disposeConstraint(constraint: PhysicsConstraint): void {\r\n        for (const jointId of constraint._pluginData) {\r\n            this._hknp.HP_Constraint_SetEnabled(jointId, false);\r\n            this._hknp.HP_Constraint_Release(jointId);\r\n        }\r\n        constraint._pluginData.length = 0;\r\n    }\r\n\r\n    private _populateHitData(hitData: any, result: ProximityCastResult | PhysicsRaycastResult | ShapeCastResult): void {\r\n        const hitBody = this._bodies.get(hitData[0][0]);\r\n        result.body = hitBody?.body;\r\n        result.bodyIndex = hitBody?.index;\r\n        const hitShape = this._shapes.get(hitData[1][0]);\r\n        result.shape = hitShape;\r\n\r\n        const hitPos = hitData[3];\r\n        const hitNormal = hitData[4];\r\n        const hitTriangle = hitData[5];\r\n\r\n        // Add floating origin offset back to hit position using the hit body's world region offset\r\n        // If no hit body (shouldn't happen), use zero offset from default region\r\n        const offset = hitBody?.body?._pluginData?.worldRegion?.floatingOrigin ?? this._worldRegions[0].floatingOrigin;\r\n        result.setHitData({ x: hitNormal[0], y: hitNormal[1], z: hitNormal[2] }, { x: hitPos[0] + offset._x, y: hitPos[1] + offset._y, z: hitPos[2] + offset._z }, hitTriangle);\r\n    }\r\n\r\n    /**\r\n     * Performs a raycast from a given start point to a given end point and stores the result in a given PhysicsRaycastResult object.\r\n     *\r\n     * @param from - The start point of the raycast.\r\n     * @param to - The end point of the raycast.\r\n     * @param result - The PhysicsRaycastResult object (or array of PhysicsRaycastResults) to store the result of the raycast.\r\n     * @param query - The raycast query options. See [[IRaycastQuery]] for more information.\r\n     *\r\n     * Performs a raycast. It takes in two points, from and to, and a PhysicsRaycastResult object to store the result of the raycast.\r\n     * It then performs the raycast and stores the hit data in the PhysicsRaycastResult object.\r\n     * If result is an empty array, it will be populated with every detected raycast hit.\r\n     * If result is a populated array, it will only fill the PhysicsRaycastResults present in the array.\r\n     */\r\n    public raycast(from: Vector3, to: Vector3, result: PhysicsRaycastResult | Array<PhysicsRaycastResult>, query?: IRaycastQuery): void {\r\n        const queryMembership = query?.membership ?? ~0;\r\n        const queryCollideWith = query?.collideWith ?? ~0;\r\n        const shouldHitTriggers = query?.shouldHitTriggers ?? false;\r\n        const bodyToIgnore = query?.ignoreBody ? [BigInt(query.ignoreBody._pluginData.hpBodyId[0])] : [BigInt(0)];\r\n\r\n        const results = Array.isArray(result) ? result : [result];\r\n        for (const raycastResult of results) {\r\n            raycastResult.reset(from, to);\r\n        }\r\n\r\n        // Use the ignored body's world region if available, otherwise use default region\r\n        const worldRegion = query?.ignoreBody?._pluginData?.worldRegion ?? this._worldRegions[0];\r\n        const offset = worldRegion.floatingOrigin;\r\n        const world = worldRegion.world;\r\n        const offsetFrom = this._bVecToV3WithOffset(from, offset);\r\n        const offsetTo = this._bVecToV3WithOffset(to, offset);\r\n\r\n        const hkQuery = [offsetFrom, offsetTo, [queryMembership, queryCollideWith], shouldHitTriggers, bodyToIgnore];\r\n        const queryCollector = results.length === 1 || !this._multiQueryCollector ? this._queryCollector : this._multiQueryCollector;\r\n        this._hknp.HP_World_CastRayWithCollector(world, queryCollector, hkQuery);\r\n\r\n        const numHits = this._hknp.HP_QueryCollector_GetNumHits(queryCollector)[1];\r\n        if (numHits <= 0) {\r\n            return;\r\n        }\r\n\r\n        if (!results.length) {\r\n            for (let i = 0; i < numHits; i++) {\r\n                const raycastResult = new PhysicsRaycastResult();\r\n                raycastResult.reset(from, to);\r\n                results.push(raycastResult);\r\n            }\r\n        }\r\n\r\n        // QueryCollector results are not sorted by distance, so we need to sort them manually\r\n        const hitDatas: Array<{ hitData: any; distance: number }> = new Array(numHits);\r\n        for (let i = 0; i < numHits; i++) {\r\n            const [, hitData] = this._hknp.HP_QueryCollector_GetCastRayResult(queryCollector, i)[1];\r\n\r\n            const hitPos = hitData[3];\r\n            // Use offsetFrom for distance calculation since hitPos is in Havok's offset space\r\n            this._tmpVec3[0].set(offsetFrom[0] - hitPos[0], offsetFrom[1] - hitPos[1], offsetFrom[2] - hitPos[2]);\r\n            const distance = this._tmpVec3[0].lengthSquared();\r\n\r\n            hitDatas[i] = {\r\n                hitData,\r\n                distance: distance,\r\n            };\r\n        }\r\n\r\n        hitDatas.sort((a, b) => a.distance - b.distance);\r\n\r\n        for (let i = 0; i < Math.min(numHits, results.length); i++) {\r\n            const raycastResult = results[i];\r\n            const hitData = hitDatas[i];\r\n\r\n            this._populateHitData(hitData.hitData, raycastResult);\r\n            raycastResult.setHitDistance(Math.sqrt(hitData.distance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a point, returns the closest physics\r\n     * body to that point.\r\n     * @param query the query to perform. @see IPhysicsPointProximityQuery\r\n     * @param result contact point on the hit shape, in world space\r\n     */\r\n    public pointProximity(query: IPhysicsPointProximityQuery, result: ProximityCastResult): void {\r\n        const queryMembership = query?.collisionFilter?.membership ?? ~0;\r\n        const queryCollideWith = query?.collisionFilter?.collideWith ?? ~0;\r\n\r\n        result.reset();\r\n\r\n        const bodyToIgnore = query.ignoreBody ? [BigInt(query.ignoreBody._pluginData.hpBodyId[0])] : [BigInt(0)];\r\n        // Use the ignored body's world region if available, otherwise use default region\r\n        const worldRegion = query.ignoreBody?._pluginData?.worldRegion ?? this._worldRegions[0];\r\n        const offset = worldRegion.floatingOrigin;\r\n        const world = worldRegion.world;\r\n\r\n        const hkQuery = [this._bVecToV3WithOffset(query.position, offset), query.maxDistance, [queryMembership, queryCollideWith], query.shouldHitTriggers, bodyToIgnore];\r\n        this._hknp.HP_World_PointProximityWithCollector(world, this._queryCollector, hkQuery);\r\n\r\n        if (this._hknp.HP_QueryCollector_GetNumHits(this._queryCollector)[1] > 0) {\r\n            const [distance, hitData] = this._hknp.HP_QueryCollector_GetPointProximityResult(this._queryCollector, 0)[1];\r\n\r\n            this._populateHitData(hitData, result);\r\n            result.setHitDistance(distance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a shape in a specific position and orientation, returns the closest point to that shape.\r\n     * @param query the query to perform. @see IPhysicsShapeProximityCastQuery\r\n     * @param inputShapeResult contact point on input shape, in input shape space\r\n     * @param hitShapeResult contact point on hit shape, in world space\r\n     */\r\n    public shapeProximity(query: IPhysicsShapeProximityCastQuery, inputShapeResult: ProximityCastResult, hitShapeResult: ProximityCastResult): void {\r\n        inputShapeResult.reset();\r\n        hitShapeResult.reset();\r\n        const shapeId = query.shape._pluginData;\r\n        const bodyToIgnore = query.ignoreBody ? [BigInt(query.ignoreBody._pluginData.hpBodyId[0])] : [BigInt(0)];\r\n        // Use the ignored body's world region if available, otherwise use default region\r\n        const worldRegion = query.ignoreBody?._pluginData?.worldRegion ?? this._worldRegions[0];\r\n        const offset = worldRegion.floatingOrigin;\r\n        const world = worldRegion.world;\r\n\r\n        const hkQuery = [shapeId, this._bVecToV3WithOffset(query.position, offset), this._bQuatToV4(query.rotation), query.maxDistance, query.shouldHitTriggers, bodyToIgnore];\r\n        this._hknp.HP_World_ShapeProximityWithCollector(world, this._queryCollector, hkQuery);\r\n\r\n        if (this._hknp.HP_QueryCollector_GetNumHits(this._queryCollector)[1] > 0) {\r\n            const [distance, hitInputData, hitShapeData] = this._hknp.HP_QueryCollector_GetShapeProximityResult(this._queryCollector, 0)[1];\r\n\r\n            this._populateHitData(hitInputData, inputShapeResult);\r\n            this._populateHitData(hitShapeData, hitShapeResult);\r\n\r\n            inputShapeResult.setHitDistance(distance);\r\n            hitShapeResult.setHitDistance(distance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given a shape in a specific orientation, cast it from the start to end position specified by the query, and return the first hit.\r\n     * @param query the query to perform. @see IPhysicsShapeCastQuery\r\n     * @param inputShapeResult contact point on input shape, in input shape space\r\n     * @param hitShapeResult contact point on hit shape, in world space\r\n     */\r\n    public shapeCast(query: IPhysicsShapeCastQuery, inputShapeResult: ShapeCastResult, hitShapeResult: ShapeCastResult): void {\r\n        inputShapeResult.reset();\r\n        hitShapeResult.reset();\r\n\r\n        const shapeId = query.shape._pluginData;\r\n        const bodyToIgnore = query.ignoreBody ? [BigInt(query.ignoreBody._pluginData.hpBodyId[0])] : [BigInt(0)];\r\n        // Use the ignored body's world region if available, otherwise use default region\r\n        const worldRegion = query.ignoreBody?._pluginData?.worldRegion ?? this._worldRegions[0];\r\n        const offset = worldRegion.floatingOrigin;\r\n        const world = worldRegion.world;\r\n\r\n        const hkQuery = [\r\n            shapeId,\r\n            this._bQuatToV4(query.rotation),\r\n            this._bVecToV3WithOffset(query.startPosition, offset),\r\n            this._bVecToV3WithOffset(query.endPosition, offset),\r\n            query.shouldHitTriggers,\r\n            bodyToIgnore,\r\n        ];\r\n        this._hknp.HP_World_ShapeCastWithCollector(world, this._queryCollector, hkQuery);\r\n\r\n        if (this._hknp.HP_QueryCollector_GetNumHits(this._queryCollector)[1] > 0) {\r\n            const [fractionAlongRay, hitInputData, hitShapeData] = this._hknp.HP_QueryCollector_GetShapeCastResult(this._queryCollector, 0)[1];\r\n\r\n            this._populateHitData(hitInputData, inputShapeResult);\r\n            this._populateHitData(hitShapeData, hitShapeResult);\r\n\r\n            inputShapeResult.setHitFraction(fractionAlongRay);\r\n            hitShapeResult.setHitFraction(fractionAlongRay);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the collision observable for a particular physics body.\r\n     * @param body the physics body\r\n     * @returns the collision observable for the body\r\n     */\r\n    public getCollisionObservable(body: PhysicsBody): Observable<IPhysicsCollisionEvent> {\r\n        const bodyId = body._pluginData.hpBodyId[0];\r\n        let observable = this._bodyCollisionObservable.get(bodyId);\r\n        if (!observable) {\r\n            observable = new Observable<IPhysicsCollisionEvent>();\r\n            this._bodyCollisionObservable.set(bodyId, observable);\r\n        }\r\n        return observable;\r\n    }\r\n\r\n    /**\r\n     * Return the collision ended observable for a particular physics body.\r\n     * @param body the physics body\r\n     * @returns\r\n     */\r\n    public getCollisionEndedObservable(body: PhysicsBody): Observable<IBasePhysicsCollisionEvent> {\r\n        const bodyId = body._pluginData.hpBodyId[0];\r\n        let observable = this._bodyCollisionEndedObservable.get(bodyId);\r\n        if (!observable) {\r\n            observable = new Observable<IBasePhysicsCollisionEvent>();\r\n            this._bodyCollisionEndedObservable.set(bodyId, observable);\r\n        }\r\n        return observable;\r\n    }\r\n\r\n    /**\r\n     * Enable collision to be reported for a body when a callback is setup on the world\r\n     * @param body the physics body\r\n     * @param enabled whether to enable or disable collision events\r\n     */\r\n    public setCollisionCallbackEnabled(body: PhysicsBody, enabled: boolean): void {\r\n        // Register for collide events by default\r\n        const collideEvents = this._hknp.EventType.COLLISION_STARTED.value | this._hknp.EventType.COLLISION_CONTINUED.value | this._hknp.EventType.COLLISION_FINISHED.value;\r\n        if (body._pluginDataInstances && body._pluginDataInstances.length) {\r\n            for (let index = 0; index < body._pluginDataInstances.length; index++) {\r\n                const bodyId = body._pluginDataInstances[index];\r\n                this._hknp.HP_Body_SetEventMask(bodyId.hpBodyId, enabled ? collideEvents : 0);\r\n            }\r\n        } else if (body._pluginData) {\r\n            this._hknp.HP_Body_SetEventMask(body._pluginData.hpBodyId, enabled ? collideEvents : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enable collision ended to be reported for a body when a callback is setup on the world\r\n     * @param body the physics body\r\n     * @param enabled whether to enable or disable collision ended events\r\n     */\r\n    public setCollisionEndedCallbackEnabled(body: PhysicsBody, enabled: boolean): void {\r\n        // Register to collide ended events\r\n        const pluginRef = this._getPluginReference(body);\r\n        let currentCollideEvents = this._hknp.HP_Body_GetEventMask(pluginRef.hpBodyId)[1];\r\n        // update with the ended mask\r\n        currentCollideEvents = enabled\r\n            ? currentCollideEvents | this._hknp.EventType.COLLISION_FINISHED.value\r\n            : currentCollideEvents & ~this._hknp.EventType.COLLISION_FINISHED.value;\r\n        if (body._pluginDataInstances && body._pluginDataInstances.length) {\r\n            for (let index = 0; index < body._pluginDataInstances.length; index++) {\r\n                const bodyId = body._pluginDataInstances[index];\r\n                this._hknp.HP_Body_SetEventMask(bodyId.hpBodyId, currentCollideEvents);\r\n            }\r\n        } else if (body._pluginData) {\r\n            this._hknp.HP_Body_SetEventMask(body._pluginData.hpBodyId, currentCollideEvents);\r\n        }\r\n    }\r\n\r\n    private _notifyTriggers(world?: any) {\r\n        const targetWorld = world ?? this.world;\r\n        let eventAddress = this._hknp.HP_World_GetTriggerEvents(targetWorld)[1];\r\n        const event = new TriggerEvent();\r\n        while (eventAddress) {\r\n            TriggerEvent.readToRef(this._hknp.HEAPU8.buffer, eventAddress, event);\r\n\r\n            const bodyInfoA = this._bodies.get(event.bodyIdA);\r\n            const bodyInfoB = this._bodies.get(event.bodyIdB);\r\n\r\n            // Bodies may have been disposed between events. Check both still exist.\r\n            if (bodyInfoA && bodyInfoB) {\r\n                const triggerCollisionInfo: IBasePhysicsCollisionEvent = {\r\n                    collider: bodyInfoA.body,\r\n                    colliderIndex: bodyInfoA.index,\r\n                    collidedAgainst: bodyInfoB.body,\r\n                    collidedAgainstIndex: bodyInfoB.index,\r\n                    type: this._nativeTriggerCollisionValueToCollisionType(event.type),\r\n                };\r\n                this.onTriggerCollisionObservable.notifyObservers(triggerCollisionInfo);\r\n            }\r\n\r\n            eventAddress = this._hknp.HP_World_GetNextTriggerEvent(targetWorld, eventAddress);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Runs thru all detected collisions and filter by body\r\n     * @param world optional world to check collisions for (defaults to main world)\r\n     */\r\n    private _notifyCollisions(world?: any) {\r\n        const targetWorld = world ?? this.world;\r\n        let eventAddress = this._hknp.HP_World_GetCollisionEvents(targetWorld)[1];\r\n        const event = new CollisionEvent();\r\n        const worldAddr = Number(targetWorld);\r\n\r\n        // Find the region for this world to get the correct floating origin offset.\r\n        // All bodies in a collision share the same world, so use one offset for both.\r\n        const region = this._worldRegions.find((r) => Number(r.world) === worldAddr) ?? this._worldRegions[0];\r\n        const regionOffset = region.floatingOrigin;\r\n\r\n        while (eventAddress) {\r\n            CollisionEvent.readToRef(this._hknp.HEAPU8.buffer, eventAddress, event);\r\n            const bodyInfoA = this._bodies.get(event.contactOnA.bodyId);\r\n            const bodyInfoB = this._bodies.get(event.contactOnB.bodyId);\r\n\r\n            // Add floating origin offset back to collision contact positions.\r\n            // Both contacts are in the same world, so use the region's floating origin.\r\n            event.contactOnA.position.addInPlace(regionOffset);\r\n            event.contactOnB.position.addInPlace(regionOffset);\r\n\r\n            // Bodies may have been disposed between events. Check both still exist.\r\n            if (bodyInfoA && bodyInfoB) {\r\n                const collisionInfo: any = {\r\n                    collider: bodyInfoA.body,\r\n                    colliderIndex: bodyInfoA.index,\r\n                    collidedAgainst: bodyInfoB.body,\r\n                    collidedAgainstIndex: bodyInfoB.index,\r\n                    type: this._nativeCollisionValueToCollisionType(event.type),\r\n                };\r\n                if (collisionInfo.type === PhysicsEventType.COLLISION_FINISHED) {\r\n                    this.onCollisionEndedObservable.notifyObservers(collisionInfo);\r\n                } else {\r\n                    event.contactOnB.position.subtractToRef(event.contactOnA.position, this._tmpVec3[0]);\r\n                    const distance = Vector3.Dot(this._tmpVec3[0], event.contactOnA.normal);\r\n                    collisionInfo.point = event.contactOnA.position;\r\n                    collisionInfo.distance = distance;\r\n                    collisionInfo.impulse = event.impulseApplied;\r\n                    collisionInfo.normal = event.contactOnA.normal;\r\n                    this.onCollisionObservable.notifyObservers(collisionInfo);\r\n                }\r\n\r\n                if (this._bodyCollisionObservable.size && collisionInfo.type !== PhysicsEventType.COLLISION_FINISHED) {\r\n                    const observableA = this._bodyCollisionObservable.get(event.contactOnA.bodyId);\r\n                    const observableB = this._bodyCollisionObservable.get(event.contactOnB.bodyId);\r\n                    event.contactOnA.position.subtractToRef(event.contactOnB.position, this._tmpVec3[0]);\r\n                    const distance = Vector3.Dot(this._tmpVec3[0], event.contactOnB.normal);\r\n                    if (observableA) {\r\n                        observableA.notifyObservers(collisionInfo);\r\n                    }\r\n                    if (observableB) {\r\n                        const collisionInfoB: any = {\r\n                            collider: bodyInfoB.body,\r\n                            colliderIndex: bodyInfoB.index,\r\n                            collidedAgainst: bodyInfoA.body,\r\n                            collidedAgainstIndex: bodyInfoA.index,\r\n                            point: event.contactOnB.position,\r\n                            distance: distance,\r\n                            impulse: event.impulseApplied,\r\n                            normal: event.contactOnB.normal,\r\n                            type: this._nativeCollisionValueToCollisionType(event.type),\r\n                        };\r\n                        observableB.notifyObservers(collisionInfoB);\r\n                    }\r\n                } else if (this._bodyCollisionEndedObservable.size) {\r\n                    const observableA = this._bodyCollisionEndedObservable.get(event.contactOnA.bodyId);\r\n                    const observableB = this._bodyCollisionEndedObservable.get(event.contactOnB.bodyId);\r\n                    event.contactOnA.position.subtractToRef(event.contactOnB.position, this._tmpVec3[0]);\r\n                    const distance = Vector3.Dot(this._tmpVec3[0], event.contactOnB.normal);\r\n                    if (observableA) {\r\n                        observableA.notifyObservers(collisionInfo);\r\n                    }\r\n                    if (observableB) {\r\n                        const collisionInfoB: any = {\r\n                            collider: bodyInfoB.body,\r\n                            colliderIndex: bodyInfoB.index,\r\n                            collidedAgainst: bodyInfoA.body,\r\n                            collidedAgainstIndex: bodyInfoA.index,\r\n                            point: event.contactOnB.position,\r\n                            distance: distance,\r\n                            impulse: event.impulseApplied,\r\n                            normal: event.contactOnB.normal,\r\n                            type: this._nativeCollisionValueToCollisionType(event.type),\r\n                        };\r\n                        observableB.notifyObservers(collisionInfoB);\r\n                    }\r\n                }\r\n            }\r\n\r\n            eventAddress = this._hknp.HP_World_GetNextCollisionEvent(worldAddr, eventAddress);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the number of bodies in the world\r\n     */\r\n    public get numBodies() {\r\n        return this._hknp.HP_World_GetNumBodies(this.world)[1];\r\n    }\r\n\r\n    /**\r\n     * Dispose the world and free resources\r\n     */\r\n    public dispose(): void {\r\n        if (this._queryCollector) {\r\n            this._hknp.HP_QueryCollector_Release(this._queryCollector);\r\n            this._queryCollector = undefined;\r\n        }\r\n        if (this._multiQueryCollector) {\r\n            this._hknp.HP_QueryCollector_Release(this._multiQueryCollector);\r\n            this._multiQueryCollector = undefined;\r\n        }\r\n\r\n        // Dispose all world regions (includes the default world)\r\n        for (const region of this._worldRegions) {\r\n            if (region.world) {\r\n                this._hknp.HP_World_Release(region.world);\r\n            }\r\n        }\r\n        this._worldRegions.length = 0;\r\n        this.world = undefined;\r\n    }\r\n\r\n    private _v3ToBvecRef(v: any, vec3: Vector3): void {\r\n        vec3.set(v[0], v[1], v[2]);\r\n    }\r\n\r\n    private _bVecToV3(v: any): any {\r\n        return [v._x, v._y, v._z];\r\n    }\r\n\r\n    /**\r\n     * Converts a Vector3 to Havok format with floating origin offset subtracted.\r\n     * Use this for world-space positions being sent to Havok.\r\n     * @param v - The vector to convert\r\n     * @param offset - Optional offset to use. If not provided, no offset is applied.\r\n     * @returns The converted vector\r\n     */\r\n    private _bVecToV3WithOffset(v: Vector3, offset?: Vector3): any {\r\n        if (offset) {\r\n            return [v._x - offset._x, v._y - offset._y, v._z - offset._z];\r\n        }\r\n        return [v._x, v._y, v._z];\r\n    }\r\n\r\n    private _bQuatToV4(q: Quaternion): Array<number> {\r\n        return [q._x, q._y, q._z, q._w];\r\n    }\r\n\r\n    private _constraintMotorTypeToNative(motorType: PhysicsConstraintMotorType): any {\r\n        switch (motorType) {\r\n            case PhysicsConstraintMotorType.POSITION:\r\n                return this._hknp.ConstraintMotorType.POSITION;\r\n            case PhysicsConstraintMotorType.VELOCITY:\r\n                return this._hknp.ConstraintMotorType.VELOCITY;\r\n        }\r\n        return this._hknp.ConstraintMotorType.NONE;\r\n    }\r\n\r\n    private _nativeToMotorType(motorType: any): PhysicsConstraintMotorType {\r\n        switch (motorType) {\r\n            case this._hknp.ConstraintMotorType.POSITION:\r\n                return PhysicsConstraintMotorType.POSITION;\r\n            case this._hknp.ConstraintMotorType.VELOCITY:\r\n                return PhysicsConstraintMotorType.VELOCITY;\r\n        }\r\n        return PhysicsConstraintMotorType.NONE;\r\n    }\r\n\r\n    private _materialCombineToNative(mat: PhysicsMaterialCombineMode): any {\r\n        switch (mat) {\r\n            case PhysicsMaterialCombineMode.GEOMETRIC_MEAN:\r\n                return this._hknp.MaterialCombine.GEOMETRIC_MEAN;\r\n            case PhysicsMaterialCombineMode.MINIMUM:\r\n                return this._hknp.MaterialCombine.MINIMUM;\r\n            case PhysicsMaterialCombineMode.MAXIMUM:\r\n                return this._hknp.MaterialCombine.MAXIMUM;\r\n            case PhysicsMaterialCombineMode.ARITHMETIC_MEAN:\r\n                return this._hknp.MaterialCombine.ARITHMETIC_MEAN;\r\n            case PhysicsMaterialCombineMode.MULTIPLY:\r\n                return this._hknp.MaterialCombine.MULTIPLY;\r\n        }\r\n    }\r\n\r\n    private _nativeToMaterialCombine(mat: any): PhysicsMaterialCombineMode | undefined {\r\n        switch (mat) {\r\n            case this._hknp.MaterialCombine.GEOMETRIC_MEAN:\r\n                return PhysicsMaterialCombineMode.GEOMETRIC_MEAN;\r\n            case this._hknp.MaterialCombine.MINIMUM:\r\n                return PhysicsMaterialCombineMode.MINIMUM;\r\n            case this._hknp.MaterialCombine.MAXIMUM:\r\n                return PhysicsMaterialCombineMode.MAXIMUM;\r\n            case this._hknp.MaterialCombine.ARITHMETIC_MEAN:\r\n                return PhysicsMaterialCombineMode.ARITHMETIC_MEAN;\r\n            case this._hknp.MaterialCombine.MULTIPLY:\r\n                return PhysicsMaterialCombineMode.MULTIPLY;\r\n            default:\r\n                return undefined;\r\n        }\r\n    }\r\n\r\n    private _constraintAxisToNative(axId: PhysicsConstraintAxis): any {\r\n        switch (axId) {\r\n            case PhysicsConstraintAxis.LINEAR_X:\r\n                return this._hknp.ConstraintAxis.LINEAR_X;\r\n            case PhysicsConstraintAxis.LINEAR_Y:\r\n                return this._hknp.ConstraintAxis.LINEAR_Y;\r\n            case PhysicsConstraintAxis.LINEAR_Z:\r\n                return this._hknp.ConstraintAxis.LINEAR_Z;\r\n            case PhysicsConstraintAxis.ANGULAR_X:\r\n                return this._hknp.ConstraintAxis.ANGULAR_X;\r\n            case PhysicsConstraintAxis.ANGULAR_Y:\r\n                return this._hknp.ConstraintAxis.ANGULAR_Y;\r\n            case PhysicsConstraintAxis.ANGULAR_Z:\r\n                return this._hknp.ConstraintAxis.ANGULAR_Z;\r\n            case PhysicsConstraintAxis.LINEAR_DISTANCE:\r\n                return this._hknp.ConstraintAxis.LINEAR_DISTANCE;\r\n        }\r\n    }\r\n\r\n    private _nativeToLimitMode(mode: number): PhysicsConstraintAxisLimitMode {\r\n        switch (mode) {\r\n            case this._hknp.ConstraintAxisLimitMode.FREE:\r\n                return PhysicsConstraintAxisLimitMode.FREE;\r\n            case this._hknp.ConstraintAxisLimitMode.LIMITED:\r\n                return PhysicsConstraintAxisLimitMode.LIMITED;\r\n            case this._hknp.ConstraintAxisLimitMode.LOCKED:\r\n                return PhysicsConstraintAxisLimitMode.LOCKED;\r\n        }\r\n\r\n        return PhysicsConstraintAxisLimitMode.FREE;\r\n    }\r\n\r\n    private _limitModeToNative(mode: PhysicsConstraintAxisLimitMode): any {\r\n        switch (mode) {\r\n            case PhysicsConstraintAxisLimitMode.FREE:\r\n                return this._hknp.ConstraintAxisLimitMode.FREE;\r\n            case PhysicsConstraintAxisLimitMode.LIMITED:\r\n                return this._hknp.ConstraintAxisLimitMode.LIMITED;\r\n            case PhysicsConstraintAxisLimitMode.LOCKED:\r\n                return this._hknp.ConstraintAxisLimitMode.LOCKED;\r\n        }\r\n    }\r\n\r\n    private _nativeCollisionValueToCollisionType(type: number): PhysicsEventType {\r\n        switch (type) {\r\n            case this._hknp.EventType.COLLISION_STARTED.value:\r\n                return PhysicsEventType.COLLISION_STARTED;\r\n            case this._hknp.EventType.COLLISION_FINISHED.value:\r\n                return PhysicsEventType.COLLISION_FINISHED;\r\n            case this._hknp.EventType.COLLISION_CONTINUED.value:\r\n                return PhysicsEventType.COLLISION_CONTINUED;\r\n        }\r\n\r\n        return PhysicsEventType.COLLISION_STARTED;\r\n    }\r\n\r\n    private _nativeTriggerCollisionValueToCollisionType(type: number): PhysicsEventType {\r\n        switch (type) {\r\n            case 8:\r\n                return PhysicsEventType.TRIGGER_ENTERED;\r\n            case 16:\r\n                return PhysicsEventType.TRIGGER_EXITED;\r\n        }\r\n        return PhysicsEventType.TRIGGER_ENTERED;\r\n    }\r\n}\r\n"]}