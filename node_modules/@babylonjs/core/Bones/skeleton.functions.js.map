{"version":3,"file":"skeleton.functions.js","sourceRoot":"","sources":["../../../../dev/core/src/Bones/skeleton.functions.ts"],"names":[],"mappings":"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","sourcesContent":["import { Bone } from \"./bone\";\r\nimport { Matrix } from \"../Maths/math.vector\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { MeshBuilder } from \"core/Meshes/meshBuilder\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Skeleton } from \"./skeleton\";\r\n\r\n/**\r\n * Creates a skeleton from a hierarchy of transform nodes by converting each node into a bone.\r\n * Each transform node in the hierarchy will be linked to its corresponding bone, allowing the skeleton\r\n * to be driven by the transform node transformations.\r\n * @param rootNode The root transform node of the hierarchy to convert into a skeleton\r\n * @param scene The scene in which to create the skeleton\r\n * @param options Optional parameters for skeleton creation\r\n *    - name: The name for the created skeleton (defaults to rootNode.name + \"_skeleton\")\r\n *    - boneMeshSize: The diameter of the sphere mesh created for each bone (defaults to 1, only used if createMesh is true)\r\n *    - createMesh: If true, creates a mesh with spheres at each bone location for visualization purposes.\r\n *       The mesh will be parented to the rootNode's parent and returned through options.mesh\r\n *    - mesh: An existing mesh to attach the skeleton to. If provided, the skeleton will be assigned to this mesh\r\n * @returns A new skeleton with bones corresponding to the transform node hierarchy\r\n * @remarks\r\n * - Only transform nodes with a rotationQuaternion property will be converted into bones\r\n */\r\nexport function CreateSkeletonFromTransformNodeHierarchy(\r\n    rootNode: TransformNode,\r\n    scene: Scene,\r\n    options?: { name?: string; boneMeshSize?: number; createMesh?: boolean; mesh?: Mesh }\r\n): Skeleton {\r\n    const name = options?.name || rootNode.name + \"_skeleton\";\r\n    const skeleton = new Skeleton(name, name, scene);\r\n\r\n    const nodes = rootNode.getChildTransformNodes(false);\r\n\r\n    nodes.unshift(rootNode);\r\n\r\n    let mesh = options?.mesh || null;\r\n    if (options?.createMesh) {\r\n        mesh = new Mesh(`${name}_mesh`, scene);\r\n        mesh.parent = rootNode.parent;\r\n        mesh.skeleton = skeleton;\r\n\r\n        options.mesh = mesh;\r\n    } else if (mesh) {\r\n        mesh.skeleton = skeleton;\r\n    }\r\n\r\n    const positions: number[] = [];\r\n    const indices: number[] = [];\r\n    const normals: number[] = [];\r\n    const boneIndices: number[] = [];\r\n    const boneWeights: number[] = [];\r\n\r\n    const boneMesh = options?.createMesh ? MeshBuilder.CreateSphere(\"dummy\", { diameter: options?.boneMeshSize || 1, segments: 8 }, scene) : null;\r\n\r\n    const boneMeshNumVertices = boneMesh?.getTotalVertices() || 0;\r\n    const boneMeshPositions = boneMesh?.getVerticesData(VertexBuffer.PositionKind);\r\n    const boneMeshIndices = boneMesh?.getIndices();\r\n    const boneMeshNormals = boneMesh?.getVerticesData(VertexBuffer.NormalKind);\r\n\r\n    const mapNameToBone: { [name: string]: Bone } = {};\r\n\r\n    for (const node of nodes) {\r\n        if (!node.rotationQuaternion || node.getClassName() !== \"TransformNode\") {\r\n            continue;\r\n        }\r\n\r\n        const currentVertexIndex = positions.length / 3;\r\n\r\n        if (boneMeshPositions) {\r\n            for (let i = 0; i < boneMeshPositions.length; ++i) {\r\n                positions.push(boneMeshPositions[i]);\r\n            }\r\n        }\r\n        if (boneMeshNormals) {\r\n            for (let i = 0; i < boneMeshNormals.length; ++i) {\r\n                normals.push(boneMeshNormals[i]);\r\n            }\r\n        }\r\n\r\n        const boneIndex = skeleton.bones.length;\r\n\r\n        if (boneMesh) {\r\n            for (let i = 0; i < boneMeshNumVertices; ++i) {\r\n                boneIndices.push(boneIndex, -1, -1, -1);\r\n                boneWeights.push(1, 0, 0, 0);\r\n            }\r\n        }\r\n\r\n        if (boneMeshIndices) {\r\n            for (let i = 0; i < boneMeshIndices.length; ++i) {\r\n                indices.push(currentVertexIndex + boneMeshIndices[i]);\r\n            }\r\n        }\r\n\r\n        const bone = new Bone(\r\n            node.name,\r\n            skeleton,\r\n            node.parent ? mapNameToBone[node.parent.name] : null,\r\n            Matrix.Compose(node.scaling, node.rotationQuaternion, node.position), // local matrix\r\n            undefined,\r\n            Matrix.Identity() // bind matrix\r\n        );\r\n\r\n        bone.linkTransformNode(node);\r\n\r\n        mapNameToBone[node.name] = bone;\r\n    }\r\n\r\n    mesh?.setVerticesData(VertexBuffer.PositionKind, positions);\r\n    mesh?.setVerticesData(VertexBuffer.NormalKind, normals);\r\n    mesh?.setVerticesData(VertexBuffer.MatricesIndicesKind, boneIndices);\r\n    mesh?.setVerticesData(VertexBuffer.MatricesWeightsKind, boneWeights);\r\n    mesh?.setIndices(indices);\r\n\r\n    mesh?.refreshBoundingInfo(true, false);\r\n\r\n    boneMesh?.dispose();\r\n\r\n    return skeleton;\r\n}\r\n"]}