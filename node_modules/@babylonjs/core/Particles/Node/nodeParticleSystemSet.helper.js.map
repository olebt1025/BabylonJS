{"version":3,"file":"nodeParticleSystemSet.helper.js","sourceRoot":"","sources":["../../../../../dev/core/src/Particles/Node/nodeParticleSystemSet.helper.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Attractor } from \"../attractor\";\r\nimport type { FlowMap } from \"../flowMap\";\r\nimport type { Color3Gradient, ColorGradient } from \"core/Misc\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { ParticleSystem } from \"core/Particles/particleSystem\";\r\nimport type { IParticleSystem } from \"core/Particles/IParticleSystem\";\r\nimport type { BoxParticleEmitter } from \"core/Particles/EmitterTypes/boxParticleEmitter\";\r\nimport type { ConeDirectedParticleEmitter, ConeParticleEmitter } from \"core/Particles/EmitterTypes/coneParticleEmitter\";\r\nimport type { CustomParticleEmitter } from \"core/Particles/EmitterTypes/customParticleEmitter\";\r\nimport type { CylinderDirectedParticleEmitter, CylinderParticleEmitter } from \"core/Particles/EmitterTypes/cylinderParticleEmitter\";\r\nimport type { HemisphericParticleEmitter } from \"core/Particles/EmitterTypes/hemisphericParticleEmitter\";\r\nimport type { MeshParticleEmitter } from \"core/Particles/EmitterTypes/meshParticleEmitter\";\r\nimport type { PointParticleEmitter } from \"core/Particles/EmitterTypes/pointParticleEmitter\";\r\nimport type { SphereDirectedParticleEmitter, SphereParticleEmitter } from \"core/Particles/EmitterTypes/sphereParticleEmitter\";\r\nimport type { NodeParticleConnectionPoint } from \"core/Particles/Node/nodeParticleBlockConnectionPoint\";\r\nimport type { IShapeBlock } from \"core/Particles/Node/Blocks/Emitters/IShapeBlock\";\r\n\r\nimport { Color4 } from \"core/Maths/math.color\";\r\nimport { Vector2, Vector3 } from \"core/Maths/math.vector\";\r\nimport { FactorGradient } from \"core/Misc/gradients\";\r\nimport { NodeParticleBlockConnectionPointTypes } from \"core/Particles/Node/Enums/nodeParticleBlockConnectionPointTypes\";\r\nimport { NodeParticleSystemSet } from \"./nodeParticleSystemSet\";\r\nimport { NodeParticleContextualSources } from \"./Enums/nodeParticleContextualSources\";\r\nimport { NodeParticleSystemSources } from \"./Enums/nodeParticleSystemSources\";\r\nimport { ParticleConverterBlock } from \"./Blocks/particleConverterBlock\";\r\nimport { ParticleFloatToIntBlock, ParticleFloatToIntBlockOperations } from \"./Blocks/particleFloatToIntBlock\";\r\nimport { ParticleGradientBlock } from \"./Blocks/particleGradientBlock\";\r\nimport { ParticleGradientValueBlock } from \"./Blocks/particleGradientValueBlock\";\r\nimport { ParticleInputBlock } from \"./Blocks/particleInputBlock\";\r\nimport { ParticleMathBlock, ParticleMathBlockOperations } from \"./Blocks/particleMathBlock\";\r\nimport { ParticleRandomBlock, ParticleRandomBlockLocks } from \"./Blocks/particleRandomBlock\";\r\nimport { ParticleLerpBlock } from \"./Blocks/particleLerpBlock\";\r\nimport { ParticleTextureSourceBlock } from \"./Blocks/particleSourceTextureBlock\";\r\nimport { ParticleVectorLengthBlock } from \"./Blocks/particleVectorLengthBlock\";\r\nimport { SystemBlock } from \"./Blocks/systemBlock\";\r\nimport { ParticleConditionBlock, ParticleConditionBlockTests } from \"./Blocks/Conditions/particleConditionBlock\";\r\nimport { CreateParticleBlock } from \"./Blocks/Emitters/createParticleBlock\";\r\nimport { BoxShapeBlock } from \"./Blocks/Emitters/boxShapeBlock\";\r\nimport { ConeShapeBlock } from \"./Blocks/Emitters/coneShapeBlock\";\r\nimport { CylinderShapeBlock } from \"./Blocks/Emitters/cylinderShapeBlock\";\r\nimport { CustomShapeBlock } from \"./Blocks/Emitters/customShapeBlock\";\r\nimport { MeshShapeBlock } from \"./Blocks/Emitters/meshShapeBlock\";\r\nimport { PointShapeBlock } from \"./Blocks/Emitters/pointShapeBlock\";\r\nimport { SetupSpriteSheetBlock } from \"./Blocks/Emitters/setupSpriteSheetBlock\";\r\nimport { SphereShapeBlock } from \"./Blocks/Emitters/sphereShapeBlock\";\r\nimport { UpdateAngleBlock } from \"./Blocks/Update/updateAngleBlock\";\r\nimport { BasicSpriteUpdateBlock } from \"./Blocks/Update/basicSpriteUpdateBlock\";\r\nimport { UpdateAttractorBlock } from \"./Blocks/Update/updateAttractorBlock\";\r\nimport { UpdateColorBlock } from \"./Blocks/Update/updateColorBlock\";\r\nimport { UpdateDirectionBlock } from \"./Blocks/Update/updateDirectionBlock\";\r\nimport { UpdateFlowMapBlock } from \"./Blocks/Update/updateFlowMapBlock\";\r\nimport { UpdateNoiseBlock } from \"./Blocks/Update/updateNoiseBlock\";\r\nimport { UpdatePositionBlock } from \"./Blocks/Update/updatePositionBlock\";\r\nimport { UpdateSizeBlock } from \"./Blocks/Update/updateSizeBlock\";\r\nimport { UpdateRemapBlock } from \"./Blocks/Update/updateRemapBlock\";\r\nimport { GenerateBase64StringFromPixelData } from \"core/Misc/copyTools\";\r\n\r\n/** Represents blocks or groups of blocks that can be used in multiple places in the graph, so they are stored in this context to be reused */\r\ntype ConversionContext = {\r\n    targetStopDurationBlockOutput: NodeParticleConnectionPoint;\r\n    // Connections that represent calculated ratios values\r\n    timeToStopTimeRatioBlockGroupOutput: NodeParticleConnectionPoint;\r\n    ageToLifeTimeRatioBlockGroupOutput: NodeParticleConnectionPoint;\r\n    // Connections for the start value of a gradient. These are stored so they can be reused for the Creation phase and the Update phase of the particle\r\n    sizeGradientValue0Output: NodeParticleConnectionPoint;\r\n    colorGradientValue0Output: NodeParticleConnectionPoint;\r\n    // Updated scaled direction direction based on velocity and drag\r\n    scaledDirection: NodeParticleConnectionPoint;\r\n};\r\n\r\ntype RuntimeConversionContext = Partial<ConversionContext>;\r\n\r\n/**\r\n * Converts a ParticleSystem to a NodeParticleSystemSet.\r\n * @param name The name of the node particle system set.\r\n * @param particleSystemsList The particle systems to convert.\r\n * @returns The converted node particle system set or null if conversion failed.\r\n */\r\nexport async function ConvertToNodeParticleSystemSetAsync(name: string, particleSystemsList: ParticleSystem[]): Promise<Nullable<NodeParticleSystemSet>> {\r\n    if (!particleSystemsList || !particleSystemsList.length) {\r\n        return null;\r\n    }\r\n\r\n    const nodeParticleSystemSet = new NodeParticleSystemSet(name);\r\n    const promises: Promise<void>[] = [];\r\n\r\n    for (const particleSystem of particleSystemsList) {\r\n        promises.push(_ExtractDatafromParticleSystemAsync(nodeParticleSystemSet, particleSystem, {}));\r\n    }\r\n\r\n    await Promise.all(promises);\r\n    return nodeParticleSystemSet;\r\n}\r\n\r\nasync function _ExtractDatafromParticleSystemAsync(newSet: NodeParticleSystemSet, oldSystem: ParticleSystem, context: RuntimeConversionContext): Promise<void> {\r\n    // CreateParticle block group\r\n    const createParticleOutput = _CreateParticleBlockGroup(oldSystem, context);\r\n\r\n    // UpdateParticle block group\r\n    const updateParticleOutput = _UpdateParticleBlockGroup(createParticleOutput, oldSystem, context);\r\n\r\n    // System block\r\n    const newSystem = _SystemBlockGroup(updateParticleOutput, oldSystem, context);\r\n\r\n    // Register\r\n    newSet.systemBlocks.push(newSystem);\r\n}\r\n\r\n// ------------- CREATE PARTICLE FUNCTIONS -------------\r\n\r\n// The creation of the different properties follows the order they are added to the CreationQueue in ThinParticleSystem:\r\n// Lifetime, Emit Power, Size, Scale/StartSize, Angle, Color, Noise, ColorDead, Ramp, Sheet\r\nfunction _CreateParticleBlockGroup(oldSystem: ParticleSystem, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    // Create particle block\r\n    const createParticleBlock = new CreateParticleBlock(\"Create Particle\");\r\n    let createdParticle = createParticleBlock.particle;\r\n\r\n    _CreateParticleLifetimeBlockGroup(oldSystem, context).connectTo(createParticleBlock.lifeTime);\r\n    _CreateParticleEmitPowerBlockGroup(oldSystem).connectTo(createParticleBlock.emitPower);\r\n    _CreateParticleSizeBlockGroup(oldSystem, context).connectTo(createParticleBlock.size);\r\n    _CreateParticleScaleBlockGroup(oldSystem, context).connectTo(createParticleBlock.scale);\r\n    _CreateParticleAngleBlockGroup(oldSystem).connectTo(createParticleBlock.angle);\r\n    _CreateParticleColorBlockGroup(oldSystem, context).connectTo(createParticleBlock.color);\r\n\r\n    // Dead color\r\n    _CreateAndConnectInput(\"Dead Color\", oldSystem.colorDead.clone(), createParticleBlock.colorDead);\r\n\r\n    // Emitter shape\r\n    createdParticle = _EmitterShapeBlock(createdParticle, oldSystem);\r\n\r\n    // Sprite sheet setup\r\n    if (oldSystem.isAnimationSheetEnabled) {\r\n        createdParticle = _SpriteSheetBlock(createdParticle, oldSystem);\r\n    }\r\n\r\n    return createdParticle;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle lifetime\r\n * @param oldSystem The old particle system to convert\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle lifetime\r\n */\r\nfunction _CreateParticleLifetimeBlockGroup(oldSystem: ParticleSystem, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    if (oldSystem.targetStopDuration && oldSystem._lifeTimeGradients && oldSystem._lifeTimeGradients.length > 0) {\r\n        context.timeToStopTimeRatioBlockGroupOutput = _CreateTimeToStopTimeRatioBlockGroup(oldSystem.targetStopDuration, context);\r\n        const gradientBlockGroupOutput = _CreateGradientBlockGroup(\r\n            context.timeToStopTimeRatioBlockGroupOutput,\r\n            oldSystem._lifeTimeGradients,\r\n            ParticleRandomBlockLocks.PerParticle,\r\n            \"Lifetime\"\r\n        );\r\n        return gradientBlockGroupOutput;\r\n    } else {\r\n        const randomLifetimeBlock = new ParticleRandomBlock(\"Random Lifetime\");\r\n        _CreateAndConnectInput(\"Min Lifetime\", oldSystem.minLifeTime, randomLifetimeBlock.min);\r\n        _CreateAndConnectInput(\"Max Lifetime\", oldSystem.maxLifeTime, randomLifetimeBlock.max);\r\n        return randomLifetimeBlock.output;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle emit power\r\n * @param oldSystem The old particle system to convert\r\n * @returns The output of the group of blocks that represent the particle emit power\r\n */\r\nfunction _CreateParticleEmitPowerBlockGroup(oldSystem: ParticleSystem): NodeParticleConnectionPoint {\r\n    const randomEmitPowerBlock = new ParticleRandomBlock(\"Random Emit Power\");\r\n    _CreateAndConnectInput(\"Min Emit Power\", oldSystem.minEmitPower, randomEmitPowerBlock.min);\r\n    _CreateAndConnectInput(\"Max Emit Power\", oldSystem.maxEmitPower, randomEmitPowerBlock.max);\r\n    return randomEmitPowerBlock.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle size\r\n * @param oldSystem The old particle system to convert\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle size\r\n */\r\nfunction _CreateParticleSizeBlockGroup(oldSystem: ParticleSystem, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    if (oldSystem._sizeGradients && oldSystem._sizeGradients.length > 0) {\r\n        context.sizeGradientValue0Output = _CreateParticleInitialValueFromGradient(oldSystem._sizeGradients);\r\n        return context.sizeGradientValue0Output;\r\n    } else {\r\n        const randomSizeBlock = new ParticleRandomBlock(\"Random size\");\r\n        _CreateAndConnectInput(\"Min size\", oldSystem.minSize, randomSizeBlock.min);\r\n        _CreateAndConnectInput(\"Max size\", oldSystem.maxSize, randomSizeBlock.max);\r\n        return randomSizeBlock.output;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle scale\r\n * @param oldSystem The old particle system to convert\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle scale\r\n */\r\nfunction _CreateParticleScaleBlockGroup(oldSystem: ParticleSystem, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    // Create the random scale\r\n    const randomScaleBlock = new ParticleRandomBlock(\"Random Scale\");\r\n    _CreateAndConnectInput(\"Min Scale\", new Vector2(oldSystem.minScaleX, oldSystem.minScaleY), randomScaleBlock.min);\r\n    _CreateAndConnectInput(\"Max Scale\", new Vector2(oldSystem.maxScaleX, oldSystem.maxScaleY), randomScaleBlock.max);\r\n\r\n    if (oldSystem.targetStopDuration && oldSystem._startSizeGradients && oldSystem._startSizeGradients.length > 0) {\r\n        // Create the start size gradient\r\n        context.timeToStopTimeRatioBlockGroupOutput = _CreateTimeToStopTimeRatioBlockGroup(oldSystem.targetStopDuration, context);\r\n        const gradientBlockGroupOutput = _CreateGradientBlockGroup(\r\n            context.timeToStopTimeRatioBlockGroupOutput,\r\n            oldSystem._startSizeGradients,\r\n            ParticleRandomBlockLocks.PerParticle,\r\n            \"Start Size\"\r\n        );\r\n\r\n        // Multiply the initial random scale by the start size gradient\r\n        const multiplyScaleBlock = new ParticleMathBlock(\"Multiply Scale by Start Size Gradient\");\r\n        multiplyScaleBlock.operation = ParticleMathBlockOperations.Multiply;\r\n        randomScaleBlock.output.connectTo(multiplyScaleBlock.left);\r\n        gradientBlockGroupOutput.connectTo(multiplyScaleBlock.right);\r\n\r\n        return multiplyScaleBlock.output;\r\n    } else {\r\n        return randomScaleBlock.output;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle angle (rotation)\r\n * @param oldSystem The old particle system to convert\r\n * @returns The output of the group of blocks that represent the particle angle (rotation)\r\n */\r\nfunction _CreateParticleAngleBlockGroup(oldSystem: ParticleSystem): NodeParticleConnectionPoint {\r\n    const randomRotationBlock = new ParticleRandomBlock(\"Random Rotation\");\r\n    _CreateAndConnectInput(\"Min Rotation\", oldSystem.minInitialRotation, randomRotationBlock.min);\r\n    _CreateAndConnectInput(\"Max Rotation\", oldSystem.maxInitialRotation, randomRotationBlock.max);\r\n    return randomRotationBlock.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle color\r\n * @param oldSystem The old particle system to convert\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle color\r\n */\r\nfunction _CreateParticleColorBlockGroup(oldSystem: ParticleSystem, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    if (oldSystem._colorGradients && oldSystem._colorGradients.length > 0) {\r\n        context.colorGradientValue0Output = _CreateParticleInitialValueFromGradient(oldSystem._colorGradients);\r\n        return context.colorGradientValue0Output;\r\n    } else {\r\n        const randomStepBlock = new ParticleRandomBlock(\"Random color step\");\r\n        _CreateAndConnectInput(\"Min\", 0, randomStepBlock.min);\r\n        _CreateAndConnectInput(\"Max\", 1, randomStepBlock.max);\r\n\r\n        const lerpColorBlock = new ParticleLerpBlock(\"Lerp color\");\r\n        _CreateAndConnectInput(\"Color 1\", oldSystem.color1.clone(), lerpColorBlock.left);\r\n        _CreateAndConnectInput(\"Color 2\", oldSystem.color2.clone(), lerpColorBlock.right);\r\n        randomStepBlock.output.connectTo(lerpColorBlock.gradient);\r\n        return lerpColorBlock.output;\r\n    }\r\n}\r\n\r\nfunction _CreateParticleInitialValueFromGradient(gradients: Array<FactorGradient> | Array<ColorGradient>): NodeParticleConnectionPoint {\r\n    if (gradients.length === 0) {\r\n        throw new Error(\"No gradients provided.\");\r\n    }\r\n\r\n    const gradientStep = gradients[0];\r\n    const value1 = (gradientStep as any).factor1 ?? (gradientStep as any).color1;\r\n    const value2 = (gradientStep as any).factor2 ?? (gradientStep as any).color2;\r\n\r\n    if (value2 !== undefined) {\r\n        // Create a random between value1 and value2\r\n        const randomBlock = new ParticleRandomBlock(\"Random Value 0\");\r\n        randomBlock.lockMode = ParticleRandomBlockLocks.OncePerParticle;\r\n        _CreateAndConnectInput(\"Value 1\", value1, randomBlock.min);\r\n        _CreateAndConnectInput(\"Value 2\", value2, randomBlock.max);\r\n        return randomBlock.output;\r\n    } else {\r\n        // Single value\r\n        const sizeBlock = new ParticleInputBlock(\"Value\");\r\n        sizeBlock.value = value1;\r\n        return sizeBlock.output;\r\n    }\r\n}\r\n\r\nfunction _EmitterShapeBlock(particle: NodeParticleConnectionPoint, oldSystem: IParticleSystem): NodeParticleConnectionPoint {\r\n    const emitter = oldSystem.particleEmitterType;\r\n    if (!emitter) {\r\n        throw new Error(\"Particle system has no emitter type.\");\r\n    }\r\n\r\n    let shapeBlock: Nullable<IShapeBlock> = null;\r\n    switch (emitter.getClassName()) {\r\n        case \"BoxParticleEmitter\": {\r\n            const source = emitter as BoxParticleEmitter;\r\n            shapeBlock = new BoxShapeBlock(\"Box Shape\");\r\n\r\n            const target = shapeBlock as BoxShapeBlock;\r\n            _CreateAndConnectInput(\"Direction 1\", source.direction1.clone(), target.direction1);\r\n            _CreateAndConnectInput(\"Direction 2\", source.direction2.clone(), target.direction2);\r\n            _CreateAndConnectInput(\"Min Emit Box\", source.minEmitBox.clone(), target.minEmitBox);\r\n            _CreateAndConnectInput(\"Max Emit Box\", source.maxEmitBox.clone(), target.maxEmitBox);\r\n            break;\r\n        }\r\n        case \"ConeParticleEmitter\": {\r\n            const source = emitter as ConeParticleEmitter;\r\n            shapeBlock = new ConeShapeBlock(\"Cone Shape\");\r\n\r\n            const target = shapeBlock as ConeShapeBlock;\r\n            target.emitFromSpawnPointOnly = source.emitFromSpawnPointOnly;\r\n            _CreateAndConnectInput(\"Radius\", source.radius, target.radius);\r\n            _CreateAndConnectInput(\"Angle\", source.angle, target.angle);\r\n            _CreateAndConnectInput(\"Radius Range\", source.radiusRange, target.radiusRange);\r\n            _CreateAndConnectInput(\"Height Range\", source.heightRange, target.heightRange);\r\n            _CreateAndConnectInput(\"Direction Randomizer\", source.directionRandomizer, target.directionRandomizer);\r\n            break;\r\n        }\r\n        case \"ConeDirectedParticleEmitter\": {\r\n            const source = emitter as ConeDirectedParticleEmitter;\r\n            shapeBlock = new ConeShapeBlock(\"Cone Shape\");\r\n\r\n            const target = shapeBlock as ConeShapeBlock;\r\n            target.emitFromSpawnPointOnly = source.emitFromSpawnPointOnly;\r\n            _CreateAndConnectInput(\"Radius\", source.radius, target.radius);\r\n            _CreateAndConnectInput(\"Angle\", source.angle, target.angle);\r\n            _CreateAndConnectInput(\"Radius Range\", source.radiusRange, target.radiusRange);\r\n            _CreateAndConnectInput(\"Height Range\", source.heightRange, target.heightRange);\r\n            _CreateAndConnectInput(\"Direction 1\", source.direction1.clone(), target.direction1);\r\n            _CreateAndConnectInput(\"Direction 2\", source.direction2.clone(), target.direction2);\r\n            break;\r\n        }\r\n        case \"CustomParticleEmitter\": {\r\n            const source = emitter as CustomParticleEmitter;\r\n            shapeBlock = new CustomShapeBlock(\"Custom Shape\");\r\n\r\n            const target = shapeBlock as CustomShapeBlock;\r\n            target.particlePositionGenerator = source.particlePositionGenerator;\r\n            target.particleDestinationGenerator = source.particleDestinationGenerator;\r\n            target.particleDirectionGenerator = source.particleDirectionGenerator;\r\n            break;\r\n        }\r\n        case \"CylinderParticleEmitter\": {\r\n            const source = emitter as CylinderParticleEmitter;\r\n            shapeBlock = new CylinderShapeBlock(\"Cylinder Shape\");\r\n\r\n            const target = shapeBlock as CylinderShapeBlock;\r\n            _CreateAndConnectInput(\"Height\", source.height, target.height);\r\n            _CreateAndConnectInput(\"Radius\", source.radius, target.radius);\r\n            _CreateAndConnectInput(\"Radius Range\", source.radiusRange, target.radiusRange);\r\n            _CreateAndConnectInput(\"Direction Randomizer\", source.directionRandomizer, target.directionRandomizer);\r\n            break;\r\n        }\r\n        case \"CylinderDirectedParticleEmitter\": {\r\n            const source = emitter as CylinderDirectedParticleEmitter;\r\n            shapeBlock = new CylinderShapeBlock(\"Cylinder Shape\");\r\n\r\n            const target = shapeBlock as CylinderShapeBlock;\r\n            _CreateAndConnectInput(\"Height\", source.height, target.height);\r\n            _CreateAndConnectInput(\"Radius\", source.radius, target.radius);\r\n            _CreateAndConnectInput(\"Radius Range\", source.radiusRange, target.radiusRange);\r\n            _CreateAndConnectInput(\"Direction 1\", source.direction1.clone(), target.direction1);\r\n            _CreateAndConnectInput(\"Direction 2\", source.direction2.clone(), target.direction2);\r\n            break;\r\n        }\r\n        case \"HemisphericParticleEmitter\": {\r\n            const source = emitter as HemisphericParticleEmitter;\r\n            shapeBlock = new SphereShapeBlock(\"Sphere Shape\");\r\n\r\n            const target = shapeBlock as SphereShapeBlock;\r\n            target.isHemispheric = true;\r\n            _CreateAndConnectInput(\"Radius\", source.radius, target.radius);\r\n            _CreateAndConnectInput(\"Radius Range\", source.radiusRange, target.radiusRange);\r\n            _CreateAndConnectInput(\"Direction Randomizer\", source.directionRandomizer, target.directionRandomizer);\r\n            break;\r\n        }\r\n        case \"MeshParticleEmitter\": {\r\n            const source = emitter as MeshParticleEmitter;\r\n            shapeBlock = new MeshShapeBlock(\"Mesh Shape\");\r\n\r\n            const target = shapeBlock as MeshShapeBlock;\r\n            target.useMeshNormalsForDirection = source.useMeshNormalsForDirection;\r\n            _CreateAndConnectInput(\"Direction 1\", source.direction1.clone(), target.direction1);\r\n            _CreateAndConnectInput(\"Direction 2\", source.direction2.clone(), target.direction2);\r\n\r\n            target.mesh = source.mesh as Mesh;\r\n            break;\r\n        }\r\n        case \"PointParticleEmitter\": {\r\n            const source = emitter as PointParticleEmitter;\r\n            shapeBlock = new PointShapeBlock(\"Point Shape\");\r\n\r\n            const target = shapeBlock as PointShapeBlock;\r\n            _CreateAndConnectInput(\"Direction 1\", source.direction1.clone(), target.direction1);\r\n            _CreateAndConnectInput(\"Direction 2\", source.direction2.clone(), target.direction2);\r\n            break;\r\n        }\r\n        case \"SphereParticleEmitter\": {\r\n            const source = emitter as SphereParticleEmitter;\r\n            shapeBlock = new SphereShapeBlock(\"Sphere Shape\");\r\n\r\n            const target = shapeBlock as SphereShapeBlock;\r\n            _CreateAndConnectInput(\"Radius\", source.radius, target.radius);\r\n            _CreateAndConnectInput(\"Radius Range\", source.radiusRange, target.radiusRange);\r\n            _CreateAndConnectInput(\"Direction Randomizer\", source.directionRandomizer, target.directionRandomizer);\r\n            break;\r\n        }\r\n        case \"SphereDirectedParticleEmitter\": {\r\n            const source = emitter as SphereDirectedParticleEmitter;\r\n            shapeBlock = new SphereShapeBlock(\"Sphere Shape\");\r\n\r\n            const target = shapeBlock as SphereShapeBlock;\r\n            _CreateAndConnectInput(\"Radius\", source.radius, target.radius);\r\n            _CreateAndConnectInput(\"Radius Range\", source.radiusRange, target.radiusRange);\r\n            _CreateAndConnectInput(\"Direction1\", source.direction1.clone(), target.direction1);\r\n            _CreateAndConnectInput(\"Direction2\", source.direction2.clone(), target.direction2);\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (!shapeBlock) {\r\n        throw new Error(`Unsupported particle emitter type: ${emitter.getClassName()}`);\r\n    }\r\n\r\n    particle.connectTo(shapeBlock.particle);\r\n    return shapeBlock.output;\r\n}\r\n\r\nfunction _SpriteSheetBlock(particle: NodeParticleConnectionPoint, oldSystem: ParticleSystem): NodeParticleConnectionPoint {\r\n    const spriteSheetBlock = new SetupSpriteSheetBlock(\"Sprite Sheet Setup\");\r\n    particle.connectTo(spriteSheetBlock.particle);\r\n\r\n    spriteSheetBlock.start = oldSystem.startSpriteCellID;\r\n    spriteSheetBlock.end = oldSystem.endSpriteCellID;\r\n    spriteSheetBlock.width = oldSystem.spriteCellWidth;\r\n    spriteSheetBlock.height = oldSystem.spriteCellHeight;\r\n    spriteSheetBlock.spriteCellChangeSpeed = oldSystem.spriteCellChangeSpeed;\r\n    spriteSheetBlock.loop = oldSystem.spriteCellLoop;\r\n    spriteSheetBlock.randomStartCell = oldSystem.spriteRandomStartCell;\r\n\r\n    return spriteSheetBlock.output;\r\n}\r\n\r\n// ------------- UPDATE PARTICLE FUNCTIONS -------------\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle system update\r\n * The creation of the different properties follows the order they are added to the ProcessQueue in ThinParticleSystem:\r\n * Color, AngularSpeedGradients, AngularSpeed, VelocityGradients, Direction, LimitVelocityGradients, DragGradients, Position, Noise, SizeGradients, Gravity, RemapGradients\r\n * @param inputParticle The particle input connection point\r\n * @param oldSystem The old particle system to convert\r\n * @param context The runtime conversion context\r\n * @returns The output connection point after all updates have been applied\r\n */\r\nfunction _UpdateParticleBlockGroup(inputParticle: NodeParticleConnectionPoint, oldSystem: ParticleSystem, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    let updatedParticle: NodeParticleConnectionPoint = inputParticle;\r\n\r\n    updatedParticle = _UpdateParticleColorBlockGroup(updatedParticle, oldSystem._colorGradients, context);\r\n    updatedParticle = _UpdateParticleAngleBlockGroup(updatedParticle, oldSystem._angularSpeedGradients, oldSystem.minAngularSpeed, oldSystem.maxAngularSpeed, context);\r\n\r\n    if (oldSystem._velocityGradients && oldSystem._velocityGradients.length > 0) {\r\n        context.scaledDirection = _UpdateParticleVelocityGradientBlockGroup(oldSystem._velocityGradients, context);\r\n    }\r\n\r\n    if (oldSystem._dragGradients && oldSystem._dragGradients.length > 0) {\r\n        context.scaledDirection = _UpdateParticleDragGradientBlockGroup(oldSystem._dragGradients, context);\r\n    }\r\n\r\n    updatedParticle = _UpdateParticlePositionBlockGroup(updatedParticle, oldSystem.isLocal, context);\r\n\r\n    if (oldSystem.attractors && oldSystem.attractors.length > 0) {\r\n        updatedParticle = _UpdateParticleAttractorBlockGroup(updatedParticle, oldSystem.attractors);\r\n    }\r\n\r\n    if (oldSystem.flowMap) {\r\n        updatedParticle = _UpdateParticleFlowMapBlockGroup(updatedParticle, oldSystem.flowMap, oldSystem.flowMapStrength);\r\n    }\r\n\r\n    if (oldSystem._limitVelocityGradients && oldSystem._limitVelocityGradients.length > 0 && oldSystem.limitVelocityDamping !== 0) {\r\n        updatedParticle = _UpdateParticleVelocityLimitGradientBlockGroup(updatedParticle, oldSystem._limitVelocityGradients, oldSystem.limitVelocityDamping, context);\r\n    }\r\n\r\n    if (oldSystem.noiseTexture && oldSystem.noiseStrength) {\r\n        updatedParticle = _UpdateParticleNoiseBlockGroup(updatedParticle, oldSystem.noiseTexture.clone(), oldSystem.noiseStrength.clone());\r\n    }\r\n\r\n    if (oldSystem._sizeGradients && oldSystem._sizeGradients.length > 0) {\r\n        updatedParticle = _UpdateParticleSizeGradientBlockGroup(updatedParticle, oldSystem._sizeGradients, context);\r\n    }\r\n\r\n    if (oldSystem.gravity.equalsToFloats(0, 0, 0) === false) {\r\n        updatedParticle = _UpdateParticleGravityBlockGroup(updatedParticle, oldSystem.gravity);\r\n    }\r\n\r\n    if (oldSystem.useRampGradients) {\r\n        updatedParticle = _UpdateParticleRemapGradientBlockGroup(updatedParticle, oldSystem.getColorRemapGradients(), oldSystem.getAlphaRemapGradients(), context);\r\n    }\r\n\r\n    if (oldSystem.isAnimationSheetEnabled) {\r\n        updatedParticle = _UpdateParticleSpriteCellBlockGroup(updatedParticle);\r\n    }\r\n\r\n    return updatedParticle;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle color update\r\n * @param inputParticle The input particle to update\r\n * @param colorGradients The color gradients (if any)\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle color update\r\n */\r\nfunction _UpdateParticleColorBlockGroup(\r\n    inputParticle: NodeParticleConnectionPoint,\r\n    colorGradients: Nullable<Array<ColorGradient>>,\r\n    context: RuntimeConversionContext\r\n): NodeParticleConnectionPoint {\r\n    let colorCalculation: NodeParticleConnectionPoint | undefined = undefined;\r\n    if (colorGradients && colorGradients.length > 0) {\r\n        if (context.colorGradientValue0Output === undefined) {\r\n            throw new Error(\"Initial color gradient values not found in context.\");\r\n        }\r\n\r\n        context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);\r\n        colorCalculation = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, colorGradients, ParticleRandomBlockLocks.OncePerParticle, \"Color\", [\r\n            context.colorGradientValue0Output,\r\n        ]);\r\n    } else {\r\n        colorCalculation = _BasicColorUpdateBlockGroup();\r\n    }\r\n\r\n    // Create the color update block clamping alpha >= 0\r\n    const colorUpdateBlock = new UpdateColorBlock(\"Color update\");\r\n    inputParticle.connectTo(colorUpdateBlock.particle);\r\n    _ClampUpdateColorAlpha(colorCalculation).connectTo(colorUpdateBlock.color);\r\n\r\n    return colorUpdateBlock.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle angle update\r\n * @param inputParticle The input particle to update\r\n * @param angularSpeedGradients The angular speed gradients (if any)\r\n * @param minAngularSpeed The minimum angular speed\r\n * @param maxAngularSpeed The maximum angular speed\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle color update\r\n */\r\nfunction _UpdateParticleAngleBlockGroup(\r\n    inputParticle: NodeParticleConnectionPoint,\r\n    angularSpeedGradients: Nullable<Array<FactorGradient>>,\r\n    minAngularSpeed: number,\r\n    maxAngularSpeed: number,\r\n    context: RuntimeConversionContext\r\n): NodeParticleConnectionPoint {\r\n    // We will try to use gradients if they exist\r\n    // If not, we will try to use min/max angular speed\r\n    let angularSpeedCalculation = null;\r\n    if (angularSpeedGradients && angularSpeedGradients.length > 0) {\r\n        angularSpeedCalculation = _UpdateParticleAngularSpeedGradientBlockGroup(angularSpeedGradients, context);\r\n    } else if (minAngularSpeed !== 0 || maxAngularSpeed !== 0) {\r\n        angularSpeedCalculation = _UpdateParticleAngularSpeedBlockGroup(minAngularSpeed, maxAngularSpeed);\r\n    }\r\n\r\n    // If we have an angular speed calculation, then update the angle\r\n    if (angularSpeedCalculation) {\r\n        // Create the angular speed delta\r\n        const angleSpeedDeltaOutput = _CreateDeltaModifiedInput(\"Angular Speed\", angularSpeedCalculation);\r\n\r\n        // Add it to the angle\r\n        const addAngle = new ParticleMathBlock(\"Add Angular Speed to Angle\");\r\n        addAngle.operation = ParticleMathBlockOperations.Add;\r\n        _CreateAndConnectContextualSource(\"Angle\", NodeParticleContextualSources.Angle, addAngle.left);\r\n        angleSpeedDeltaOutput.connectTo(addAngle.right);\r\n\r\n        // Update the particle angle\r\n        const updateAngle = new UpdateAngleBlock(\"Angle Update with Angular Speed\");\r\n        inputParticle.connectTo(updateAngle.particle);\r\n        addAngle.output.connectTo(updateAngle.angle);\r\n\r\n        return updateAngle.output;\r\n    } else {\r\n        return inputParticle;\r\n    }\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle velocity update\r\n * @param velocityGradients The velocity gradients\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle velocity update\r\n */\r\nfunction _UpdateParticleVelocityGradientBlockGroup(velocityGradients: Array<FactorGradient>, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);\r\n\r\n    // Generate the gradient\r\n    const velocityValueOutput = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, velocityGradients, ParticleRandomBlockLocks.OncePerParticle, \"Velocity\");\r\n\r\n    // Update the direction scale based on the velocity\r\n    const multiplyScaleByVelocity = new ParticleMathBlock(\"Multiply Direction Scale by Velocity\");\r\n    multiplyScaleByVelocity.operation = ParticleMathBlockOperations.Multiply;\r\n    velocityValueOutput.connectTo(multiplyScaleByVelocity.left);\r\n    _CreateAndConnectContextualSource(\"Direction Scale\", NodeParticleContextualSources.DirectionScale, multiplyScaleByVelocity.right);\r\n\r\n    // Update the particle direction scale\r\n    const multiplyDirection = new ParticleMathBlock(\"Scaled Direction\");\r\n    multiplyDirection.operation = ParticleMathBlockOperations.Multiply;\r\n    multiplyScaleByVelocity.output.connectTo(multiplyDirection.left);\r\n    _CreateAndConnectContextualSource(\"Direction\", NodeParticleContextualSources.Direction, multiplyDirection.right);\r\n\r\n    // Store the new calculation of the scaled direction in the context\r\n    context.scaledDirection = multiplyDirection.output;\r\n    return multiplyDirection.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle velocity limit update\r\n * @param inputParticle The input particle to update\r\n * @param velocityLimitGradients The velocity limit gradients\r\n * @param limitVelocityDamping The limit velocity damping factor\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle velocity limit update\r\n */\r\nfunction _UpdateParticleVelocityLimitGradientBlockGroup(\r\n    inputParticle: NodeParticleConnectionPoint,\r\n    velocityLimitGradients: Array<FactorGradient>,\r\n    limitVelocityDamping: number,\r\n    context: RuntimeConversionContext\r\n): NodeParticleConnectionPoint {\r\n    context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);\r\n\r\n    // Calculate the current speed\r\n    const currentSpeedBlock = new ParticleVectorLengthBlock(\"Current Speed\");\r\n    _CreateAndConnectContextualSource(\"Direction\", NodeParticleContextualSources.Direction, currentSpeedBlock.input);\r\n\r\n    // Calculate the velocity limit from the gradient\r\n    const velocityLimitValueOutput = _CreateGradientBlockGroup(\r\n        context.ageToLifeTimeRatioBlockGroupOutput,\r\n        velocityLimitGradients,\r\n        ParticleRandomBlockLocks.OncePerParticle,\r\n        \"Velocity Limit\"\r\n    );\r\n\r\n    // Blocks that will calculate the new velocity if over the limit\r\n    const damped = new ParticleMathBlock(\"Damped Speed\");\r\n    damped.operation = ParticleMathBlockOperations.Multiply;\r\n    _CreateAndConnectContextualSource(\"Direction\", NodeParticleContextualSources.Direction, damped.left);\r\n    _CreateAndConnectInput(\"Limit Velocity Damping\", limitVelocityDamping, damped.right);\r\n\r\n    // Compare current speed and limit\r\n    const compareSpeed = new ParticleConditionBlock(\"Compare Speed to Limit\");\r\n    compareSpeed.test = ParticleConditionBlockTests.GreaterThan;\r\n    currentSpeedBlock.output.connectTo(compareSpeed.left);\r\n    velocityLimitValueOutput.connectTo(compareSpeed.right);\r\n    damped.output.connectTo(compareSpeed.ifTrue);\r\n    _CreateAndConnectContextualSource(\"Direction\", NodeParticleContextualSources.Direction, compareSpeed.ifFalse);\r\n\r\n    // Update the direction based on the calculted value\r\n    const updateDirection = new UpdateDirectionBlock(\"Direction Update\");\r\n    inputParticle.connectTo(updateDirection.particle);\r\n    compareSpeed.output.connectTo(updateDirection.direction);\r\n\r\n    return updateDirection.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle noise update\r\n * @param inputParticle The particle to update\r\n * @param noiseTexture The noise texture\r\n * @param noiseStrength The strength of the noise\r\n * @returns The output of the group of blocks that represent the particle noise update\r\n */\r\nfunction _UpdateParticleNoiseBlockGroup(inputParticle: NodeParticleConnectionPoint, noiseTexture: ProceduralTexture, noiseStrength: Vector3): NodeParticleConnectionPoint {\r\n    const noiseUpdate = new UpdateNoiseBlock(\"Noise Update\");\r\n    inputParticle.connectTo(noiseUpdate.particle);\r\n    _CreateTextureBlock(noiseTexture).connectTo(noiseUpdate.noiseTexture);\r\n    _CreateAndConnectInput(\"Noise Strength\", noiseStrength, noiseUpdate.strength);\r\n    return noiseUpdate.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle drag update\r\n * @param dragGradients The drag gradients\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle drag update\r\n */\r\nfunction _UpdateParticleDragGradientBlockGroup(dragGradients: Array<FactorGradient>, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);\r\n\r\n    // Generate the gradient\r\n    const dragValueOutput = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, dragGradients, ParticleRandomBlockLocks.OncePerParticle, \"Drag\");\r\n\r\n    // Calculate drag factor\r\n    const oneMinusDragBlock = new ParticleMathBlock(\"1 - Drag\");\r\n    oneMinusDragBlock.operation = ParticleMathBlockOperations.Subtract;\r\n    _CreateAndConnectInput(\"One\", 1, oneMinusDragBlock.left);\r\n    dragValueOutput.connectTo(oneMinusDragBlock.right);\r\n\r\n    // Multiply the scaled direction by drag factor\r\n    const multiplyDirection = new ParticleMathBlock(\"Scaled Direction with Drag\");\r\n    multiplyDirection.operation = ParticleMathBlockOperations.Multiply;\r\n    oneMinusDragBlock.output.connectTo(multiplyDirection.left);\r\n    if (context.scaledDirection === undefined) {\r\n        _CreateAndConnectContextualSource(\"Scaled Direction\", NodeParticleContextualSources.ScaledDirection, multiplyDirection.right);\r\n    } else {\r\n        context.scaledDirection.connectTo(multiplyDirection.right);\r\n    }\r\n\r\n    // Store the new calculation of the scaled direction in the context\r\n    context.scaledDirection = multiplyDirection.output;\r\n    return multiplyDirection.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle position update\r\n * @param inputParticle The input particle to update\r\n * @param isLocal Whether the particle coordinate system is local or not\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle position update\r\n */\r\nfunction _UpdateParticlePositionBlockGroup(inputParticle: NodeParticleConnectionPoint, isLocal: boolean, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    // Update the particle position\r\n    const updatePosition = new UpdatePositionBlock(\"Position Update\");\r\n    inputParticle.connectTo(updatePosition.particle);\r\n\r\n    if (isLocal) {\r\n        _CreateAndConnectContextualSource(\"Local Position Updated\", NodeParticleContextualSources.LocalPositionUpdated, updatePosition.position);\r\n    } else {\r\n        // Calculate the new position\r\n        const addPositionBlock = new ParticleMathBlock(\"Add Position\");\r\n        addPositionBlock.operation = ParticleMathBlockOperations.Add;\r\n        _CreateAndConnectContextualSource(\"Position\", NodeParticleContextualSources.Position, addPositionBlock.left);\r\n        if (context.scaledDirection === undefined) {\r\n            _CreateAndConnectContextualSource(\"Scaled Direction\", NodeParticleContextualSources.ScaledDirection, addPositionBlock.right);\r\n        } else {\r\n            context.scaledDirection.connectTo(addPositionBlock.right);\r\n        }\r\n\r\n        addPositionBlock.output.connectTo(updatePosition.position);\r\n    }\r\n\r\n    return updatePosition.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle attractor update\r\n * @param inputParticle The input particle to update\r\n * @param attractors The attractors (if any)\r\n * @returns The output of the group of blocks that represent the particle attractor update\r\n */\r\nfunction _UpdateParticleAttractorBlockGroup(inputParticle: NodeParticleConnectionPoint, attractors: Attractor[]): NodeParticleConnectionPoint {\r\n    let outputParticle = inputParticle;\r\n\r\n    // Chain update attractor blocks for each attractor\r\n    for (let i = 0; i < attractors.length; i++) {\r\n        const attractor = attractors[i];\r\n        const attractorBlock = new UpdateAttractorBlock(`Attractor Block ${i}`);\r\n        outputParticle.connectTo(attractorBlock.particle);\r\n        _CreateAndConnectInput(\"Attractor Position\", attractor.position.clone(), attractorBlock.attractor);\r\n        _CreateAndConnectInput(\"Attractor Strength\", attractor.strength, attractorBlock.strength);\r\n        outputParticle = attractorBlock.output;\r\n    }\r\n\r\n    return outputParticle;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle flow map update\r\n * @param inputParticle The input particle to update\r\n * @param flowMap The flow map data\r\n * @param flowMapStrength The strength of the flow map\r\n * @returns The output of the group of blocks that represent the particle flow map update\r\n */\r\nfunction _UpdateParticleFlowMapBlockGroup(inputParticle: NodeParticleConnectionPoint, flowMap: FlowMap, flowMapStrength: number): NodeParticleConnectionPoint {\r\n    // Create the flow map update block\r\n    const updateFlowMapBlock = new UpdateFlowMapBlock(\"Flow Map Update\");\r\n    inputParticle.connectTo(updateFlowMapBlock.particle);\r\n\r\n    // Create a texture block from the flow map data\r\n    // The FlowMap only stores raw pixel data, so we need to convert it to a base64 data URL\r\n    // Y has to be flipped as the texture data is flipped between CPU (canvas, Y=0 at top) and GPU (texture, Y=0 at bottom)\r\n    const flowMapTextureBlock = new ParticleTextureSourceBlock(\"Flow Map Texture\");\r\n    flowMapTextureBlock.serializedCachedData = true;\r\n    flowMapTextureBlock.textureDataUrl = GenerateBase64StringFromPixelData(flowMap.data, { width: flowMap.width, height: flowMap.height }, true) ?? \"\";\r\n    flowMapTextureBlock.texture.connectTo(updateFlowMapBlock.flowMap);\r\n\r\n    _CreateAndConnectInput(\"Flow Map Strength\", flowMapStrength, updateFlowMapBlock.strength);\r\n\r\n    return updateFlowMapBlock.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle size update\r\n * @param inputParticle The input particle to update\r\n * @param sizeGradients The size gradients (if any)\r\n * @param context The context of the current conversion\r\n * @returns The output of the group of blocks that represent the particle size update\r\n */\r\nfunction _UpdateParticleSizeGradientBlockGroup(\r\n    inputParticle: NodeParticleConnectionPoint,\r\n    sizeGradients: Array<FactorGradient>,\r\n    context: RuntimeConversionContext\r\n): NodeParticleConnectionPoint {\r\n    if (context.sizeGradientValue0Output === undefined) {\r\n        throw new Error(\"Initial size gradient values not found in context.\");\r\n    }\r\n\r\n    context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);\r\n\r\n    // Generate the gradient\r\n    const sizeValueOutput = _CreateGradientBlockGroup(context.ageToLifeTimeRatioBlockGroupOutput, sizeGradients, ParticleRandomBlockLocks.OncePerParticle, \"Size\", [\r\n        context.sizeGradientValue0Output,\r\n    ]);\r\n\r\n    // Create the update size\r\n    const updateSizeBlock = new UpdateSizeBlock(\"Size Update\");\r\n    inputParticle.connectTo(updateSizeBlock.particle);\r\n    sizeValueOutput.connectTo(updateSizeBlock.size);\r\n\r\n    return updateSizeBlock.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle gravity update\r\n * @param inputParticle The input particle to update\r\n * @param gravity The gravity vector to apply\r\n * @returns The output of the group of blocks that represent the particle gravity update\r\n */\r\nfunction _UpdateParticleGravityBlockGroup(inputParticle: NodeParticleConnectionPoint, gravity: Vector3): NodeParticleConnectionPoint {\r\n    // Create the gravity delta\r\n    const gravityDeltaOutput = _CreateDeltaModifiedInput(\"Gravity\", gravity);\r\n\r\n    // Add it to the direction\r\n    const addDirectionBlock = new ParticleMathBlock(\"Add Gravity to Direction\");\r\n    addDirectionBlock.operation = ParticleMathBlockOperations.Add;\r\n    _CreateAndConnectContextualSource(\"Direction\", NodeParticleContextualSources.Direction, addDirectionBlock.left);\r\n    gravityDeltaOutput.connectTo(addDirectionBlock.right);\r\n\r\n    // Update the particle direction\r\n    const updateDirection = new UpdateDirectionBlock(\"Direction Update with Gravity\");\r\n    inputParticle.connectTo(updateDirection.particle);\r\n    addDirectionBlock.output.connectTo(updateDirection.direction);\r\n\r\n    return updateDirection.output;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the color and alpha remap update\r\n * @param inputParticle The input particle to update\r\n * @param colorRemapGradients The color remap gradients\r\n * @param alphaRemapGradients The alpha remap gradients\r\n * @param context The context of the current conversion\r\n * @returns The ouput of the group of blocks that represent the particle remap update\r\n */\r\nfunction _UpdateParticleRemapGradientBlockGroup(\r\n    inputParticle: NodeParticleConnectionPoint,\r\n    colorRemapGradients: Nullable<Array<FactorGradient>>,\r\n    alphaRemapGradients: Nullable<Array<FactorGradient>>,\r\n    context: RuntimeConversionContext\r\n): NodeParticleConnectionPoint {\r\n    let hasUpdate = false;\r\n\r\n    const remapUpdateBlock = new UpdateRemapBlock(\"Remap Update\");\r\n\r\n    if (colorRemapGradients && colorRemapGradients.length > 0) {\r\n        context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);\r\n\r\n        // Split the color gradient into factor1 and factor2 gradients\r\n        const colorFactor1Gradients: Array<FactorGradient> = [];\r\n        const colorFactor2Gradients: Array<FactorGradient> = [];\r\n\r\n        for (let i = 0; i < colorRemapGradients.length; i++) {\r\n            const gradientValue = colorRemapGradients[i];\r\n\r\n            colorFactor1Gradients.push(new FactorGradient(gradientValue.gradient, gradientValue.factor1));\r\n            colorFactor2Gradients.push(new FactorGradient(gradientValue.gradient, gradientValue.factor2!));\r\n        }\r\n\r\n        // Generate the gradient\r\n        const colorFactor1BlockGroup = _CreateGradientBlockGroup(\r\n            context.ageToLifeTimeRatioBlockGroupOutput,\r\n            colorFactor1Gradients,\r\n            ParticleRandomBlockLocks.OncePerParticle,\r\n            \"Color Min\"\r\n        );\r\n\r\n        // Generate the gradient\r\n        const colorFactor2BlockGroup = _CreateGradientBlockGroup(\r\n            context.ageToLifeTimeRatioBlockGroupOutput,\r\n            colorFactor2Gradients,\r\n            ParticleRandomBlockLocks.OncePerParticle,\r\n            \"Color Max\"\r\n        );\r\n\r\n        const substractBlock = new ParticleMathBlock(\"Color Max - Min\");\r\n        substractBlock.operation = ParticleMathBlockOperations.Subtract;\r\n        colorFactor2BlockGroup.connectTo(substractBlock.left);\r\n        colorFactor1BlockGroup.connectTo(substractBlock.right);\r\n\r\n        const colorConverterBlock = new ParticleConverterBlock(\"Color Remap Converter\");\r\n        colorFactor1BlockGroup.connectTo(colorConverterBlock.xIn);\r\n        substractBlock.output.connectTo(colorConverterBlock.yIn);\r\n\r\n        colorConverterBlock.xyOut.connectTo(remapUpdateBlock.remapColor);\r\n\r\n        hasUpdate = true;\r\n    }\r\n\r\n    if (alphaRemapGradients && alphaRemapGradients.length > 0) {\r\n        context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);\r\n\r\n        // Split the color gradient into factor1 and factor2 gradients\r\n        const alphaFactor1Gradients: Array<FactorGradient> = [];\r\n        const alphaFactor2Gradients: Array<FactorGradient> = [];\r\n\r\n        for (let i = 0; i < alphaRemapGradients.length; i++) {\r\n            const gradientValue = alphaRemapGradients[i];\r\n\r\n            alphaFactor1Gradients.push(new FactorGradient(gradientValue.gradient, gradientValue.factor1));\r\n            alphaFactor2Gradients.push(new FactorGradient(gradientValue.gradient, gradientValue.factor2!));\r\n        }\r\n\r\n        // Generate the gradient\r\n        const alphaFactor1BlockGroup = _CreateGradientBlockGroup(\r\n            context.ageToLifeTimeRatioBlockGroupOutput,\r\n            alphaFactor1Gradients,\r\n            ParticleRandomBlockLocks.OncePerParticle,\r\n            \"Alpha Min\"\r\n        );\r\n\r\n        // Generate the gradient\r\n        const alphaFactor2BlockGroup = _CreateGradientBlockGroup(\r\n            context.ageToLifeTimeRatioBlockGroupOutput,\r\n            alphaFactor2Gradients,\r\n            ParticleRandomBlockLocks.OncePerParticle,\r\n            \"Alpha Max\"\r\n        );\r\n\r\n        const substractBlock = new ParticleMathBlock(\"Alpha Max - Min\");\r\n        substractBlock.operation = ParticleMathBlockOperations.Subtract;\r\n        alphaFactor2BlockGroup.connectTo(substractBlock.left);\r\n        alphaFactor1BlockGroup.connectTo(substractBlock.right);\r\n\r\n        const alphaConverterBlock = new ParticleConverterBlock(\"Alpha Remap Converter\");\r\n        alphaFactor1BlockGroup.connectTo(alphaConverterBlock.xIn);\r\n        substractBlock.output.connectTo(alphaConverterBlock.yIn);\r\n\r\n        alphaConverterBlock.xyOut.connectTo(remapUpdateBlock.remapAlpha);\r\n\r\n        hasUpdate = true;\r\n    }\r\n\r\n    if (hasUpdate) {\r\n        inputParticle.connectTo(remapUpdateBlock.particle);\r\n        return remapUpdateBlock.output;\r\n    }\r\n\r\n    return inputParticle;\r\n}\r\n\r\n/**\r\n * Creates the group of blocks that represent the particle sprite cell update\r\n * @param inputParticle The input particle to update\r\n * @returns The output of the group of blocks that represent the particle sprite cell update #2MI0A1#3\r\n */\r\nfunction _UpdateParticleSpriteCellBlockGroup(inputParticle: NodeParticleConnectionPoint): NodeParticleConnectionPoint {\r\n    const updateSpriteCell = new BasicSpriteUpdateBlock(\"Sprite Cell Update\");\r\n    inputParticle.connectTo(updateSpriteCell.particle);\r\n    return updateSpriteCell.output;\r\n}\r\n\r\nfunction _UpdateParticleAngularSpeedGradientBlockGroup(angularSpeedGradients: Array<FactorGradient>, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    context.ageToLifeTimeRatioBlockGroupOutput = _CreateAgeToLifeTimeRatioBlockGroup(context);\r\n\r\n    // Generate the gradient\r\n    const angularSpeedValueOutput = _CreateGradientBlockGroup(\r\n        context.ageToLifeTimeRatioBlockGroupOutput,\r\n        angularSpeedGradients,\r\n        ParticleRandomBlockLocks.OncePerParticle,\r\n        \"Angular Speed\"\r\n    );\r\n    return angularSpeedValueOutput;\r\n}\r\n\r\nfunction _UpdateParticleAngularSpeedBlockGroup(minAngularSpeed: number, maxAngularSpeed: number): NodeParticleConnectionPoint {\r\n    // Random value between for the angular speed of the particle\r\n    const randomAngularSpeedBlock = new ParticleRandomBlock(\"Random Angular Speed\");\r\n    randomAngularSpeedBlock.lockMode = ParticleRandomBlockLocks.OncePerParticle;\r\n    _CreateAndConnectInput(\"Min Angular Speed\", minAngularSpeed, randomAngularSpeedBlock.min);\r\n    _CreateAndConnectInput(\"Max Angular Speed\", maxAngularSpeed, randomAngularSpeedBlock.max);\r\n    return randomAngularSpeedBlock.output;\r\n}\r\n\r\nfunction _BasicColorUpdateBlockGroup(): NodeParticleConnectionPoint {\r\n    const addColorBlock = new ParticleMathBlock(\"Add Color\");\r\n    addColorBlock.operation = ParticleMathBlockOperations.Add;\r\n    _CreateAndConnectContextualSource(\"Color\", NodeParticleContextualSources.Color, addColorBlock.left);\r\n    _CreateAndConnectContextualSource(\"Scaled Color Step\", NodeParticleContextualSources.ScaledColorStep, addColorBlock.right);\r\n    return addColorBlock.output;\r\n}\r\n\r\nfunction _ClampUpdateColorAlpha(colorCalculationOutput: NodeParticleConnectionPoint): NodeParticleConnectionPoint {\r\n    // Decompose color to clamp alpha\r\n    const decomposeColorBlock = new ParticleConverterBlock(\"Decompose Color\");\r\n    colorCalculationOutput.connectTo(decomposeColorBlock.colorIn);\r\n\r\n    // Clamp alpha to be >= 0\r\n    const maxAlphaBlock = new ParticleMathBlock(\"Alpha >= 0\");\r\n    maxAlphaBlock.operation = ParticleMathBlockOperations.Max;\r\n    decomposeColorBlock.wOut.connectTo(maxAlphaBlock.left);\r\n    _CreateAndConnectInput(\"Zero\", 0, maxAlphaBlock.right);\r\n\r\n    // Recompose color\r\n    const composeColorBlock = new ParticleConverterBlock(\"Compose Color\");\r\n    decomposeColorBlock.xyzOut.connectTo(composeColorBlock.xyzIn);\r\n    maxAlphaBlock.output.connectTo(composeColorBlock.wIn);\r\n\r\n    return composeColorBlock.colorOut;\r\n}\r\n\r\n// ------------- SYSTEM FUNCTIONS -------------\r\n\r\nfunction _SystemBlockGroup(updateParticleOutput: NodeParticleConnectionPoint, oldSystem: ParticleSystem, context: RuntimeConversionContext): SystemBlock {\r\n    const newSystem = new SystemBlock(oldSystem.name);\r\n\r\n    newSystem.translationPivot.value = oldSystem.translationPivot.clone();\r\n    newSystem.textureMask.value = oldSystem.textureMask.clone();\r\n    newSystem.manualEmitCount = oldSystem.manualEmitCount;\r\n    newSystem.blendMode = oldSystem.blendMode;\r\n    newSystem.capacity = oldSystem.getCapacity();\r\n    newSystem.startDelay = oldSystem.startDelay;\r\n    newSystem.updateSpeed = oldSystem.updateSpeed;\r\n    newSystem.preWarmCycles = oldSystem.preWarmCycles;\r\n    newSystem.preWarmStepOffset = oldSystem.preWarmStepOffset;\r\n    newSystem.isBillboardBased = oldSystem.isBillboardBased;\r\n    newSystem.billBoardMode = oldSystem.billboardMode;\r\n    newSystem.isLocal = oldSystem.isLocal;\r\n    newSystem.disposeOnStop = oldSystem.disposeOnStop;\r\n    newSystem.renderingGroupId = oldSystem.renderingGroupId;\r\n    const emitter = oldSystem.emitter;\r\n    if (emitter instanceof Vector3) {\r\n        newSystem.emitter = emitter.clone();\r\n    } else {\r\n        newSystem.emitter = emitter;\r\n    }\r\n\r\n    _SystemCustomShader(oldSystem, newSystem);\r\n    _SystemEmitRateValue(oldSystem.getEmitRateGradients(), oldSystem.targetStopDuration, oldSystem.emitRate, newSystem, context);\r\n    _SystemTargetStopDuration(oldSystem.targetStopDuration, newSystem, context);\r\n\r\n    const rampGradients = oldSystem.getRampGradients();\r\n    if (rampGradients && rampGradients.length > 0) {\r\n        _SystemRampGradientsBlockGroup(rampGradients, newSystem);\r\n    }\r\n\r\n    const texture = oldSystem.particleTexture;\r\n    if (texture) {\r\n        _CreateTextureBlock(texture).connectTo(newSystem.texture);\r\n    }\r\n\r\n    updateParticleOutput.connectTo(newSystem.particle);\r\n\r\n    return newSystem;\r\n}\r\n\r\nfunction _SystemCustomShader(oldSystem: ParticleSystem, newSystem: SystemBlock) {\r\n    if (oldSystem.customShader) {\r\n        // Copy the custom shader configuration so it can be recreated when building the system\r\n        newSystem.customShader = {\r\n            shaderPath: {\r\n                fragmentElement: oldSystem.customShader.shaderPath.fragmentElement,\r\n            },\r\n            shaderOptions: {\r\n                uniforms: oldSystem.customShader.shaderOptions.uniforms.slice(),\r\n                samplers: oldSystem.customShader.shaderOptions.samplers.slice(),\r\n                defines: oldSystem.customShader.shaderOptions.defines.slice(),\r\n            },\r\n        };\r\n    } else {\r\n        // Check if there's a custom effect set directly without customShader metadata\r\n        // This happens when using the ThinParticleSystem constructor with a customEffect parameter or when calling setCustomEffect directly\r\n        const customEffect = oldSystem.getCustomEffect(0);\r\n        if (customEffect) {\r\n            const effectName = customEffect.name;\r\n            const fragmentElement =\r\n                typeof effectName === \"string\"\r\n                    ? effectName\r\n                    : ((effectName as { fragmentElement?: string; fragment?: string }).fragmentElement ?? (effectName as { fragment?: string }).fragment);\r\n\r\n            newSystem.customShader = {\r\n                shaderPath: {\r\n                    fragmentElement: fragmentElement ?? \"\",\r\n                },\r\n                shaderOptions: {\r\n                    uniforms: (customEffect as any)._uniformsNames.slice(),\r\n                    samplers: (customEffect as any)._samplerList.slice(),\r\n                    defines: customEffect.defines ? customEffect.defines.split(\"\\n\").filter((d) => d.length > 0) : [],\r\n                },\r\n            };\r\n        }\r\n    }\r\n}\r\n\r\nfunction _SystemEmitRateValue(\r\n    emitGradients: Nullable<Array<FactorGradient>>,\r\n    targetStopDuration: number,\r\n    emitRate: number,\r\n    newSystem: SystemBlock,\r\n    context: RuntimeConversionContext\r\n): void {\r\n    if (emitGradients && emitGradients.length > 0 && targetStopDuration > 0) {\r\n        // Create the emit gradients\r\n        context.timeToStopTimeRatioBlockGroupOutput = _CreateTimeToStopTimeRatioBlockGroup(targetStopDuration, context);\r\n        const gradientValue = _CreateGradientBlockGroup(context.timeToStopTimeRatioBlockGroupOutput, emitGradients, ParticleRandomBlockLocks.PerSystem, \"Emit Rate\");\r\n\r\n        // Round the value to an int\r\n        const roundBlock = new ParticleFloatToIntBlock(\"Round to Int\");\r\n        roundBlock.operation = ParticleFloatToIntBlockOperations.Round;\r\n        gradientValue.connectTo(roundBlock.input);\r\n        roundBlock.output.connectTo(newSystem.emitRate);\r\n    } else {\r\n        newSystem.emitRate.value = emitRate;\r\n    }\r\n}\r\n\r\nfunction _SystemTargetStopDuration(targetStopDuration: number, newSystem: SystemBlock, context: RuntimeConversionContext): void {\r\n    // If something else uses the target stop duration (like a gradient),\r\n    // then the block is already created and stored in the context\r\n    if (context.targetStopDurationBlockOutput) {\r\n        context.targetStopDurationBlockOutput.connectTo(newSystem.targetStopDuration);\r\n    } else {\r\n        // If no one used it, do not create a block just set the value\r\n        newSystem.targetStopDuration.value = targetStopDuration;\r\n    }\r\n}\r\n\r\nfunction _SystemRampGradientsBlockGroup(rampGradients: Color3Gradient[], newSystem: SystemBlock): void {\r\n    const gradientBlock = new ParticleGradientBlock(\"Ramp Gradient Block\");\r\n\r\n    for (let i = 0; i < rampGradients.length; i++) {\r\n        const rampGradient = rampGradients[i];\r\n\r\n        const gradientValueBlock = new ParticleGradientValueBlock(`Ramp Gradient ${i}`);\r\n        gradientValueBlock.reference = rampGradient.gradient;\r\n        _CreateAndConnectInput(\r\n            `Color ${i}`,\r\n            new Color4(rampGradient.color.r, rampGradient.color.g, rampGradient.color.b),\r\n            gradientValueBlock.value,\r\n            NodeParticleBlockConnectionPointTypes.Color4\r\n        );\r\n\r\n        gradientValueBlock.output.connectTo(gradientBlock.inputs[i + 1]);\r\n    }\r\n\r\n    gradientBlock.output.connectTo(newSystem.rampGradient);\r\n}\r\n\r\n// ------------- UTILITY FUNCTIONS -------------\r\n\r\nfunction _CreateDeltaModifiedInput(name: string, value: Vector3 | NodeParticleConnectionPoint): NodeParticleConnectionPoint {\r\n    const multiplyBlock = new ParticleMathBlock(\"Multiply by Delta\");\r\n    multiplyBlock.operation = ParticleMathBlockOperations.Multiply;\r\n    if (value instanceof Vector3) {\r\n        _CreateAndConnectInput(name, value, multiplyBlock.left);\r\n    } else {\r\n        value.connectTo(multiplyBlock.left);\r\n    }\r\n    _CreateAndConnectSystemSource(\"Delta\", NodeParticleSystemSources.Delta, multiplyBlock.right);\r\n\r\n    return multiplyBlock.output;\r\n}\r\n\r\nfunction _CreateAndConnectInput(\r\n    inputBlockName: string,\r\n    value: number | Vector2 | Vector3 | Color4,\r\n    targetToConnectTo: NodeParticleConnectionPoint,\r\n    inputType?: NodeParticleBlockConnectionPointTypes\r\n): void {\r\n    const input = new ParticleInputBlock(inputBlockName, inputType);\r\n    input.value = value;\r\n    input.output.connectTo(targetToConnectTo);\r\n}\r\n\r\nfunction _CreateAndConnectContextualSource(contextualBlockName: string, contextSource: NodeParticleContextualSources, targetToConnectTo: NodeParticleConnectionPoint): void {\r\n    const input = new ParticleInputBlock(contextualBlockName);\r\n    input.contextualValue = contextSource;\r\n    input.output.connectTo(targetToConnectTo);\r\n}\r\n\r\nfunction _CreateAndConnectSystemSource(systemBlockName: string, systemSource: NodeParticleSystemSources, targetToConnectTo: NodeParticleConnectionPoint): void {\r\n    const input = new ParticleInputBlock(systemBlockName);\r\n    input.systemSource = systemSource;\r\n    input.output.connectTo(targetToConnectTo);\r\n}\r\n\r\n/**\r\n * Creates the target stop duration input block, as it can be shared in multiple places\r\n * This block is stored in the context so the same block is shared in the graph\r\n * @param targetStopDuration The target stop duration value\r\n * @param context The context of the current conversion\r\n * @returns\r\n */\r\nfunction _CreateTargetStopDurationInputBlock(targetStopDuration: number, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    // If we have already created the target stop duration input block, return it\r\n    if (context.targetStopDurationBlockOutput) {\r\n        return context.targetStopDurationBlockOutput;\r\n    }\r\n\r\n    // Create the target stop duration input block if not already created\r\n    const targetStopDurationInputBlock = new ParticleInputBlock(\"Target Stop Duration\");\r\n    targetStopDurationInputBlock.value = targetStopDuration;\r\n\r\n    // Save the output in our context to avoid regenerating it again\r\n    context.targetStopDurationBlockOutput = targetStopDurationInputBlock.output;\r\n    return context.targetStopDurationBlockOutput;\r\n}\r\n\r\n/**\r\n * Create a group of blocks that calculates the ratio between the actual frame and the target stop duration, clamped between 0 and 1.\r\n * This is used to simulate the behavior of the old particle system where several particle gradient values are affected by the target stop duration.\r\n * This block group is stored in the context so the same group is shared in the graph\r\n * @param targetStopDuration The target stop duration value\r\n * @param context The context of the current conversion\r\n * @returns The ratio block output connection point\r\n */\r\nfunction _CreateTimeToStopTimeRatioBlockGroup(targetStopDuration: number, context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    // If we have already generated this group, return it\r\n    if (context.timeToStopTimeRatioBlockGroupOutput) {\r\n        return context.timeToStopTimeRatioBlockGroupOutput;\r\n    }\r\n\r\n    context.targetStopDurationBlockOutput = _CreateTargetStopDurationInputBlock(targetStopDuration, context);\r\n\r\n    // Find the ratio between the actual frame and the target stop duration\r\n    const ratio = new ParticleMathBlock(\"Frame/Stop Ratio\");\r\n    ratio.operation = ParticleMathBlockOperations.Divide;\r\n    _CreateAndConnectSystemSource(\"Actual Frame\", NodeParticleSystemSources.Time, ratio.left);\r\n    context.targetStopDurationBlockOutput.connectTo(ratio.right);\r\n\r\n    // Make sure values is >=0\r\n    const clampMin = new ParticleMathBlock(\"Clamp Min 0\");\r\n    clampMin.operation = ParticleMathBlockOperations.Max;\r\n    _CreateAndConnectInput(\"Zero\", 0, clampMin.left);\r\n    ratio.output.connectTo(clampMin.right);\r\n\r\n    // Make sure values is <=1\r\n    const clampMax = new ParticleMathBlock(\"Clamp Max 1\");\r\n    clampMax.operation = ParticleMathBlockOperations.Min;\r\n    _CreateAndConnectInput(\"One\", 1, clampMax.left);\r\n    clampMin.output.connectTo(clampMax.right);\r\n\r\n    // Save the group output in our context to avoid regenerating it again\r\n    context.timeToStopTimeRatioBlockGroupOutput = clampMax.output;\r\n    return context.timeToStopTimeRatioBlockGroupOutput;\r\n}\r\n\r\nfunction _CreateAgeToLifeTimeRatioBlockGroup(context: RuntimeConversionContext): NodeParticleConnectionPoint {\r\n    // If we have already generated this group, return it\r\n    if (context.ageToLifeTimeRatioBlockGroupOutput) {\r\n        return context.ageToLifeTimeRatioBlockGroupOutput;\r\n    }\r\n\r\n    // Find the ratio between the age and the lifetime\r\n    const ratio = new ParticleMathBlock(\"Age/LifeTime Ratio\");\r\n    ratio.operation = ParticleMathBlockOperations.Divide;\r\n    _CreateAndConnectContextualSource(\"Age\", NodeParticleContextualSources.Age, ratio.left);\r\n    _CreateAndConnectContextualSource(\"LifeTime\", NodeParticleContextualSources.Lifetime, ratio.right);\r\n\r\n    // Save the group output in our context to avoid regenerating it again\r\n    context.ageToLifeTimeRatioBlockGroupOutput = ratio.output;\r\n    return ratio.output;\r\n}\r\n\r\n/**\r\n * Creates the blocks that represent a gradient\r\n * @param gradientSelector The value that determines which gradient to use\r\n * @param gradientValues The list of gradient values\r\n * @param randomLockMode The type of random to use for the gradient values\r\n * @param prefix The prefix to use for naming the blocks\r\n * @param initialValues Optional initial values to connect to the gradient inputs that were calculated during other steps of the conversion\r\n * @returns The output connection point of the gradient block\r\n */\r\nfunction _CreateGradientBlockGroup(\r\n    gradientSelector: NodeParticleConnectionPoint,\r\n    gradientValues: Array<FactorGradient> | Array<ColorGradient>,\r\n    randomLockMode: ParticleRandomBlockLocks,\r\n    prefix: string,\r\n    initialValues: NodeParticleConnectionPoint[] = []\r\n): NodeParticleConnectionPoint {\r\n    // Create the gradient block and connect the value that controls the gradient selection\r\n    const gradientBlock = new ParticleGradientBlock(prefix + \" Gradient Block\");\r\n    gradientSelector.connectTo(gradientBlock.gradient);\r\n\r\n    // If initial values are provided, we use them instead of the values in the gradientValues array\r\n    // These means this values were already transformed into blocks on a previous step of the conversion and we must reuse them\r\n    for (let i = 0; i < initialValues.length; i++) {\r\n        const reference = i < gradientValues.length ? gradientValues[i].gradient : 1;\r\n        const gradientValueBlock = new ParticleGradientValueBlock(prefix + \" Gradient Value \" + i);\r\n        gradientValueBlock.reference = reference;\r\n        initialValues[i].connectTo(gradientValueBlock.value);\r\n        gradientValueBlock.output.connectTo(gradientBlock.inputs[i + 1]);\r\n    }\r\n\r\n    // Create the gradient values\r\n    for (let i = 0 + initialValues.length; i < gradientValues.length; i++) {\r\n        const gradientValueBlockGroupOutput = _CreateGradientValueBlockGroup(gradientValues[i], randomLockMode, prefix, i);\r\n        gradientValueBlockGroupOutput.connectTo(gradientBlock.inputs[i + 1]);\r\n    }\r\n\r\n    return gradientBlock.output;\r\n}\r\n\r\n/**\r\n * Creates the blocks that represent a gradient value\r\n * This can be either a single value or a random between two values\r\n * @param gradientStep The gradient step data\r\n * @param randomLockMode The lock mode to use for random values\r\n * @param prefix The prefix to use for naming the blocks\r\n * @param index The index of the gradient step\r\n * @returns The output connection point of the gradient value block\r\n */\r\nfunction _CreateGradientValueBlockGroup(\r\n    gradientStep: FactorGradient | ColorGradient,\r\n    randomLockMode: ParticleRandomBlockLocks,\r\n    prefix: string,\r\n    index: number\r\n): NodeParticleConnectionPoint {\r\n    const gradientValueBlock = new ParticleGradientValueBlock(prefix + \" Gradient Value \" + index);\r\n    gradientValueBlock.reference = gradientStep.gradient;\r\n\r\n    const value1 = (gradientStep as any).factor1 ?? (gradientStep as any).color1.clone();\r\n    const value2 = (gradientStep as any).factor2 ?? (gradientStep as any).color2?.clone();\r\n\r\n    if (value2 !== undefined) {\r\n        // Create a random between value1 and value2\r\n        const randomBlock = new ParticleRandomBlock(\"Random Value \" + index);\r\n        randomBlock.lockMode = randomLockMode;\r\n        _CreateAndConnectInput(\"Value 1\", value1, randomBlock.min);\r\n        _CreateAndConnectInput(\"Value 2\", value2, randomBlock.max);\r\n        randomBlock.output.connectTo(gradientValueBlock.value);\r\n    } else {\r\n        // Single value\r\n        _CreateAndConnectInput(\"Value\", value1, gradientValueBlock.value);\r\n    }\r\n\r\n    return gradientValueBlock.output;\r\n}\r\n\r\nfunction _CreateTextureBlock(texture: Nullable<BaseTexture>): NodeParticleConnectionPoint {\r\n    // Texture - always use sourceTexture to preserve all texture options\r\n    const textureBlock = new ParticleTextureSourceBlock(\"Texture\");\r\n    textureBlock.sourceTexture = texture;\r\n    return textureBlock.texture;\r\n}\r\n"]}