{"version":3,"file":"frameGraph.js","sourceRoot":"","sources":["../../../../dev/core/src/FrameGraph/frameGraph.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Scene, AbstractEngine, FrameGraphTask, Nullable, NodeRenderGraph, IDisposable } from \"core/index\";\r\nimport { FrameGraphPass } from \"./Passes/pass\";\r\nimport { FrameGraphRenderPass } from \"./Passes/renderPass\";\r\nimport { FrameGraphObjectListPass } from \"./Passes/objectListPass\";\r\nimport { FrameGraphRenderContext } from \"./frameGraphRenderContext\";\r\nimport { FrameGraphContext } from \"./frameGraphContext\";\r\nimport { FrameGraphTextureManager } from \"./frameGraphTextureManager\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { _RetryWithInterval } from \"core/Misc/timingTools\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { UniqueIdGenerator } from \"core/Misc/uniqueIdGenerator\";\r\n\r\nenum FrameGraphPassType {\r\n    Normal = 0,\r\n    Render = 1,\r\n    ObjectList = 2,\r\n}\r\n\r\n/**\r\n * Class used to implement a frame graph\r\n */\r\nexport class FrameGraph implements IDisposable {\r\n    /**\r\n     * Gets the texture manager used by the frame graph\r\n     */\r\n    public readonly textureManager: FrameGraphTextureManager;\r\n\r\n    private readonly _engine: AbstractEngine;\r\n    private readonly _scene: Scene;\r\n    private readonly _tasks: FrameGraphTask[] = [];\r\n    private readonly _passContext: FrameGraphContext;\r\n    private readonly _renderContext: FrameGraphRenderContext;\r\n    private readonly _initAsyncPromises: Promise<unknown>[] = [];\r\n    private _currentProcessedTask: FrameGraphTask | null = null;\r\n    private _whenReadyAsyncCancel: Nullable<() => void> = null;\r\n    private _importPromise: Promise<any>;\r\n\r\n    /**\r\n     * Name of the frame graph\r\n     */\r\n    public name = \"Frame Graph\";\r\n\r\n    /**\r\n     * Gets the unique id of the frame graph\r\n     */\r\n    public readonly uniqueId = UniqueIdGenerator.UniqueId;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that texture allocation should be optimized (that is, reuse existing textures when possible to limit GPU memory usage) (default: true)\r\n     */\r\n    public optimizeTextureAllocation = true;\r\n\r\n    /**\r\n     * Observable raised when the node render graph is built\r\n     */\r\n    public onBuildObservable = new Observable<FrameGraph>();\r\n\r\n    /**\r\n     * Gets the engine used by the frame graph\r\n     */\r\n    public get engine() {\r\n        return this._engine;\r\n    }\r\n\r\n    /**\r\n     * Gets the scene used by the frame graph\r\n     */\r\n    public get scene() {\r\n        return this._scene;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of tasks in the frame graph\r\n     */\r\n    public get tasks() {\r\n        return this._tasks;\r\n    }\r\n\r\n    /**\r\n     * Indicates whether the execution of the frame graph is paused (default is false)\r\n     */\r\n    public pausedExecution = false;\r\n\r\n    /**\r\n     * Gets the node render graph linked to the frame graph (if any)\r\n     * @returns the linked node render graph or null if none\r\n     */\r\n    public getLinkedNodeRenderGraph(): Nullable<NodeRenderGraph> {\r\n        return this._linkedNodeRenderGraph;\r\n    }\r\n\r\n    /**\r\n     * Constructs the frame graph\r\n     * @param scene defines the scene the frame graph is associated with\r\n     * @param debugTextures defines a boolean indicating that textures created by the frame graph should be visible in the inspector (default is false)\r\n     * @param _linkedNodeRenderGraph defines the linked node render graph (if any)\r\n     */\r\n    constructor(\r\n        scene: Scene,\r\n        debugTextures = false,\r\n        private readonly _linkedNodeRenderGraph: Nullable<NodeRenderGraph> = null\r\n    ) {\r\n        this._scene = scene;\r\n        this._engine = scene.getEngine();\r\n        this._importPromise = this._engine.isWebGPU ? import(\"../Engines/WebGPU/Extensions/engine.multiRender\") : import(\"../Engines/Extensions/engine.multiRender\");\r\n        this.textureManager = new FrameGraphTextureManager(this._engine, debugTextures, scene);\r\n        this._passContext = new FrameGraphContext(this._engine, this.textureManager, scene);\r\n        this._renderContext = new FrameGraphRenderContext(this._engine, this.textureManager, scene);\r\n\r\n        this._scene.addFrameGraph(this);\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of the frame graph\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"FrameGraph\";\r\n    }\r\n\r\n    /**\r\n     * Gets a task by name\r\n     * @param name Name of the task to get\r\n     * @returns The task or undefined if not found\r\n     */\r\n    public getTaskByName<T extends FrameGraphTask>(name: string): T | undefined {\r\n        return this._tasks.find((t) => t.name === name) as T;\r\n    }\r\n\r\n    /**\r\n     * Gets all tasks of a specific type\r\n     * @param taskType Type of the task(s) to get\r\n     * @returns The list of tasks of the specified type\r\n     */\r\n    public getTasksByType<T extends FrameGraphTask>(taskType: new (...args: any[]) => T): T[] {\r\n        return this._tasks.filter((t) => t instanceof taskType) as T[];\r\n    }\r\n\r\n    /**\r\n     * Gets all tasks of a specific type, based on their class name\r\n     * @param taskClassName Class name(s) of the task(s) to get\r\n     * @returns The list of tasks of the specified type\r\n     */\r\n    public getTasksByClassName<T extends FrameGraphTask>(taskClassName: string | string[]): T[] {\r\n        return Array.isArray(taskClassName)\r\n            ? (this._tasks.filter((t) => taskClassName.includes(t.getClassName())) as T[])\r\n            : (this._tasks.filter((t) => t.getClassName() === taskClassName) as T[]);\r\n    }\r\n\r\n    /**\r\n     * Adds a task to the frame graph\r\n     * @param task Task to add\r\n     */\r\n    public addTask(task: FrameGraphTask): void {\r\n        if (this._currentProcessedTask !== null) {\r\n            throw new Error(`FrameGraph.addTask: Can't add the task \"${task.name}\" while another task is currently building (task: ${this._currentProcessedTask.name}).`);\r\n        }\r\n\r\n        this._tasks.push(task);\r\n        this._initAsyncPromises.push(task.initAsync());\r\n    }\r\n\r\n    /**\r\n     * Adds a pass to a task. This method can only be called during a Task.record execution.\r\n     * @param name The name of the pass\r\n     * @param whenTaskDisabled If true, the pass will be added to the list of passes to execute when the task is disabled (default is false)\r\n     * @returns The render pass created\r\n     */\r\n    public addPass(name: string, whenTaskDisabled = false): FrameGraphPass<FrameGraphContext> {\r\n        return this._addPass(name, FrameGraphPassType.Normal, whenTaskDisabled) as FrameGraphPass<FrameGraphContext>;\r\n    }\r\n\r\n    /**\r\n     * Adds a render pass to a task. This method can only be called during a Task.record execution.\r\n     * @param name The name of the pass\r\n     * @param whenTaskDisabled If true, the pass will be added to the list of passes to execute when the task is disabled (default is false)\r\n     * @returns The render pass created\r\n     */\r\n    public addRenderPass(name: string, whenTaskDisabled = false): FrameGraphRenderPass {\r\n        return this._addPass(name, FrameGraphPassType.Render, whenTaskDisabled) as FrameGraphRenderPass;\r\n    }\r\n\r\n    /**\r\n     * Adds an object list pass to a task. This method can only be called during a Task.record execution.\r\n     * @param name The name of the pass\r\n     * @param whenTaskDisabled If true, the pass will be added to the list of passes to execute when the task is disabled (default is false)\r\n     * @returns The object list pass created\r\n     */\r\n    public addObjectListPass(name: string, whenTaskDisabled = false): FrameGraphObjectListPass {\r\n        return this._addPass(name, FrameGraphPassType.ObjectList, whenTaskDisabled) as FrameGraphObjectListPass;\r\n    }\r\n\r\n    private _addPass(name: string, passType: FrameGraphPassType, whenTaskDisabled = false): FrameGraphPass<FrameGraphContext> | FrameGraphRenderPass {\r\n        if (!this._currentProcessedTask) {\r\n            throw new Error(\"FrameGraph: A pass must be created during a Task.record execution only.\");\r\n        }\r\n\r\n        let pass: FrameGraphPass<FrameGraphContext> | FrameGraphRenderPass;\r\n\r\n        switch (passType) {\r\n            case FrameGraphPassType.Render:\r\n                pass = new FrameGraphRenderPass(name, this._currentProcessedTask, this._renderContext, this._engine);\r\n                break;\r\n            case FrameGraphPassType.ObjectList:\r\n                pass = new FrameGraphObjectListPass(name, this._currentProcessedTask, this._passContext, this._engine);\r\n                break;\r\n            default:\r\n                pass = new FrameGraphPass(name, this._currentProcessedTask, this._passContext);\r\n                break;\r\n        }\r\n\r\n        this._currentProcessedTask._addPass(pass, whenTaskDisabled);\r\n\r\n        return pass;\r\n    }\r\n\r\n    /** @internal */\r\n    public async _whenAsynchronousInitializationDoneAsync(): Promise<void> {\r\n        if (this._initAsyncPromises.length > 0) {\r\n            await Promise.all(this._initAsyncPromises);\r\n            this._initAsyncPromises.length = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Builds the frame graph.\r\n     * This method should be called after all tasks have been added to the frame graph (FrameGraph.addTask) and before the graph is executed (FrameGraph.execute).\r\n     * @param waitForReadiness If true, the method will wait for the frame graph to be ready before returning (default is true)\r\n     */\r\n    public async buildAsync(waitForReadiness = true): Promise<void> {\r\n        this.textureManager._releaseTextures(false);\r\n\r\n        this.pausedExecution = true;\r\n\r\n        try {\r\n            await this._importPromise;\r\n\r\n            await this._whenAsynchronousInitializationDoneAsync();\r\n\r\n            for (const task of this._tasks) {\r\n                task._reset();\r\n\r\n                this._currentProcessedTask = task;\r\n                this.textureManager._isRecordingTask = true;\r\n\r\n                task.record();\r\n\r\n                this.textureManager._isRecordingTask = false;\r\n                this._currentProcessedTask = null;\r\n            }\r\n\r\n            this.textureManager._allocateTextures(this.optimizeTextureAllocation ? this._tasks : undefined);\r\n\r\n            for (const task of this._tasks) {\r\n                task._checkTask();\r\n            }\r\n\r\n            for (const task of this._tasks) {\r\n                task.onTexturesAllocatedObservable.notifyObservers(this._renderContext);\r\n            }\r\n\r\n            for (const task of this._tasks) {\r\n                task._initializePasses();\r\n            }\r\n\r\n            this.onBuildObservable.notifyObservers(this);\r\n\r\n            if (waitForReadiness) {\r\n                await this.whenReadyAsync();\r\n            }\r\n        } catch (e) {\r\n            this._tasks.length = 0;\r\n            this._currentProcessedTask = null;\r\n            this.textureManager._isRecordingTask = false;\r\n            throw e;\r\n        } finally {\r\n            this.pausedExecution = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks if the frame graph is ready to be executed.\r\n     * Note that you can use the whenReadyAsync method to wait for the frame graph to be ready.\r\n     * @returns True if the frame graph is ready to be executed, else false\r\n     */\r\n    public isReady(): boolean {\r\n        let ready = this._renderContext._isReady();\r\n        for (const task of this._tasks) {\r\n            ready &&= task.isReady();\r\n        }\r\n        return ready;\r\n    }\r\n\r\n    /**\r\n     * Returns a promise that resolves when the frame graph is ready to be executed.\r\n     * In general, calling “await buildAsync()” should suffice, as this function also waits for readiness by default.\r\n     * @param timeStep Time step in ms between retries (default is 16)\r\n     * @param maxTimeout Maximum time in ms to wait for the graph to be ready (default is 10000)\r\n     * @returns The promise that resolves when the graph is ready\r\n     */\r\n    public async whenReadyAsync(timeStep = 16, maxTimeout = 10000): Promise<void> {\r\n        let firstNotReadyTask: FrameGraphTask | null = null;\r\n\r\n        return await new Promise((resolve, reject) => {\r\n            this._whenReadyAsyncCancel = _RetryWithInterval(\r\n                () => {\r\n                    let ready = this._renderContext._isReady();\r\n                    for (const task of this._tasks) {\r\n                        const taskIsReady = task.isReady();\r\n                        if (!taskIsReady && !firstNotReadyTask) {\r\n                            firstNotReadyTask = task;\r\n                        }\r\n                        ready &&= taskIsReady;\r\n                    }\r\n                    return ready;\r\n                },\r\n                () => {\r\n                    this._whenReadyAsyncCancel = null;\r\n                    resolve();\r\n                },\r\n                (err, isTimeout) => {\r\n                    this._whenReadyAsyncCancel = null;\r\n                    if (!isTimeout) {\r\n                        Logger.Error(\"FrameGraph: An unexpected error occurred while waiting for the frame graph to be ready.\");\r\n                        if (err) {\r\n                            Logger.Error(err);\r\n                            if (err.stack) {\r\n                                Logger.Error(err.stack);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        Logger.Error(\r\n                            `FrameGraph: Timeout while waiting for the frame graph to be ready.${firstNotReadyTask ? ` First task not ready: ${firstNotReadyTask.name}` : \"\"}`\r\n                        );\r\n                        if (err) {\r\n                            Logger.Error(err);\r\n                        }\r\n                    }\r\n                    reject(new Error(err));\r\n                },\r\n                timeStep,\r\n                maxTimeout\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Executes the frame graph.\r\n     */\r\n    public execute(): void {\r\n        if (this.pausedExecution) {\r\n            return;\r\n        }\r\n\r\n        this._renderContext.restoreDefaultFramebuffer();\r\n\r\n        this.textureManager._updateHistoryTextures();\r\n\r\n        for (const task of this._tasks) {\r\n            task._execute();\r\n        }\r\n\r\n        this._renderContext.restoreDefaultFramebuffer();\r\n    }\r\n\r\n    /**\r\n     * Clears the frame graph (remove the tasks and release the textures).\r\n     * The frame graph can be built again after this method is called.\r\n     */\r\n    public clear(): void {\r\n        this._whenReadyAsyncCancel?.();\r\n        this._whenReadyAsyncCancel = null;\r\n\r\n        for (const task of this._tasks) {\r\n            task._reset();\r\n        }\r\n\r\n        this._tasks.length = 0;\r\n        this.textureManager._releaseTextures();\r\n        this._currentProcessedTask = null;\r\n    }\r\n\r\n    /**\r\n     * Disposes the frame graph\r\n     */\r\n    public dispose(): void {\r\n        this._whenReadyAsyncCancel?.();\r\n        this._whenReadyAsyncCancel = null;\r\n        this.clear();\r\n        this.textureManager._dispose();\r\n        this._renderContext._dispose();\r\n\r\n        this._scene.removeFrameGraph(this);\r\n    }\r\n}\r\n"]}