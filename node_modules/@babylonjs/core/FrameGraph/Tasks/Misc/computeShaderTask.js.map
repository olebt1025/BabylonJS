{"version":3,"file":"computeShaderTask.js","sourceRoot":"","sources":["../../../../../../dev/core/src/FrameGraph/Tasks/Misc/computeShaderTask.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\r\n    BaseTexture,\r\n    DataBuffer,\r\n    ExternalTexture,\r\n    FrameGraph,\r\n    FrameGraphContext,\r\n    FrameGraphPass,\r\n    IComputeShaderOptions,\r\n    IComputeShaderPath,\r\n    InternalTexture,\r\n    StorageBuffer,\r\n    TextureSampler,\r\n    VideoTexture,\r\n} from \"core/index\";\r\nimport { FrameGraphTask } from \"../../frameGraphTask\";\r\nimport { ComputeShader } from \"core/Compute/computeShader\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { UniformBuffer } from \"core/Materials/uniformBuffer\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/**\r\n * Task used to execute a compute shader (WebGPU only)\r\n */\r\nexport class FrameGraphComputeShaderTask extends FrameGraphTask {\r\n    private readonly _notSupported: boolean;\r\n    private readonly _cs: ComputeShader;\r\n    private readonly _ubo: { [name: string]: { ubo: UniformBuffer; autoUpdate: boolean } };\r\n\r\n    /**\r\n     * Defines the dispatch size for the compute shader\r\n     */\r\n    public dispatchSize = new Vector3(1, 1, 1);\r\n\r\n    /**\r\n     * Defines an indirect dispatch buffer and offset.\r\n     * If set, this will be used instead of the dispatchSize property and an indirect dispatch will be performed.\r\n     * \"offset\" is the offset in the buffer where the workgroup counts are stored (default: 0)\r\n     */\r\n    public indirectDispatch?: { buffer: StorageBuffer | DataBuffer; offset?: number };\r\n\r\n    /**\r\n     * An optional execute function that will be called at the beginning of the task execution\r\n     */\r\n    public execute?: (context: FrameGraphContext) => void;\r\n\r\n    /**\r\n     * Gets the compute shader used by the task\r\n     */\r\n    public get computeShader(): ComputeShader {\r\n        return this._cs;\r\n    }\r\n\r\n    /**\r\n     * Gets a uniform buffer created by a call to createUniformBuffer()\r\n     * @param name Name of the uniform buffer\r\n     * @returns The uniform buffer\r\n     */\r\n    public getUniformBuffer(name: string): UniformBuffer {\r\n        return this._ubo[name]?.ubo;\r\n    }\r\n\r\n    /**\r\n     * Creates a new compute shader task.\r\n     * @param name The name of the task.\r\n     * @param frameGraph The frame graph the task belongs to.\r\n     * @param shaderPath Defines the route to the shader code in one of three ways:\r\n     *  * object: \\{ compute: \"custom\" \\}, used with ShaderStore.ShadersStoreWGSL[\"customComputeShader\"]\r\n     *  * object: \\{ computeElement: \"HTMLElementId\" \\}, used with shader code in script tags\r\n     *  * object: \\{ computeSource: \"compute shader code string\" \\}, where the string contains the shader code\r\n     *  * string: try first to find the code in ShaderStore.ShadersStoreWGSL[shaderPath + \"ComputeShader\"]. If not, assumes it is a file with name shaderPath.compute.fx in index.html folder.\r\n     * @param options Define the options used to create the shader\r\n     */\r\n    constructor(name: string, frameGraph: FrameGraph, shaderPath: IComputeShaderPath | string, options: Partial<IComputeShaderOptions> = {}) {\r\n        super(name, frameGraph);\r\n\r\n        if (!frameGraph.engine.getCaps().supportComputeShaders) {\r\n            this._notSupported = true;\r\n            Logger.Error(\"This engine does not support compute shaders!\");\r\n            return;\r\n        }\r\n\r\n        this._notSupported = false;\r\n        this._cs = new ComputeShader(name + \"_cs\", frameGraph.engine, shaderPath, options);\r\n        this._ubo = {};\r\n    }\r\n\r\n    public override isReady(): boolean {\r\n        return this._notSupported ? true : this._cs.isReady();\r\n    }\r\n\r\n    /**\r\n     * Creates a uniform buffer and binds it to the shader\r\n     * @param name Name of the uniform buffer\r\n     * @param description Description of the uniform buffer: names and sizes (in floats) of the uniforms\r\n     * @param autoUpdate If the UBO must be updated automatically before each dispatch (default: true)\r\n     * @returns The created uniform buffer\r\n     */\r\n    public createUniformBuffer(name: string, description: { [name: string]: number }, autoUpdate = true): UniformBuffer {\r\n        const uBuffer = new UniformBuffer(this._frameGraph.engine);\r\n\r\n        this._ubo[name] = { ubo: uBuffer, autoUpdate };\r\n\r\n        for (const key in description) {\r\n            uBuffer.addUniform(key, description[key]);\r\n        }\r\n\r\n        this._cs.setUniformBuffer(name, uBuffer);\r\n\r\n        return uBuffer;\r\n    }\r\n\r\n    /**\r\n     * Binds a texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     * @param bindSampler Bind the sampler corresponding to the texture (default: true). The sampler will be bound just before the binding index of the texture\r\n     */\r\n    public setTexture(name: string, texture: BaseTexture, bindSampler = true): void {\r\n        this._cs.setTexture(name, texture, bindSampler);\r\n    }\r\n\r\n    /**\r\n     * Binds an internal texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     */\r\n    public setInternalTexture(name: string, texture: InternalTexture): void {\r\n        this._cs.setInternalTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Binds a storage texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     */\r\n    public setStorageTexture(name: string, texture: BaseTexture): void {\r\n        this._cs.setStorageTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Binds an external texture to the shader\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     */\r\n    public setExternalTexture(name: string, texture: ExternalTexture): void {\r\n        this._cs.setExternalTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Binds a video texture to the shader (by binding the external texture attached to this video)\r\n     * @param name Binding name of the texture\r\n     * @param texture Texture to bind\r\n     * @returns true if the video texture was successfully bound, else false. false will be returned if the current engine does not support external textures\r\n     */\r\n    public setVideoTexture(name: string, texture: VideoTexture) {\r\n        return this._cs.setVideoTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Binds a uniform buffer to the shader\r\n     * @param name Binding name of the buffer\r\n     * @param buffer Buffer to bind\r\n     */\r\n    public setUniformBuffer(name: string, buffer: UniformBuffer | DataBuffer): void {\r\n        this._cs.setUniformBuffer(name, buffer);\r\n    }\r\n\r\n    /**\r\n     * Binds a storage buffer to the shader\r\n     * @param name Binding name of the buffer\r\n     * @param buffer Buffer to bind\r\n     */\r\n    public setStorageBuffer(name: string, buffer: StorageBuffer | DataBuffer): void {\r\n        this._cs.setStorageBuffer(name, buffer);\r\n    }\r\n\r\n    /**\r\n     * Binds a texture sampler to the shader\r\n     * @param name Binding name of the sampler\r\n     * @param sampler Sampler to bind\r\n     */\r\n    public setTextureSampler(name: string, sampler: TextureSampler): void {\r\n        this._cs.setTextureSampler(name, sampler);\r\n    }\r\n\r\n    public override getClassName(): string {\r\n        return \"FrameGraphComputeShaderTask\";\r\n    }\r\n\r\n    public record(skipCreationOfDisabledPasses?: boolean): FrameGraphPass<FrameGraphContext> {\r\n        const pass = this._frameGraph.addPass(this.name);\r\n\r\n        if (this._notSupported) {\r\n            pass.setExecuteFunc(() => {});\r\n        } else {\r\n            pass.setExecuteFunc((context) => {\r\n                this.execute?.(context);\r\n\r\n                for (const key in this._ubo) {\r\n                    const uboEntry = this._ubo[key];\r\n                    if (uboEntry.autoUpdate) {\r\n                        uboEntry.ubo.update();\r\n                    }\r\n                }\r\n\r\n                if (this.indirectDispatch) {\r\n                    context.pushDebugGroup(`Indirect dispatch compute shader (${this.name})`);\r\n                    this._cs.dispatchIndirect(this.indirectDispatch.buffer, this.indirectDispatch.offset);\r\n                    context.popDebugGroup();\r\n                } else {\r\n                    context.pushDebugGroup(`Dispatch compute shader (${this.name})`);\r\n                    this._cs.dispatch(this.dispatchSize.x, this.dispatchSize.y, this.dispatchSize.z);\r\n                    context.popDebugGroup();\r\n                }\r\n            });\r\n        }\r\n\r\n        if (!skipCreationOfDisabledPasses) {\r\n            const passDisabled = this._frameGraph.addPass(this.name + \"_disabled\", true);\r\n\r\n            passDisabled.setExecuteFunc(() => {});\r\n        }\r\n\r\n        return pass;\r\n    }\r\n\r\n    public override dispose(): void {\r\n        for (const key in this._ubo) {\r\n            this._ubo[key].ubo.dispose();\r\n        }\r\n        super.dispose();\r\n    }\r\n}\r\n"]}