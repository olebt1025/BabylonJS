{"version":3,"file":"frameGraphRenderContext.js","sourceRoot":"","sources":["../../../../dev/core/src/FrameGraph/frameGraphRenderContext.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\r\n    Nullable,\r\n    AbstractEngine,\r\n    DrawWrapper,\r\n    IColor4Like,\r\n    Layer,\r\n    FrameGraphTextureHandle,\r\n    Effect,\r\n    FrameGraphTextureManager,\r\n    ObjectRenderer,\r\n    Scene,\r\n    FrameGraphRenderTarget,\r\n    InternalTexture,\r\n    UtilityLayerRenderer,\r\n    IStencilState,\r\n    IStencilStateProperties,\r\n} from \"core/index\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { EffectRenderer } from \"../Materials/effectRenderer\";\r\nimport { CopyTextureToTexture } from \"../Misc/copyTextureToTexture\";\r\nimport { FrameGraphContext } from \"./frameGraphContext\";\r\nimport { IsDepthTexture } from \"../Materials/Textures/textureHelper.functions\";\r\n\r\nconst SamplingModeHasMipMapFiltering = [\r\n    false, // not used\r\n    false, // TEXTURE_NEAREST_SAMPLINGMODE / TEXTURE_NEAREST_NEAREST\r\n    false, // TEXTURE_BILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR\r\n    true, // TEXTURE_TRILINEAR_SAMPLINGMODE / TEXTURE_LINEAR_LINEAR_MIPLINEAR\r\n    true, // TEXTURE_NEAREST_NEAREST_MIPNEAREST\r\n    true, // TEXTURE_NEAREST_LINEAR_MIPNEAREST\r\n    true, // TEXTURE_NEAREST_LINEAR_MIPLINEAR\r\n    false, // TEXTURE_NEAREST_LINEAR\r\n    true, // TEXTURE_NEAREST_NEAREST_MIPLINEAR\r\n    true, // TEXTURE_LINEAR_NEAREST_MIPNEAREST\r\n    true, // TEXTURE_LINEAR_NEAREST_MIPLINEAR\r\n    true, // TEXTURE_LINEAR_LINEAR_MIPNEAREST\r\n    false, // TEXTURE_LINEAR_NEAREST\r\n];\r\n\r\n/**\r\n * Frame graph context used render passes.\r\n */\r\nexport class FrameGraphRenderContext extends FrameGraphContext {\r\n    private readonly _effectRenderer: EffectRenderer;\r\n    private readonly _effectRendererBack: EffectRenderer;\r\n    private _currentRenderTarget: FrameGraphRenderTarget | undefined;\r\n    private _renderTargetIsBound = true;\r\n    private readonly _copyTexture: CopyTextureToTexture;\r\n    private readonly _copyDepthTexture: CopyTextureToTexture;\r\n\r\n    private static _IsObjectRenderer(value: Layer | ObjectRenderer | UtilityLayerRenderer): value is ObjectRenderer {\r\n        return (value as ObjectRenderer).initRender !== undefined;\r\n    }\r\n\r\n    /** @internal */\r\n    constructor(engine: AbstractEngine, textureManager: FrameGraphTextureManager, scene: Scene) {\r\n        super(engine, textureManager, scene);\r\n        this._effectRenderer = new EffectRenderer(this._engine);\r\n        this._effectRendererBack = new EffectRenderer(this._engine, {\r\n            positions: [1, 1, -1, 1, -1, -1, 1, -1],\r\n            indices: [0, 2, 1, 0, 3, 2],\r\n        });\r\n        this._copyTexture = new CopyTextureToTexture(this._engine);\r\n        this._copyDepthTexture = new CopyTextureToTexture(this._engine, true);\r\n    }\r\n\r\n    /**\r\n     * Checks whether a texture handle points to the backbuffer's color or depth texture\r\n     * @param handle The handle to check\r\n     * @returns True if the handle points to the backbuffer's color or depth texture, otherwise false\r\n     */\r\n    public isBackbuffer(handle: FrameGraphTextureHandle): boolean {\r\n        return this._textureManager._isBackbuffer(handle);\r\n    }\r\n\r\n    /**\r\n     * Checks whether a texture handle points to the backbuffer's color texture\r\n     * @param handle The handle to check\r\n     * @returns True if the handle points to the backbuffer's color texture, otherwise false\r\n     */\r\n    public isBackbufferColor(handle: FrameGraphTextureHandle): boolean {\r\n        return this._textureManager.isBackbufferColor(handle);\r\n    }\r\n\r\n    /**\r\n     * Checks whether a texture handle points to the backbuffer's depth texture\r\n     * @param handle The handle to check\r\n     * @returns True if the handle points to the backbuffer's depth texture, otherwise false\r\n     */\r\n    public isBackbufferDepthStencil(handle: FrameGraphTextureHandle): boolean {\r\n        return this._textureManager.isBackbufferDepthStencil(handle);\r\n    }\r\n\r\n    /**\r\n     * Creates a (frame graph) render target wrapper\r\n     * Note that renderTargets or renderTargetDepth can be undefined, but not both at the same time!\r\n     * @param name Name of the render target wrapper\r\n     * @param renderTargets Render target handles (textures) to use\r\n     * @param renderTargetDepth Render target depth handle (texture) to use\r\n     * @param depthReadOnly If true, the depth buffer will be read-only\r\n     * @param stencilReadOnly If true, the stencil buffer will be read-only\r\n     * @returns The created render target wrapper\r\n     */\r\n    public createRenderTarget(\r\n        name: string,\r\n        renderTargets?: FrameGraphTextureHandle | FrameGraphTextureHandle[],\r\n        renderTargetDepth?: FrameGraphTextureHandle,\r\n        depthReadOnly?: boolean,\r\n        stencilReadOnly?: boolean\r\n    ): FrameGraphRenderTarget {\r\n        return this._textureManager.createRenderTarget(name, renderTargets, renderTargetDepth, depthReadOnly, stencilReadOnly);\r\n    }\r\n\r\n    /**\r\n     * Clears the current render buffer or the current render target (if any is set up)\r\n     * @param color Defines the color to use\r\n     * @param backBuffer Defines if the back buffer must be cleared\r\n     * @param depth Defines if the depth buffer must be cleared\r\n     * @param stencil Defines if the stencil buffer must be cleared\r\n     * @param stencilClearValue Defines the value to use to clear the stencil buffer (default is 0)\r\n     */\r\n    public clear(color: Nullable<IColor4Like>, backBuffer: boolean, depth: boolean, stencil?: boolean, stencilClearValue = 0): void {\r\n        this._applyRenderTarget();\r\n        this._engine.clear(color, backBuffer, depth, stencil, stencilClearValue);\r\n    }\r\n\r\n    /**\r\n     * Clears the color attachments of the current render target\r\n     * @param color Defines the color to use\r\n     * @param attachments The attachments to clear\r\n     */\r\n    public clearColorAttachments(color: Nullable<IColor4Like>, attachments: number[]): void {\r\n        this._applyRenderTarget();\r\n        this._engine.bindAttachments(attachments);\r\n        this._engine.clear(color, true, false, false);\r\n    }\r\n\r\n    /**\r\n     * Clears all attachments (color(s) + depth/stencil) of the current render target\r\n     * @param color Defines the color to use\r\n     * @param attachments The attachments to clear\r\n     * @param backBuffer Defines if the back buffer must be cleared\r\n     * @param depth Defines if the depth buffer must be cleared\r\n     * @param stencil Defines if the stencil buffer must be cleared\r\n     * @param stencilClearValue Defines the value to use to clear the stencil buffer (default is 0)\r\n     */\r\n    public clearAttachments(color: Nullable<IColor4Like>, attachments: number[], backBuffer: boolean, depth: boolean, stencil?: boolean, stencilClearValue = 0): void {\r\n        this._applyRenderTarget();\r\n        this._engine.bindAttachments(attachments);\r\n        this._engine.clear(color, backBuffer, depth, stencil, stencilClearValue);\r\n    }\r\n\r\n    /**\r\n     * Binds the attachments to the current render target\r\n     * @param attachments The attachments to bind\r\n     */\r\n    public bindAttachments(attachments: number[]): void {\r\n        this._applyRenderTarget();\r\n        this._engine.bindAttachments(attachments);\r\n    }\r\n\r\n    /**\r\n     * Generates mipmaps for the current render target\r\n     * @param handle Optional handle of the texture to generate mipmaps for (if not provided, will generate mipmaps for all textures in the current render target)\r\n     */\r\n    public generateMipMaps(handle?: FrameGraphTextureHandle): void {\r\n        if (handle !== undefined) {\r\n            const internalTexture = this._textureManager.getTextureFromHandle(handle);\r\n            if (internalTexture) {\r\n                this._engine.generateMipmaps(internalTexture);\r\n            }\r\n            return;\r\n        }\r\n        if (this._currentRenderTarget?.renderTargetWrapper === undefined) {\r\n            return;\r\n        }\r\n\r\n        if (this._engine._currentRenderTarget && (!this._engine.isWebGPU || this._renderTargetIsBound)) {\r\n            // we can't generate the mipmaps if the render target (which is the texture we want to generate mipmaps for) is bound\r\n            // Also, for some reasons, on WebGL2, generating mipmaps doesn't work if a render target is bound, even if it's not the texture we want to generate mipmaps for...\r\n            this._engine.unBindFramebuffer(this._engine._currentRenderTarget);\r\n            this._renderTargetIsBound = false;\r\n        }\r\n\r\n        const textures = this._currentRenderTarget.renderTargetWrapper.textures;\r\n        if (textures) {\r\n            for (const texture of textures) {\r\n                this._engine.generateMipmaps(texture);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the texture sampling mode for a given texture handle\r\n     * @param handle Handle of the texture to set the sampling mode for\r\n     * @param samplingMode Sampling mode to set\r\n     */\r\n    public setTextureSamplingMode(handle: FrameGraphTextureHandle, samplingMode: number): void {\r\n        const internalTexture = this._textureManager.getTextureFromHandle(handle);\r\n        if (internalTexture && internalTexture.samplingMode !== samplingMode) {\r\n            internalTexture.useMipMaps = SamplingModeHasMipMapFiltering[samplingMode];\r\n            this._engine.updateTextureSamplingMode(samplingMode, internalTexture);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds a texture handle to a given effect (resolves the handle to a texture and binds it to the effect)\r\n     * @param effect The effect to bind the texture to\r\n     * @param name The name of the texture in the effect\r\n     * @param handle The handle of the texture to bind\r\n     */\r\n    public bindTextureHandle(effect: Effect, name: string, handle: FrameGraphTextureHandle): void {\r\n        let texture: Nullable<InternalTexture>;\r\n\r\n        const historyEntry = this._textureManager._historyTextures.get(handle);\r\n        if (historyEntry) {\r\n            texture = historyEntry.textures[historyEntry.index]; // texture we write to in this frame\r\n            if (\r\n                this._currentRenderTarget !== undefined &&\r\n                this._currentRenderTarget.renderTargetWrapper !== undefined &&\r\n                this._currentRenderTarget.renderTargetWrapper.textures!.includes(texture!)\r\n            ) {\r\n                // If the current render target renders to the history write texture, we bind the read texture instead\r\n                texture = historyEntry.textures[historyEntry.index ^ 1];\r\n            }\r\n        } else {\r\n            texture = this._textureManager._textures.get(handle)!.texture;\r\n        }\r\n\r\n        effect._bindTexture(name, texture);\r\n    }\r\n\r\n    /**\r\n     * Applies a full-screen effect to the current render target\r\n     * @param drawWrapper The draw wrapper containing the effect to apply\r\n     * @param customBindings The custom bindings to use when applying the effect (optional)\r\n     * @param stencilState The stencil state to use when applying the effect (optional)\r\n     * @param disableColorWrite If true, color write will be disabled when applying the effect (optional)\r\n     * @param drawBackFace If true, the fullscreen quad will be drawn as a back face (in CW - optional)\r\n     * @param depthTest If true, depth testing will be enabled when applying the effect (default is false)\r\n     * @param noViewport If true, the current viewport will be left unchanged (optional). If false or undefined, the viewport will be set to the full render target size.\r\n     * @param alphaMode The alpha mode to use when applying the effect (default is ALPHA_DISABLE)\r\n     * @returns True if the effect was applied, otherwise false (effect not ready)\r\n     */\r\n    public applyFullScreenEffect(\r\n        drawWrapper: DrawWrapper,\r\n        customBindings?: () => void,\r\n        stencilState?: IStencilState | IStencilStateProperties,\r\n        disableColorWrite?: boolean,\r\n        drawBackFace?: boolean,\r\n        depthTest?: boolean,\r\n        noViewport?: boolean,\r\n        alphaMode = Constants.ALPHA_DISABLE\r\n    ): boolean {\r\n        if (!drawWrapper.effect?.isReady()) {\r\n            return false;\r\n        }\r\n\r\n        this._applyRenderTarget();\r\n\r\n        const engineDepthMask = this._engine.getDepthWrite(); // for some reasons, depthWrite is not restored by EffectRenderer.restoreStates\r\n        const engineDepthFunc = this._engine.getDepthFunction();\r\n\r\n        const effectRenderer = drawBackFace ? this._effectRendererBack : this._effectRenderer;\r\n\r\n        effectRenderer.saveStates();\r\n        if (!noViewport) {\r\n            effectRenderer.setViewport();\r\n        }\r\n\r\n        this._engine.enableEffect(drawWrapper);\r\n        this._engine.setState(false, undefined, undefined, undefined, undefined, stencilState);\r\n        this._engine.setDepthBuffer(!!depthTest);\r\n        if (disableColorWrite) {\r\n            this._engine.setColorWrite(false);\r\n        }\r\n        this._engine.setDepthWrite(false);\r\n        this._engine.setAlphaMode(alphaMode);\r\n\r\n        effectRenderer.bindBuffers(drawWrapper.effect);\r\n        customBindings?.();\r\n        effectRenderer.draw();\r\n        effectRenderer.restoreStates();\r\n        if (disableColorWrite) {\r\n            this._engine.setColorWrite(true);\r\n        }\r\n        this._engine.setDepthWrite(engineDepthMask);\r\n        if (engineDepthFunc) {\r\n            this._engine.setDepthFunction(engineDepthFunc);\r\n        }\r\n        this._engine.setAlphaMode(Constants.ALPHA_DISABLE);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Copies a texture to the current render target\r\n     * @param sourceTexture The source texture to copy from\r\n     * @param forceCopyToBackbuffer If true, the copy will be done to the back buffer regardless of the current render target\r\n     * @param noViewport If true, the current viewport will be left unchanged (optional). If false or undefined, the viewport will be set to the full render target size.\r\n     * @param lodLevel The LOD level to use when copying the texture (default: 0).\r\n     */\r\n    public copyTexture(sourceTexture: FrameGraphTextureHandle, forceCopyToBackbuffer = false, noViewport?: boolean, lodLevel = 0): void {\r\n        if (forceCopyToBackbuffer) {\r\n            this.bindRenderTarget();\r\n        }\r\n\r\n        const texture = this._textureManager.getTextureFromHandle(sourceTexture, true)!;\r\n        const copyTexture = IsDepthTexture(texture.format) ? this._copyDepthTexture : this._copyTexture;\r\n\r\n        copyTexture.source = texture;\r\n        copyTexture.lodLevel = lodLevel;\r\n\r\n        this.applyFullScreenEffect(\r\n            copyTexture.effectWrapper.drawWrapper,\r\n            () => {\r\n                copyTexture.effectWrapper.onApplyObservable.notifyObservers({});\r\n            },\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            undefined,\r\n            noViewport\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Renders a RenderTargetTexture or a layer\r\n     * @param object The RenderTargetTexture/Layer to render\r\n     * @param viewportWidth The width of the viewport (optional for Layer, but mandatory for ObjectRenderer)\r\n     * @param viewportHeight The height of the viewport (optional for Layer, but mandatory for ObjectRenderer)\r\n     * @param restoreDefaultFramebuffer If true, the default framebuffer will be restored after rendering (default: false)\r\n     */\r\n    public render(object: Layer | ObjectRenderer | UtilityLayerRenderer, viewportWidth?: number, viewportHeight?: number, restoreDefaultFramebuffer = false): void {\r\n        if (FrameGraphRenderContext._IsObjectRenderer(object)) {\r\n            this._scene._intermediateRendering = true;\r\n            if (object.shouldRender()) {\r\n                this._scene.incrementRenderId();\r\n                this._scene.resetCachedMaterial();\r\n\r\n                object.prepareRenderList();\r\n\r\n                object.initRender(viewportWidth!, viewportHeight!);\r\n\r\n                this._applyRenderTarget();\r\n\r\n                object.render();\r\n\r\n                object.finishRender();\r\n\r\n                if (restoreDefaultFramebuffer) {\r\n                    this.restoreDefaultFramebuffer();\r\n                }\r\n            }\r\n            this._scene._intermediateRendering = false;\r\n        } else {\r\n            this._applyRenderTarget();\r\n            object.render();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Binds a render target texture so that upcoming draw calls will render to it\r\n     * Note: it is a lazy operation, so the render target will only be bound when needed. This way, it is possible to call\r\n     *   this method several times with different render targets without incurring the cost of binding if no draw calls are made\r\n     * @param renderTarget The handle of the render target texture to bind (default: undefined, meaning \"back buffer\"). Pass an array for MRT rendering.\r\n     * @param applyImmediately If true, the render target will be applied immediately (otherwise it will be applied at first use). Default is false (delayed application).\r\n     */\r\n    public bindRenderTarget(renderTarget?: FrameGraphRenderTarget, applyImmediately = false): void {\r\n        this._currentRenderTarget = renderTarget?.renderTargetWrapper === undefined ? undefined : renderTarget;\r\n        this._renderTargetIsBound = false;\r\n        if (applyImmediately) {\r\n            this._applyRenderTarget();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restores the default framebuffer (back buffer) as the current render target\r\n     */\r\n    public restoreDefaultFramebuffer(): void {\r\n        this._engine.restoreDefaultFramebuffer(true);\r\n        this._renderTargetIsBound = false;\r\n        this._currentRenderTarget = undefined;\r\n    }\r\n\r\n    /** @internal */\r\n    public _applyRenderTarget() {\r\n        if (this._renderTargetIsBound) {\r\n            return;\r\n        }\r\n\r\n        const renderTargetWrapper = this._currentRenderTarget?.renderTargetWrapper;\r\n\r\n        if (renderTargetWrapper === undefined) {\r\n            if (this._engine._currentRenderTarget) {\r\n                this._engine.restoreDefaultFramebuffer(true);\r\n            }\r\n        } else if (this._engine._currentRenderTarget !== renderTargetWrapper) {\r\n            if (this._engine._currentRenderTarget) {\r\n                this._engine.unBindFramebuffer(this._engine._currentRenderTarget);\r\n            }\r\n            this._engine.bindFramebuffer(renderTargetWrapper);\r\n        }\r\n\r\n        this._renderTargetIsBound = true;\r\n    }\r\n\r\n    /** @internal */\r\n    public _isReady(): boolean {\r\n        return this._copyTexture.isReady() && this._copyDepthTexture.isReady();\r\n    }\r\n\r\n    /** @internal */\r\n    public _dispose() {\r\n        this._effectRenderer.dispose();\r\n        this._effectRendererBack.dispose();\r\n        this._copyTexture.dispose();\r\n        this._copyDepthTexture.dispose();\r\n    }\r\n}\r\n"]}